(function () { const r = document.createElement("link").relList; if (r && r.supports && r.supports("modulepreload")) return; for (const t of document.querySelectorAll('link[rel="modulepreload"]')) n(t); new MutationObserver(t => { for (const o of t) if (o.type === "childList") for (const c of o.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && n(c) }).observe(document, { childList: !0, subtree: !0 }); function a(t) { const o = {}; return t.integrity && (o.integrity = t.integrity), t.referrerpolicy && (o.referrerPolicy = t.referrerpolicy), t.crossorigin === "use-credentials" ? o.credentials = "include" : t.crossorigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function n(t) { if (t.ep) return; t.ep = !0; const o = a(t); fetch(t.href, o) } })(); var s = (e => (e.syncAllRequest = "1", e.syncAllResponse = "2", e.profileChanged = "3", e.positionChanged = "57", e.positionChangedResponse = "4", e.positionChangedRequest = "53", e.positionChangedStop = "54", e.cameraStreamRequest = "5", e.cameraStreamResponse = "34", e.cameraStreamStop = "44", e.temperatureStreamRequest = "6", e.temperatureStreamResponse = "35", e.temperatureStreamStop = "43", e.bedLevelingRequest = "7", e.bedLevelingResponse = "8", e.terminalRequest = "9", e.terminalResponse = "10", e.terminalStop = "42", e.filamentModified = "58", e.filamentAssigned = "11", e.filamentRemoved = "12", e.filamentModifiedResponse = "40", e.filamentModifiedRequest = "52", e.filamentModifiedStop = "55", e.jobCreated = "13", e.jobFile = "41", e.jobDone = "14", e.jobCancelled = "15", e.jobFailed = "16", e.jobDeleted = "17", e.jobPause = "25", e.jobResume = "26", e.jobPrinting = "37", e.jobFilamentModified = "30", e.currentJobUpdatesResponse = "49", e.currentJobUpdatesRequest = "51", e.currentJobUpdatesStop = "56", e.jobRankChange = "18", e.actionCreated = "19", e.actionModified = "20", e.actionExecuted = "21", e.actionDeleted = "22", e.executeCustomGcode = "23", e.emergencyStop = "24", e.connectPrinter = "27", e.disconnectPrinter = "28", e.connectionOptionsChanged = "38", e.printerStateChanged = "39", e.refreshConnectionOptions = "45", e.filamentExtrude = "46", e.targetTool = "47", e.targetBed = "48", e.handshakeRequest = "50", e.handshakeResponse = "31", e.queuePaused = "29", e))(s || {}); function p(e) { return e.includes("Operational") ? "Operational" : e.includes("Printing") ? "Printing" : e.includes("Paused") ? "Paused" : "Offline" } async function f() { try { return await (await fetch("http://localhost:5000/api/printerprofiles/_default", { method: "GET", headers: { "X-API-KEY": d } })).json() } catch (e) { return console.error(e), {} } } async function h() { try { return await (await fetch("http://localhost:5000/api/connection", { method: "GET", headers: { "X-API-KEY": d } })).json() } catch (e) { return console.error(e), {} } } async function u() { try { return p((await (await fetch("http://localhost:5000/api/printer", { method: "GET", headers: { "X-API-KEY": d } })).json()).state.text) } catch { return "Offline" } } function m(e, r, a, n) { let t = { command: "connect", save: n, autoconnect: a }; e.includes("auto") || (t.port = e), r.includes("auto") || (t.baudrate = parseInt(r)), fetch("http://localhost:5000/api/connection", { method: "POST", headers: { "X-API-KEY": d, "Content-Type": "application/json" }, body: JSON.stringify(t) }) } function g() { fetch("http://localhost:5000/api/connection", { method: "POST", headers: { "X-API-KEY": d, "Content-Type": "application/json" }, body: JSON.stringify({ command: "disconnect" }) }) } function l(e, r, a) { const n = { label: a, metadata: e, serialization: "json", reliable: !0 }, t = i.connect(e, n); t.on("open", function () { t.send(JSON.stringify(r)), console.log("Sent:", r) }), t.on("error", function (o) { console.error("Could not send data: " + o) }) } function y(e, r, a, n) { switch (e = JSON.parse(e), n = JSON.parse(n), a) { case s.syncAllRequest: P(r); break; case s.connectPrinter: m(e.port, e.baudrate, e.autoconnect, e.save); break; case s.disconnectPrinter: g(); break; case s.jobCreated: break; case s.handshakeRequest: R(r); break; default: console.log("Unhandled label: " + a); break } } async function P(e) { let r = { printer_profile: {}, connection_options: {}, printer_state: {}, current_position: { x: 0, y: 0, z: 0, e: 0, speed: 0, relative: !1 }, bed_levelling_data: [], queue_state: { isQueuePaused: !1, queuePausedReason: "testing" }, current_job: { id: "" }, print_queue: [], jobs_history: [], current_filament: { current_filament: {} }, scripts: {} }; r.printer_profile = await f(), r.connection_options = (await h()).options, r.printer_state = { status: await u() }, l(e, r, s.syncAllResponse) } async function R(e) { l(e, { status: await u() }, s.handshakeResponse) } let i, d, S = setInterval(() => { window.peer && !i && (i = window.peer, w()), window.apiKey && !d && (d = window.apiKey), i && d && clearInterval(S) }, 1e3); function w() { console.log("callback functions called"), i.on("open", function (e) { console.log("Connected to peer server with id:" + e) }), i.on("connection", function (e) { console.log("Connected with peer:" + e.peer), e.on("data", function (r) { console.log("Received Label: " + e.label), y(r, e.peer, e.label, e.metadata), e.close() }) }), i.on("disconnected", function () { console.log("Disconnected from signaling server, reconnecting..."), i.reconnect() }), i.on("close", function () { console.log("Peer destroyed, cannot reconnect") }), i.on("error", function (e) { console.error(e) }) }
