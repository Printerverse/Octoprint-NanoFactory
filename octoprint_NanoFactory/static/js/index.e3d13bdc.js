var ja = Object.defineProperty; var Fa = (e, t, r) => t in e ? ja(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; var z = (e, t, r) => (Fa(e, typeof t != "symbol" ? t + "" : t, r), r); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function r(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerpolicy && (a.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? a.credentials = "include" : i.crossorigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function n(i) { if (i.ep) return; i.ep = !0; const a = r(i); fetch(i.href, a) } })(); var je = (e => (e.syncAllRequest = "1", e.syncAllResponse = "2", e.profileChanged = "3", e.positionChanged = "57", e.positionChangedResponse = "4", e.positionChangedRequest = "53", e.positionChangedStop = "54", e.cameraStreamRequest = "5", e.cameraStreamResponse = "34", e.cameraStreamStop = "44", e.temperatureStreamRequest = "6", e.temperatureStreamResponse = "35", e.temperatureStreamStop = "43", e.bedLevelingRequest = "7", e.bedLevelingResponse = "8", e.terminalRequest = "9", e.terminalResponse = "10", e.terminalStop = "42", e.filamentModified = "58", e.filamentAssigned = "11", e.filamentRemoved = "12", e.filamentModifiedResponse = "40", e.filamentModifiedRequest = "52", e.filamentModifiedStop = "55", e.jobCreated = "13", e.jobFile = "41", e.jobDone = "14", e.jobCancelled = "15", e.jobFailed = "16", e.jobDeleted = "17", e.jobPause = "25", e.jobResume = "26", e.jobPrinting = "37", e.jobFilamentModified = "30", e.currentJobUpdatesResponse = "49", e.currentJobUpdatesRequest = "51", e.currentJobUpdatesStop = "56", e.jobRankChange = "18", e.actionCreated = "19", e.actionModified = "20", e.actionExecuted = "21", e.actionDeleted = "22", e.executeCustomGcode = "23", e.emergencyStop = "24", e.connectPrinter = "27", e.disconnectPrinter = "28", e.connectionOptionsChanged = "38", e.printerStateChanged = "39", e.refreshConnectionOptions = "45", e.filamentExtrude = "46", e.targetTool = "47", e.targetBed = "48", e.handshakeRequest = "50", e.handshakeResponse = "31", e.queuePaused = "29", e))(je || {});/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var A = function () { return A = Object.assign || function (t) { for (var r, n = 1, i = arguments.length; n < i; n++) { r = arguments[n]; for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]) } return t }, A.apply(this, arguments) }; function Tr(e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) } var U = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, V = Object.keys, re = Array.isArray; typeof Promise < "u" && !U.Promise && (U.Promise = Promise); function oe(e, t) { return typeof t != "object" || V(t).forEach(function (r) { e[r] = t[r] }), e } var _t = Object.getPrototypeOf, Ka = {}.hasOwnProperty; function de(e, t) { return Ka.call(e, t) } function tt(e, t) { typeof t == "function" && (t = t(_t(e))), (typeof Reflect > "u" ? V : Reflect.ownKeys)(t).forEach(function (r) { De(e, r, t[r]) }) } var pi = Object.defineProperty; function De(e, t, r, n) { pi(e, t, oe(r && de(r, "get") && typeof r.get == "function" ? { get: r.get, set: r.set, configurable: !0 } : { value: r, configurable: !0, writable: !0 }, n)) } function rt(e) { return { from: function (t) { return e.prototype = Object.create(t.prototype), De(e.prototype, "constructor", e), { extend: tt.bind(null, e.prototype) } } } } var La = Object.getOwnPropertyDescriptor; function tn(e, t) { var r = La(e, t), n; return r || (n = _t(e)) && tn(n, t) } var Na = [].slice; function ur(e, t, r) { return Na.call(e, t, r) } function di(e, t) { return t(e) } function ut(e) { if (!e) throw new Error("Assertion Failed") } function hi(e) { U.setImmediate ? setImmediate(e) : setTimeout(e, 0) } function vi(e, t) { return e.reduce(function (r, n, i) { var a = t(n, i); return a && (r[a[0]] = a[1]), r }, {}) } function Ua(e, t, r) { try { e.apply(null, r) } catch (n) { t && t(n) } } function xe(e, t) { if (de(e, t)) return e[t]; if (!t) return e; if (typeof t != "string") { for (var r = [], n = 0, i = t.length; n < i; ++n) { var a = xe(e, t[n]); r.push(a) } return r } var o = t.indexOf("."); if (o !== -1) { var u = e[t.substr(0, o)]; return u === void 0 ? void 0 : xe(u, t.substr(o + 1)) } } function me(e, t, r) { if (!(!e || t === void 0) && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) { ut(typeof r != "string" && "length" in r); for (var n = 0, i = t.length; n < i; ++n)me(e, t[n], r[n]) } else { var a = t.indexOf("."); if (a !== -1) { var o = t.substr(0, a), u = t.substr(a + 1); if (u === "") r === void 0 ? re(e) && !isNaN(parseInt(o)) ? e.splice(o, 1) : delete e[o] : e[o] = r; else { var s = e[o]; (!s || !de(e, o)) && (s = e[o] = {}), me(s, u, r) } } else r === void 0 ? re(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r } } function za(e, t) { typeof t == "string" ? me(e, t, void 0) : "length" in t && [].map.call(t, function (r) { me(e, r, void 0) }) } function mi(e) { var t = {}; for (var r in e) de(e, r) && (t[r] = e[r]); return t } var $a = [].concat; function yi(e) { return $a.apply([], e) } var gi = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(yi([8, 16, 32, 64].map(function (e) { return ["Int", "Uint", "Float"].map(function (t) { return t + e + "Array" }) }))).filter(function (e) { return U[e] }), Ga = gi.map(function (e) { return U[e] }); vi(gi, function (e) { return [e, !0] }); var Be = null; function Rt(e) { Be = typeof WeakMap < "u" && new WeakMap; var t = kr(e); return Be = null, t } function kr(e) { if (!e || typeof e != "object") return e; var t = Be && Be.get(e); if (t) return t; if (re(e)) { t = [], Be && Be.set(e, t); for (var r = 0, n = e.length; r < n; ++r)t.push(kr(e[r])) } else if (Ga.indexOf(e.constructor) >= 0) t = e; else { var i = _t(e); t = i === Object.prototype ? {} : Object.create(i), Be && Be.set(e, t); for (var a in e) de(e, a) && (t[a] = kr(e[a])) } return t } var Va = {}.toString; function Pr(e) { return Va.call(e).slice(8, -1) } var Er = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ja = typeof Er == "symbol" ? function (e) { var t; return e != null && (t = e[Er]) && t.apply(e) } : function () { return null }, Ze = {}; function Pe(e) { var t, r, n, i; if (arguments.length === 1) { if (re(e)) return e.slice(); if (this === Ze && typeof e == "string") return [e]; if (i = Ja(e)) { for (r = []; n = i.next(), !n.done;)r.push(n.value); return r } if (e == null) return [e]; if (t = e.length, typeof t == "number") { for (r = new Array(t); t--;)r[t] = e[t]; return r } return [e] } for (t = arguments.length, r = new Array(t); t--;)r[t] = arguments[t]; return r } var rn = typeof Symbol < "u" ? function (e) { return e[Symbol.toStringTag] === "AsyncFunction" } : function () { return !1 }, _e = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href); function _i(e, t) { _e = e, bi = t } var bi = function () { return !0 }, Ha = !new Error("").stack; function qe() { if (Ha) try { throw qe.arguments, new Error } catch (e) { return e } return new Error } function Rr(e, t) {
    var r = e.stack; return r ? (t = t || 0, r.indexOf(e.name) === 0 && (t += (e.name + e.message).split(`
`).length), r.split(`
`).slice(t).filter(bi).map(function (n) {
        return `
`+ n
    }).join("")) : ""
} var Wa = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"], Ci = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], nn = Wa.concat(Ci), Ya = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" }; function nt(e, t) { this._e = qe(), this.name = e, this.message = t } rt(nt).from(Error).extend({ stack: { get: function () { return this._stack || (this._stack = this.name + ": " + this.message + Rr(this._e, 2)) } }, toString: function () { return this.name + ": " + this.message } }); function Si(e, t) {
    return e + ". Errors: " + Object.keys(t).map(function (r) { return t[r].toString() }).filter(function (r, n, i) { return i.indexOf(r) === n }).join(`
`)
} function Qt(e, t, r, n) { this._e = qe(), this.failures = t, this.failedKeys = n, this.successCount = r, this.message = Si(e, t) } rt(Qt).from(nt); function vt(e, t) { this._e = qe(), this.name = "BulkError", this.failures = Object.keys(t).map(function (r) { return t[r] }), this.failuresByPos = t, this.message = Si(e, t) } rt(vt).from(nt); var an = nn.reduce(function (e, t) { return e[t] = t + "Error", e }, {}), qa = nt, w = nn.reduce(function (e, t) {
    var r = t + "Error"; function n(i, a) {
        this._e = qe(), this.name = r, i ? typeof i == "string" ? (this.message = "" + i + (a ? `
 `+ a : ""), this.inner = a || null) : typeof i == "object" && (this.message = i.name + " " + i.message, this.inner = i) : (this.message = Ya[t] || r, this.inner = null)
    } return rt(n).from(qa), e[t] = n, e
}, {}); w.Syntax = SyntaxError; w.Type = TypeError; w.Range = RangeError; var Rn = Ci.reduce(function (e, t) { return e[t + "Error"] = w[t], e }, {}); function Xa(e, t) { if (!e || e instanceof nt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Rn[e.name]) return e; var r = new Rn[e.name](t || e.message, e); return "stack" in e && De(r, "stack", { get: function () { return this.inner.stack } }), r } var fr = nn.reduce(function (e, t) { return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = w[t]), e }, {}); fr.ModifyError = Qt; fr.DexieError = nt; fr.BulkError = vt; function L() { } function xt(e) { return e } function Qa(e, t) { return e == null || e === xt ? t : function (r) { return t(e(r)) } } function We(e, t) { return function () { e.apply(this, arguments), t.apply(this, arguments) } } function Za(e, t) { return e === L ? t : function () { var r = e.apply(this, arguments); r !== void 0 && (arguments[0] = r); var n = this.onsuccess, i = this.onerror; this.onsuccess = null, this.onerror = null; var a = t.apply(this, arguments); return n && (this.onsuccess = this.onsuccess ? We(n, this.onsuccess) : n), i && (this.onerror = this.onerror ? We(i, this.onerror) : i), a !== void 0 ? a : r } } function eo(e, t) { return e === L ? t : function () { e.apply(this, arguments); var r = this.onsuccess, n = this.onerror; this.onsuccess = this.onerror = null, t.apply(this, arguments), r && (this.onsuccess = this.onsuccess ? We(r, this.onsuccess) : r), n && (this.onerror = this.onerror ? We(n, this.onerror) : n) } } function to(e, t) { return e === L ? t : function (r) { var n = e.apply(this, arguments); oe(r, n); var i = this.onsuccess, a = this.onerror; this.onsuccess = null, this.onerror = null; var o = t.apply(this, arguments); return i && (this.onsuccess = this.onsuccess ? We(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? We(a, this.onerror) : a), n === void 0 ? o === void 0 ? void 0 : o : oe(n, o) } } function ro(e, t) { return e === L ? t : function () { return t.apply(this, arguments) === !1 ? !1 : e.apply(this, arguments) } } function on(e, t) { return e === L ? t : function () { var r = e.apply(this, arguments); if (r && typeof r.then == "function") { for (var n = this, i = arguments.length, a = new Array(i); i--;)a[i] = arguments[i]; return r.then(function () { return t.apply(n, a) }) } return t.apply(this, arguments) } } var bt = {}, no = 100, io = 20, Ti = 100, sn = typeof Promise > "u" ? [] : function () { var e = Promise.resolve(); if (typeof crypto > "u" || !crypto.subtle) return [e, _t(e), e]; var t = crypto.subtle.digest("SHA-512", new Uint8Array([0])); return [t, _t(t), e] }(), xr = sn[0], Zt = sn[1], Dr = sn[2], ki = Zt && Zt.then, zt = xr && xr.constructor, cn = !!Dr, Or = !1, ao = Dr ? function () { Dr.then(Mt) } : U.setImmediate ? setImmediate.bind(null, Mt) : U.MutationObserver ? function () { var e = document.createElement("div"); new MutationObserver(function () { Mt(), e = null }).observe(e, { attributes: !0 }), e.setAttribute("i", "1") } : function () { setTimeout(Mt, 0) }, Ct = function (e, t) { ft.push([e, t]), er && (ao(), er = !1) }, wr = !0, er = !0, Je = [], $t = [], Ir = null, Ar = xt, et = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: On, pgp: !1, env: {}, finalize: function () { this.unhandleds.forEach(function (e) { try { On(e[0], e[1]) } catch { } }) } }, x = et, ft = [], He = 0, Gt = []; function E(e) { if (typeof this != "object") throw new TypeError("Promises must be constructed via new"); this._listeners = [], this.onuncatched = L, this._lib = !1; var t = this._PSD = x; if (_e && (this._stackHolder = qe(), this._prev = null, this._numPrev = 0), typeof e != "function") { if (e !== bt) throw new TypeError("Not a function"); this._state = arguments[1], this._value = arguments[2], this._state === !1 && Br(this, this._value); return } this._state = null, this._value = null, ++t.ref, Ei(this, e) } var Mr = { get: function () { var e = x, t = tr; function r(n, i) { var a = this, o = !e.global && (e !== x || t !== tr), u = o && !Oe(), s = new E(function (c, f) { un(a, new Pi(nr(n, e, o, u), nr(i, e, o, u), c, f, e)) }); return _e && Di(s, this), s } return r.prototype = bt, r }, set: function (e) { De(this, "then", e && e.prototype === bt ? Mr : { get: function () { return e }, set: Mr.set }) } }; tt(E.prototype, {
    then: Mr, _then: function (e, t) { un(this, new Pi(null, null, e, t, x)) }, catch: function (e) { if (arguments.length === 1) return this.then(null, e); var t = arguments[0], r = arguments[1]; return typeof t == "function" ? this.then(null, function (n) { return n instanceof t ? r(n) : Vt(n) }) : this.then(null, function (n) { return n && n.name === t ? r(n) : Vt(n) }) }, finally: function (e) { return this.then(function (t) { return e(), t }, function (t) { return e(), Vt(t) }) }, stack: {
        get: function () {
            if (this._stack) return this._stack; try {
                Or = !0; var e = xi(this, [], io), t = e.join(`
From previous: `); return this._state !== null && (this._stack = t), t
            } finally { Or = !1 }
        }
    }, timeout: function (e, t) { var r = this; return e < 1 / 0 ? new E(function (n, i) { var a = setTimeout(function () { return i(new w.Timeout(t)) }, e); r.then(n, i).finally(clearTimeout.bind(null, a)) }) : this }
}); typeof Symbol < "u" && Symbol.toStringTag && De(E.prototype, Symbol.toStringTag, "Dexie.Promise"); et.env = Oi(); function Pi(e, t, r, n, i) { this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = r, this.reject = n, this.psd = i } tt(E, { all: function () { var e = Pe.apply(null, arguments).map(rr); return new E(function (t, r) { e.length === 0 && t([]); var n = e.length; e.forEach(function (i, a) { return E.resolve(i).then(function (o) { e[a] = o, --n || t(e) }, r) }) }) }, resolve: function (e) { if (e instanceof E) return e; if (e && typeof e.then == "function") return new E(function (r, n) { e.then(r, n) }); var t = new E(bt, !0, e); return Di(t, Ir), t }, reject: Vt, race: function () { var e = Pe.apply(null, arguments).map(rr); return new E(function (t, r) { e.map(function (n) { return E.resolve(n).then(t, r) }) }) }, PSD: { get: function () { return x }, set: function (e) { return x = e } }, totalEchoes: { get: function () { return tr } }, newPSD: Ke, usePSD: at, scheduler: { get: function () { return Ct }, set: function (e) { Ct = e } }, rejectionMapper: { get: function () { return Ar }, set: function (e) { Ar = e } }, follow: function (e, t) { return new E(function (r, n) { return Ke(function (i, a) { var o = x; o.unhandleds = [], o.onunhandled = a, o.finalize = We(function () { var u = this; so(function () { u.unhandleds.length === 0 ? i() : a(u.unhandleds[0]) }) }, o.finalize), e() }, t, r, n) }) } }); zt && (zt.allSettled && De(E, "allSettled", function () { var e = Pe.apply(null, arguments).map(rr); return new E(function (t) { e.length === 0 && t([]); var r = e.length, n = new Array(r); e.forEach(function (i, a) { return E.resolve(i).then(function (o) { return n[a] = { status: "fulfilled", value: o } }, function (o) { return n[a] = { status: "rejected", reason: o } }).then(function () { return --r || t(n) }) }) }) }), zt.any && typeof AggregateError < "u" && De(E, "any", function () { var e = Pe.apply(null, arguments).map(rr); return new E(function (t, r) { e.length === 0 && r(new AggregateError([])); var n = e.length, i = new Array(n); e.forEach(function (a, o) { return E.resolve(a).then(function (u) { return t(u) }, function (u) { i[o] = u, --n || r(new AggregateError(i)) }) }) }) })); function Ei(e, t) { try { t(function (r) { if (e._state === null) { if (r === e) throw new TypeError("A promise cannot be resolved with itself."); var n = e._lib && Dt(); r && typeof r.then == "function" ? Ei(e, function (i, a) { r instanceof E ? r._then(i, a) : r.then(i, a) }) : (e._state = !0, e._value = r, Ri(e)), n && Ot() } }, Br.bind(null, e)) } catch (r) { Br(e, r) } } function Br(e, t) { if ($t.push(t), e._state === null) { var r = e._lib && Dt(); t = Ar(t), e._state = !1, e._value = t, _e && t !== null && typeof t == "object" && !t._promise && Ua(function () { var n = tn(t, "stack"); t._promise = e, De(t, "stack", { get: function () { return Or ? n && (n.get ? n.get.apply(t) : n.value) : e.stack } }) }), co(e), Ri(e), r && Ot() } } function Ri(e) { var t = e._listeners; e._listeners = []; for (var r = 0, n = t.length; r < n; ++r)un(e, t[r]); var i = e._PSD; --i.ref || i.finalize(), He === 0 && (++He, Ct(function () { --He === 0 && fn() }, [])) } function un(e, t) { if (e._state === null) { e._listeners.push(t); return } var r = e._state ? t.onFulfilled : t.onRejected; if (r === null) return (e._state ? t.resolve : t.reject)(e._value); ++t.psd.ref, ++He, Ct(oo, [r, e, t]) } function oo(e, t, r) { try { Ir = t; var n, i = t._value; t._state ? n = e(i) : ($t.length && ($t = []), n = e(i), $t.indexOf(i) === -1 && uo(t)), r.resolve(n) } catch (a) { r.reject(a) } finally { Ir = null, --He === 0 && fn(), --r.psd.ref || r.psd.finalize() } } function xi(e, t, r) { if (t.length === r) return t; var n = ""; if (e._state === !1) { var i = e._value, a, o; i != null ? (a = i.name || "Error", o = i.message || i, n = Rr(i, 0)) : (a = i, o = ""), t.push(a + (o ? ": " + o : "") + n) } return _e && (n = Rr(e._stackHolder, 2), n && t.indexOf(n) === -1 && t.push(n), e._prev && xi(e._prev, t, r)), t } function Di(e, t) { var r = t ? t._numPrev + 1 : 0; r < no && (e._prev = t, e._numPrev = r) } function Mt() { Dt() && Ot() } function Dt() { var e = wr; return wr = !1, er = !1, e } function Ot() { var e, t, r; do for (; ft.length > 0;)for (e = ft, ft = [], r = e.length, t = 0; t < r; ++t) { var n = e[t]; n[0].apply(null, n[1]) } while (ft.length > 0); wr = !0, er = !0 } function fn() { var e = Je; Je = [], e.forEach(function (n) { n._PSD.onunhandled.call(null, n._value, n) }); for (var t = Gt.slice(0), r = t.length; r;)t[--r]() } function so(e) { function t() { e(), Gt.splice(Gt.indexOf(t), 1) } Gt.push(t), ++He, Ct(function () { --He === 0 && fn() }, []) } function co(e) { Je.some(function (t) { return t._value === e._value }) || Je.push(e) } function uo(e) { for (var t = Je.length; t;)if (Je[--t]._value === e._value) { Je.splice(t, 1); return } } function Vt(e) { return new E(bt, !1, e) } function $(e, t) { var r = x; return function () { var n = Dt(), i = x; try { return Le(r, !0), e.apply(this, arguments) } catch (a) { t && t(a) } finally { Le(i, !1), n && Ot() } } } var te = { awaits: 0, echoes: 0, id: 0 }, fo = 0, Jt = [], hr = 0, tr = 0, lo = 0; function Ke(e, t, r, n) { var i = x, a = Object.create(i); a.parent = i, a.ref = 0, a.global = !1, a.id = ++lo; var o = et.env; a.env = cn ? { Promise: E, PromiseProp: { value: E, configurable: !0, writable: !0 }, all: E.all, race: E.race, allSettled: E.allSettled, any: E.any, resolve: E.resolve, reject: E.reject, nthen: xn(o.nthen, a), gthen: xn(o.gthen, a) } : {}, t && oe(a, t), ++i.ref, a.finalize = function () { --this.parent.ref || this.parent.finalize() }; var u = at(a, e, r, n); return a.ref === 0 && a.finalize(), u } function it() { return te.id || (te.id = ++fo), ++te.awaits, te.echoes += Ti, te.id } function Oe() { return te.awaits ? (--te.awaits === 0 && (te.id = 0), te.echoes = te.awaits * Ti, !0) : !1 } ("" + ki).indexOf("[native code]") === -1 && (it = Oe = L); function rr(e) { return te.echoes && e && e.constructor === zt ? (it(), e.then(function (t) { return Oe(), t }, function (t) { return Oe(), J(t) })) : e } function po(e) { ++tr, (!te.echoes || --te.echoes === 0) && (te.echoes = te.id = 0), Jt.push(x), Le(e, !0) } function ho() { var e = Jt[Jt.length - 1]; Jt.pop(), Le(e, !1) } function Le(e, t) { var r = x; if ((t ? te.echoes && (!hr++ || e !== x) : hr && (!--hr || e !== x)) && wi(t ? po.bind(null, e) : ho), e !== x && (x = e, r === et && (et.env = Oi()), cn)) { var n = et.env.Promise, i = e.env; Zt.then = i.nthen, n.prototype.then = i.gthen, (r.global || e.global) && (Object.defineProperty(U, "Promise", i.PromiseProp), n.all = i.all, n.race = i.race, n.resolve = i.resolve, n.reject = i.reject, i.allSettled && (n.allSettled = i.allSettled), i.any && (n.any = i.any)) } } function Oi() { var e = U.Promise; return cn ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(U, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject, nthen: Zt.then, gthen: e.prototype.then } : {} } function at(e, t, r, n, i) { var a = x; try { return Le(e, !0), t(r, n, i) } finally { Le(a, !1) } } function wi(e) { ki.call(xr, e) } function nr(e, t, r, n) { return typeof e != "function" ? e : function () { var i = x; r && it(), Le(t, !0); try { return e.apply(this, arguments) } finally { Le(i, !1), n && wi(Oe) } } } function xn(e, t) { return function (r, n) { return e.call(this, nr(r, t), nr(n, t)) } } var Dn = "unhandledrejection"; function On(e, t) { var r; try { r = t.onuncatched(e) } catch { } if (r !== !1) try { var n, i = { promise: t, reason: e }; if (U.document && document.createEvent ? (n = document.createEvent("Event"), n.initEvent(Dn, !0, !0), oe(n, i)) : U.CustomEvent && (n = new CustomEvent(Dn, { detail: i }), oe(n, i)), n && U.dispatchEvent && (dispatchEvent(n), !U.PromiseRejectionEvent && U.onunhandledrejection)) try { U.onunhandledrejection(n) } catch { } _e && n && !n.defaultPrevented && console.warn("Unhandled rejection: " + (e.stack || e)) } catch { } } var J = E.reject; function jr(e, t, r, n) { if (!e.idbdb || !e._state.openComplete && !x.letThrough && !e._vip) { if (e._state.openComplete) return J(new w.DatabaseClosed(e._state.dbOpenError)); if (!e._state.isBeingOpened) { if (!e._options.autoOpen) return J(new w.DatabaseClosed); e.open().catch(L) } return e._state.dbReadyPromise.then(function () { return jr(e, t, r, n) }) } else { var i = e._createTransaction(t, r, e._dbSchema); try { i.create(), e._state.PR1398_maxLoop = 3 } catch (a) { return a.name === an.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return jr(e, t, r, n) })) : J(a) } return i._promise(t, function (a, o) { return Ke(function () { return x.trans = i, n(a, o, i) }) }).then(function (a) { return i._completion.then(function () { return a }) }) } } var wn = "3.2.2", Ge = String.fromCharCode(65535), Fr = -1 / 0, Ce = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ii = "String expected.", mt = [], lr = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), vo = lr, mo = lr, Ai = function (e) { return !/(dexie\.js|dexie\.min\.js)/.test(e) }, pr = "__dbnames", vr = "readonly", mr = "readwrite"; function Ye(e, t) { return e ? t ? function () { return e.apply(this, arguments) && t.apply(this, arguments) } : e : t } var Mi = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 }; function Bt(e) { return typeof e == "string" && !/\./.test(e) ? function (t) { return t[e] === void 0 && e in t && (t = Rt(t), delete t[e]), t } : function (t) { return t } } var yo = function () { function e() { } return e.prototype._trans = function (t, r, n) { var i = this._tx || x.trans, a = this.name; function o(s, c, f) { if (!f.schema[a]) throw new w.NotFound("Table " + a + " not part of transaction"); return r(f.idbtrans, f) } var u = Dt(); try { return i && i.db === this.db ? i === x.trans ? i._promise(t, o, n) : Ke(function () { return i._promise(t, o, n) }, { trans: i, transless: x.transless || x }) : jr(this.db, t, [this.name], o) } finally { u && Ot() } }, e.prototype.get = function (t, r) { var n = this; return t && t.constructor === Object ? this.where(t).first(r) : this._trans("readonly", function (i) { return n.core.get({ trans: i, key: t }).then(function (a) { return n.hook.reading.fire(a) }) }).then(r) }, e.prototype.where = function (t) { if (typeof t == "string") return new this.db.WhereClause(this, t); if (re(t)) return new this.db.WhereClause(this, "[" + t.join("+") + "]"); var r = V(t); if (r.length === 1) return this.where(r[0]).equals(t[r[0]]); var n = this.schema.indexes.concat(this.schema.primKey).filter(function (f) { return f.compound && r.every(function (l) { return f.keyPath.indexOf(l) >= 0 }) && f.keyPath.every(function (l) { return r.indexOf(l) >= 0 }) })[0]; if (n && this.db._maxKey !== Ge) return this.where(n.name).equals(n.keyPath.map(function (f) { return t[f] })); !n && _e && console.warn("The query " + JSON.stringify(t) + " on " + this.name + " would benefit of a " + ("compound index [" + r.join("+") + "]")); var i = this.schema.idxByName, a = this.db._deps.indexedDB; function o(f, l) { try { return a.cmp(f, l) === 0 } catch { return !1 } } var u = r.reduce(function (f, l) { var p = f[0], v = f[1], d = i[l], h = t[l]; return [p || d, p || !d ? Ye(v, d && d.multi ? function (_) { var m = xe(_, l); return re(m) && m.some(function (g) { return o(h, g) }) } : function (_) { return o(h, xe(_, l)) }) : v] }, [null, null]), s = u[0], c = u[1]; return s ? this.where(s.name).equals(t[s.keyPath]).filter(c) : n ? this.filter(c) : this.where(r).equals("") }, e.prototype.filter = function (t) { return this.toCollection().and(t) }, e.prototype.count = function (t) { return this.toCollection().count(t) }, e.prototype.offset = function (t) { return this.toCollection().offset(t) }, e.prototype.limit = function (t) { return this.toCollection().limit(t) }, e.prototype.each = function (t) { return this.toCollection().each(t) }, e.prototype.toArray = function (t) { return this.toCollection().toArray(t) }, e.prototype.toCollection = function () { return new this.db.Collection(new this.db.WhereClause(this)) }, e.prototype.orderBy = function (t) { return new this.db.Collection(new this.db.WhereClause(this, re(t) ? "[" + t.join("+") + "]" : t)) }, e.prototype.reverse = function () { return this.toCollection().reverse() }, e.prototype.mapToClass = function (t) { this.schema.mappedClass = t; var r = function (n) { if (!n) return n; var i = Object.create(t.prototype); for (var a in n) if (de(n, a)) try { i[a] = n[a] } catch { } return i }; return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook("reading", r), t }, e.prototype.defineClass = function () { function t(r) { oe(this, r) } return this.mapToClass(t) }, e.prototype.add = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Bt(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "add", keys: r != null ? [r] : null, values: [u] }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { me(t, o, s) } catch { } return s }) }, e.prototype.update = function (t, r) { if (typeof t == "object" && !re(t)) { var n = xe(t, this.schema.primKey.keyPath); if (n === void 0) return J(new w.InvalidArgument("Given object does not contain its primary key")); try { typeof r != "function" ? V(r).forEach(function (i) { me(t, i, r[i]) }) : r(t, { value: t, primKey: n }) } catch { } return this.where(":id").equals(n).modify(r) } else return this.where(":id").equals(t).modify(r) }, e.prototype.put = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Bt(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "put", values: [u], keys: r != null ? [r] : null }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { me(t, o, s) } catch { } return s }) }, e.prototype.delete = function (t) { var r = this; return this._trans("readwrite", function (n) { return r.core.mutate({ trans: n, type: "delete", keys: [t] }) }).then(function (n) { return n.numFailures ? E.reject(n.failures[0]) : void 0 }) }, e.prototype.clear = function () { var t = this; return this._trans("readwrite", function (r) { return t.core.mutate({ trans: r, type: "deleteRange", range: Mi }) }).then(function (r) { return r.numFailures ? E.reject(r.failures[0]) : void 0 }) }, e.prototype.bulkGet = function (t) { var r = this; return this._trans("readonly", function (n) { return r.core.getMany({ keys: t, trans: n }).then(function (i) { return i.map(function (a) { return r.hook.reading.fire(a) }) }) }) }, e.prototype.bulkAdd = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, f = s.keyPath; if (f && a) throw new w.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new w.InvalidArgument("Arguments objects and keys must have the same length"); var l = t.length, p = f && c ? t.map(Bt(f)) : t; return i.core.mutate({ trans: u, type: "add", keys: a, values: p, wantResults: o }).then(function (v) { var d = v.numFailures, h = v.results, _ = v.lastResult, m = v.failures, g = o ? h : _; if (d === 0) return g; throw new vt(i.name + ".bulkAdd(): " + d + " of " + l + " operations failed", m) }) }) }, e.prototype.bulkPut = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, f = s.keyPath; if (f && a) throw new w.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new w.InvalidArgument("Arguments objects and keys must have the same length"); var l = t.length, p = f && c ? t.map(Bt(f)) : t; return i.core.mutate({ trans: u, type: "put", keys: a, values: p, wantResults: o }).then(function (v) { var d = v.numFailures, h = v.results, _ = v.lastResult, m = v.failures, g = o ? h : _; if (d === 0) return g; throw new vt(i.name + ".bulkPut(): " + d + " of " + l + " operations failed", m) }) }) }, e.prototype.bulkDelete = function (t) { var r = this, n = t.length; return this._trans("readwrite", function (i) { return r.core.mutate({ trans: i, type: "delete", keys: t }) }).then(function (i) { var a = i.numFailures, o = i.lastResult, u = i.failures; if (a === 0) return o; throw new vt(r.name + ".bulkDelete(): " + a + " of " + n + " operations failed", u) }) }, e }(); function wt(e) { var t = {}, r = function (u, s) { if (s) { for (var c = arguments.length, f = new Array(c - 1); --c;)f[c - 1] = arguments[c]; return t[u].subscribe.apply(null, f), e } else if (typeof u == "string") return t[u] }; r.addEventType = a; for (var n = 1, i = arguments.length; n < i; ++n)a(arguments[n]); return r; function a(u, s, c) { if (typeof u == "object") return o(u); s || (s = ro), c || (c = L); var f = { subscribers: [], fire: c, subscribe: function (l) { f.subscribers.indexOf(l) === -1 && (f.subscribers.push(l), f.fire = s(f.fire, l)) }, unsubscribe: function (l) { f.subscribers = f.subscribers.filter(function (p) { return p !== l }), f.fire = f.subscribers.reduce(s, c) } }; return t[u] = r[u] = f, f } function o(u) { V(u).forEach(function (s) { var c = u[s]; if (re(c)) a(s, u[s][0], u[s][1]); else if (c === "asap") var f = a(s, xt, function () { for (var p = arguments.length, v = new Array(p); p--;)v[p] = arguments[p]; f.subscribers.forEach(function (d) { hi(function () { d.apply(null, v) }) }) }); else throw new w.InvalidArgument("Invalid event config") }) } } function It(e, t) { return rt(t).from({ prototype: e }), t } function go(e) { return It(yo.prototype, function (r, n, i) { this.db = e, this._tx = i, this.name = r, this.schema = n, this.hook = e._allTables[r] ? e._allTables[r].hook : wt(null, { creating: [Za, L], reading: [Qa, xt], updating: [to, L], deleting: [eo, L] }) }) } function Xe(e, t) { return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter) } function yr(e, t) { e.filter = Ye(e.filter, t) } function gr(e, t, r) { var n = e.replayFilter; e.replayFilter = n ? function () { return Ye(n(), t()) } : t, e.justLimit = r && !n } function _o(e, t) { e.isMatch = Ye(e.isMatch, t) } function Ht(e, t) { if (e.isPrimKey) return t.primaryKey; var r = t.getIndexByKeyPath(e.index); if (!r) throw new w.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed"); return r } function In(e, t, r) { var n = Ht(e, t.schema); return t.openCursor({ trans: r, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: n, range: e.range } }) } function jt(e, t, r, n) { var i = e.replayFilter ? Ye(e.filter, e.replayFilter()) : e.filter; if (e.or) { var a = {}, o = function (u, s, c) { if (!i || i(s, c, function (p) { return s.stop(p) }, function (p) { return s.fail(p) })) { var f = s.primaryKey, l = "" + f; l === "[object ArrayBuffer]" && (l = "" + new Uint8Array(f)), de(a, l) || (a[l] = !0, t(u, s, c)) } }; return Promise.all([e.or._iterate(o, r), An(In(e, n, r), e.algorithm, o, !e.keysOnly && e.valueMapper)]) } else return An(In(e, n, r), Ye(e.algorithm, i), t, !e.keysOnly && e.valueMapper) } function An(e, t, r, n) { var i = n ? function (o, u, s) { return r(n(o), u, s) } : r, a = $(i); return e.then(function (o) { if (o) return o.start(function () { var u = function () { return o.continue() }; (!t || t(o, function (s) { return u = s }, function (s) { o.stop(s), u = L }, function (s) { o.fail(s), u = L })) && a(o.value, o, function (s) { return u = s }), u() }) }) } function ae(e, t) { try { var r = Mn(e), n = Mn(t); if (r !== n) return r === "Array" ? 1 : n === "Array" ? -1 : r === "binary" ? 1 : n === "binary" ? -1 : r === "string" ? 1 : n === "string" ? -1 : r === "Date" ? 1 : n !== "Date" ? NaN : -1; switch (r) { case "number": case "Date": case "string": return e > t ? 1 : e < t ? -1 : 0; case "binary": return Co(Bn(e), Bn(t)); case "Array": return bo(e, t) } } catch { } return NaN } function bo(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a) { var o = ae(e[a], t[a]); if (o !== 0) return o } return r === n ? 0 : r < n ? -1 : 1 } function Co(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a)if (e[a] !== t[a]) return e[a] < t[a] ? -1 : 1; return r === n ? 0 : r < n ? -1 : 1 } function Mn(e) { var t = typeof e; if (t !== "object") return t; if (ArrayBuffer.isView(e)) return "binary"; var r = Pr(e); return r === "ArrayBuffer" ? "binary" : r } function Bn(e) { return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e) } var So = function () { function e() { } return e.prototype._read = function (t, r) { var n = this._ctx; return n.error ? n.table._trans(null, J.bind(null, n.error)) : n.table._trans("readonly", t).then(r) }, e.prototype._write = function (t) { var r = this._ctx; return r.error ? r.table._trans(null, J.bind(null, r.error)) : r.table._trans("readwrite", t, "locked") }, e.prototype._addAlgorithm = function (t) { var r = this._ctx; r.algorithm = Ye(r.algorithm, t) }, e.prototype._iterate = function (t, r) { return jt(this._ctx, t, r, this._ctx.table.core) }, e.prototype.clone = function (t) { var r = Object.create(this.constructor.prototype), n = Object.create(this._ctx); return t && oe(n, t), r._ctx = n, r }, e.prototype.raw = function () { return this._ctx.valueMapper = null, this }, e.prototype.each = function (t) { var r = this._ctx; return this._read(function (n) { return jt(r, t, n, r.table.core) }) }, e.prototype.count = function (t) { var r = this; return this._read(function (n) { var i = r._ctx, a = i.table.core; if (Xe(i, !0)) return a.count({ trans: n, query: { index: Ht(i, a.schema), range: i.range } }).then(function (u) { return Math.min(u, i.limit) }); var o = 0; return jt(i, function () { return ++o, !1 }, n, a).then(function () { return o }) }).then(t) }, e.prototype.sortBy = function (t, r) { var n = t.split(".").reverse(), i = n[0], a = n.length - 1; function o(c, f) { return f ? o(c[n[f]], f - 1) : c[i] } var u = this._ctx.dir === "next" ? 1 : -1; function s(c, f) { var l = o(c, a), p = o(f, a); return l < p ? -u : l > p ? u : 0 } return this.toArray(function (c) { return c.sort(s) }).then(r) }, e.prototype.toArray = function (t) { var r = this; return this._read(function (n) { var i = r._ctx; if (i.dir === "next" && Xe(i, !0) && i.limit > 0) { var a = i.valueMapper, o = Ht(i, i.table.core.schema); return i.table.core.query({ trans: n, limit: i.limit, values: !0, query: { index: o, range: i.range } }).then(function (s) { var c = s.result; return a ? c.map(a) : c }) } else { var u = []; return jt(i, function (s) { return u.push(s) }, n, i.table.core).then(function () { return u }) } }, t) }, e.prototype.offset = function (t) { var r = this._ctx; return t <= 0 ? this : (r.offset += t, Xe(r) ? gr(r, function () { var n = t; return function (i, a) { return n === 0 ? !0 : n === 1 ? (--n, !1) : (a(function () { i.advance(n), n = 0 }), !1) } }) : gr(r, function () { var n = t; return function () { return --n < 0 } }), this) }, e.prototype.limit = function (t) { return this._ctx.limit = Math.min(this._ctx.limit, t), gr(this._ctx, function () { var r = t; return function (n, i, a) { return --r <= 0 && i(a), r >= 0 } }, !0), this }, e.prototype.until = function (t, r) { return yr(this._ctx, function (n, i, a) { return t(n.value) ? (i(a), r) : !0 }), this }, e.prototype.first = function (t) { return this.limit(1).toArray(function (r) { return r[0] }).then(t) }, e.prototype.last = function (t) { return this.reverse().first(t) }, e.prototype.filter = function (t) { return yr(this._ctx, function (r) { return t(r.value) }), _o(this._ctx, t), this }, e.prototype.and = function (t) { return this.filter(t) }, e.prototype.or = function (t) { return new this.db.WhereClause(this._ctx.table, t, this) }, e.prototype.reverse = function () { return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this }, e.prototype.desc = function () { return this.reverse() }, e.prototype.eachKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.key, i) }) }, e.prototype.eachUniqueKey = function (t) { return this._ctx.unique = "unique", this.eachKey(t) }, e.prototype.eachPrimaryKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.primaryKey, i) }) }, e.prototype.keys = function (t) { var r = this._ctx; r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.key) }).then(function () { return n }).then(t) }, e.prototype.primaryKeys = function (t) { var r = this._ctx; if (r.dir === "next" && Xe(r, !0) && r.limit > 0) return this._read(function (i) { var a = Ht(r, r.table.core.schema); return r.table.core.query({ trans: i, values: !1, limit: r.limit, query: { index: a, range: r.range } }) }).then(function (i) { var a = i.result; return a }).then(t); r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.primaryKey) }).then(function () { return n }).then(t) }, e.prototype.uniqueKeys = function (t) { return this._ctx.unique = "unique", this.keys(t) }, e.prototype.firstKey = function (t) { return this.limit(1).keys(function (r) { return r[0] }).then(t) }, e.prototype.lastKey = function (t) { return this.reverse().firstKey(t) }, e.prototype.distinct = function () { var t = this._ctx, r = t.index && t.table.schema.idxByName[t.index]; if (!r || !r.multi) return this; var n = {}; return yr(this._ctx, function (i) { var a = i.primaryKey.toString(), o = de(n, a); return n[a] = !0, !o }), this }, e.prototype.modify = function (t) { var r = this, n = this._ctx; return this._write(function (i) { var a; if (typeof t == "function") a = t; else { var o = V(t), u = o.length; a = function (m) { for (var g = !1, C = 0; C < u; ++C) { var b = o[C], y = t[b]; xe(m, b) !== y && (me(m, b, y), g = !0) } return g } } var s = n.table.core, c = s.schema.primaryKey, f = c.outbound, l = c.extractKey, p = r.db._options.modifyChunkSize || 200, v = [], d = 0, h = [], _ = function (m, g) { var C = g.failures, b = g.numFailures; d += m - b; for (var y = 0, S = V(C); y < S.length; y++) { var P = S[y]; v.push(C[P]) } }; return r.clone().primaryKeys().then(function (m) { var g = function (C) { var b = Math.min(p, m.length - C); return s.getMany({ trans: i, keys: m.slice(C, C + b), cache: "immutable" }).then(function (y) { for (var S = [], P = [], T = f ? [] : null, D = [], k = 0; k < b; ++k) { var j = y[k], B = { value: Rt(j), primKey: m[C + k] }; a.call(B, B.value, B) !== !1 && (B.value == null ? D.push(m[C + k]) : !f && ae(l(j), l(B.value)) !== 0 ? (D.push(m[C + k]), S.push(B.value)) : (P.push(B.value), f && T.push(m[C + k]))) } var M = Xe(n) && n.limit === 1 / 0 && (typeof t != "function" || t === _r) && { index: n.index, range: n.range }; return Promise.resolve(S.length > 0 && s.mutate({ trans: i, type: "add", values: S }).then(function (N) { for (var I in N.failures) D.splice(parseInt(I), 1); _(S.length, N) })).then(function () { return (P.length > 0 || M && typeof t == "object") && s.mutate({ trans: i, type: "put", keys: T, values: P, criteria: M, changeSpec: typeof t != "function" && t }).then(function (N) { return _(P.length, N) }) }).then(function () { return (D.length > 0 || M && t === _r) && s.mutate({ trans: i, type: "delete", keys: D, criteria: M }).then(function (N) { return _(D.length, N) }) }).then(function () { return m.length > C + b && g(C + p) }) }) }; return g(0).then(function () { if (v.length > 0) throw new Qt("Error modifying one or more objects", v, d, h); return m.length }) }) }) }, e.prototype.delete = function () { var t = this._ctx, r = t.range; return Xe(t) && (t.isPrimKey && !mo || r.type === 3) ? this._write(function (n) { var i = t.table.core.schema.primaryKey, a = r; return t.table.core.count({ trans: n, query: { index: i, range: a } }).then(function (o) { return t.table.core.mutate({ trans: n, type: "deleteRange", range: a }).then(function (u) { var s = u.failures; u.lastResult, u.results; var c = u.numFailures; if (c) throw new Qt("Could not delete some values", Object.keys(s).map(function (f) { return s[f] }), o - c); return o - c }) }) }) : this.modify(_r) }, e }(), _r = function (e, t) { return t.value = null }; function To(e) { return It(So.prototype, function (r, n) { this.db = e; var i = Mi, a = null; if (n) try { i = n() } catch (c) { a = c } var o = r._ctx, u = o.table, s = u.hook.reading.fire; this._ctx = { table: u, index: o.index, isPrimKey: !o.index || u.schema.primKey.keyPath && o.index === u.schema.primKey.name, range: i, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: a, or: o.or, valueMapper: s !== xt ? s : null } }) } function ko(e, t) { return e < t ? -1 : e === t ? 0 : 1 } function Po(e, t) { return e > t ? -1 : e === t ? 0 : 1 } function pe(e, t, r) { var n = e instanceof ji ? new e.Collection(e) : e; return n._ctx.error = r ? new r(t) : new TypeError(t), n } function Qe(e) { return new e.Collection(e, function () { return Bi("") }).limit(0) } function Eo(e) { return e === "next" ? function (t) { return t.toUpperCase() } : function (t) { return t.toLowerCase() } } function Ro(e) { return e === "next" ? function (t) { return t.toLowerCase() } : function (t) { return t.toUpperCase() } } function xo(e, t, r, n, i, a) { for (var o = Math.min(e.length, n.length), u = -1, s = 0; s < o; ++s) { var c = t[s]; if (c !== n[s]) return i(e[s], r[s]) < 0 ? e.substr(0, s) + r[s] + r.substr(s + 1) : i(e[s], n[s]) < 0 ? e.substr(0, s) + n[s] + r.substr(s + 1) : u >= 0 ? e.substr(0, u) + t[u] + r.substr(u + 1) : null; i(e[s], c) < 0 && (u = s) } return o < n.length && a === "next" ? e + r.substr(e.length) : o < e.length && a === "prev" ? e.substr(0, r.length) : u < 0 ? null : e.substr(0, u) + n[u] + r.substr(u + 1) } function Ft(e, t, r, n) { var i, a, o, u, s, c, f, l = r.length; if (!r.every(function (h) { return typeof h == "string" })) return pe(e, Ii); function p(h) { i = Eo(h), a = Ro(h), o = h === "next" ? ko : Po; var _ = r.map(function (m) { return { lower: a(m), upper: i(m) } }).sort(function (m, g) { return o(m.lower, g.lower) }); u = _.map(function (m) { return m.upper }), s = _.map(function (m) { return m.lower }), c = h, f = h === "next" ? "" : n } p("next"); var v = new e.Collection(e, function () { return Me(u[0], s[l - 1] + n) }); v._ondirectionchange = function (h) { p(h) }; var d = 0; return v._addAlgorithm(function (h, _, m) { var g = h.key; if (typeof g != "string") return !1; var C = a(g); if (t(C, s, d)) return !0; for (var b = null, y = d; y < l; ++y) { var S = xo(g, C, u[y], s[y], o, c); S === null && b === null ? d = y + 1 : (b === null || o(b, S) > 0) && (b = S) } return _(b !== null ? function () { h.continue(b + f) } : m), !1 }), v } function Me(e, t, r, n) { return { type: 2, lower: e, upper: t, lowerOpen: r, upperOpen: n } } function Bi(e) { return { type: 1, lower: e, upper: e } } var ji = function () { function e() { } return Object.defineProperty(e.prototype, "Collection", { get: function () { return this._ctx.table.db.Collection }, enumerable: !1, configurable: !0 }), e.prototype.between = function (t, r, n, i) { n = n !== !1, i = i === !0; try { return this._cmp(t, r) > 0 || this._cmp(t, r) === 0 && (n || i) && !(n && i) ? Qe(this) : new this.Collection(this, function () { return Me(t, r, !n, !i) }) } catch { return pe(this, Ce) } }, e.prototype.equals = function (t) { return t == null ? pe(this, Ce) : new this.Collection(this, function () { return Bi(t) }) }, e.prototype.above = function (t) { return t == null ? pe(this, Ce) : new this.Collection(this, function () { return Me(t, void 0, !0) }) }, e.prototype.aboveOrEqual = function (t) { return t == null ? pe(this, Ce) : new this.Collection(this, function () { return Me(t, void 0, !1) }) }, e.prototype.below = function (t) { return t == null ? pe(this, Ce) : new this.Collection(this, function () { return Me(void 0, t, !1, !0) }) }, e.prototype.belowOrEqual = function (t) { return t == null ? pe(this, Ce) : new this.Collection(this, function () { return Me(void 0, t) }) }, e.prototype.startsWith = function (t) { return typeof t != "string" ? pe(this, Ii) : this.between(t, t + Ge, !0, !0) }, e.prototype.startsWithIgnoreCase = function (t) { return t === "" ? this.startsWith(t) : Ft(this, function (r, n) { return r.indexOf(n[0]) === 0 }, [t], Ge) }, e.prototype.equalsIgnoreCase = function (t) { return Ft(this, function (r, n) { return r === n[0] }, [t], "") }, e.prototype.anyOfIgnoreCase = function () { var t = Pe.apply(Ze, arguments); return t.length === 0 ? Qe(this) : Ft(this, function (r, n) { return n.indexOf(r) !== -1 }, t, "") }, e.prototype.startsWithAnyOfIgnoreCase = function () { var t = Pe.apply(Ze, arguments); return t.length === 0 ? Qe(this) : Ft(this, function (r, n) { return n.some(function (i) { return r.indexOf(i) === 0 }) }, t, Ge) }, e.prototype.anyOf = function () { var t = this, r = Pe.apply(Ze, arguments), n = this._cmp; try { r.sort(n) } catch { return pe(this, Ce) } if (r.length === 0) return Qe(this); var i = new this.Collection(this, function () { return Me(r[0], r[r.length - 1]) }); i._ondirectionchange = function (o) { n = o === "next" ? t._ascending : t._descending, r.sort(n) }; var a = 0; return i._addAlgorithm(function (o, u, s) { for (var c = o.key; n(c, r[a]) > 0;)if (++a, a === r.length) return u(s), !1; return n(c, r[a]) === 0 ? !0 : (u(function () { o.continue(r[a]) }), !1) }), i }, e.prototype.notEqual = function (t) { return this.inAnyRange([[Fr, t], [t, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 }) }, e.prototype.noneOf = function () { var t = Pe.apply(Ze, arguments); if (t.length === 0) return new this.Collection(this); try { t.sort(this._ascending) } catch { return pe(this, Ce) } var r = t.reduce(function (n, i) { return n ? n.concat([[n[n.length - 1][1], i]]) : [[Fr, i]] }, null); return r.push([t[t.length - 1], this.db._maxKey]), this.inAnyRange(r, { includeLowers: !1, includeUppers: !1 }) }, e.prototype.inAnyRange = function (t, r) { var n = this, i = this._cmp, a = this._ascending, o = this._descending, u = this._min, s = this._max; if (t.length === 0) return Qe(this); if (!t.every(function (y) { return y[0] !== void 0 && y[1] !== void 0 && a(y[0], y[1]) <= 0 })) return pe(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", w.InvalidArgument); var c = !r || r.includeLowers !== !1, f = r && r.includeUppers === !0; function l(y, S) { for (var P = 0, T = y.length; P < T; ++P) { var D = y[P]; if (i(S[0], D[1]) < 0 && i(S[1], D[0]) > 0) { D[0] = u(D[0], S[0]), D[1] = s(D[1], S[1]); break } } return P === T && y.push(S), y } var p = a; function v(y, S) { return p(y[0], S[0]) } var d; try { d = t.reduce(l, []), d.sort(v) } catch { return pe(this, Ce) } var h = 0, _ = f ? function (y) { return a(y, d[h][1]) > 0 } : function (y) { return a(y, d[h][1]) >= 0 }, m = c ? function (y) { return o(y, d[h][0]) > 0 } : function (y) { return o(y, d[h][0]) >= 0 }; function g(y) { return !_(y) && !m(y) } var C = _, b = new this.Collection(this, function () { return Me(d[0][0], d[d.length - 1][1], !c, !f) }); return b._ondirectionchange = function (y) { y === "next" ? (C = _, p = a) : (C = m, p = o), d.sort(v) }, b._addAlgorithm(function (y, S, P) { for (var T = y.key; C(T);)if (++h, h === d.length) return S(P), !1; return g(T) ? !0 : (n._cmp(T, d[h][1]) === 0 || n._cmp(T, d[h][0]) === 0 || S(function () { p === a ? y.continue(d[h][0]) : y.continue(d[h][1]) }), !1) }), b }, e.prototype.startsWithAnyOf = function () { var t = Pe.apply(Ze, arguments); return t.every(function (r) { return typeof r == "string" }) ? t.length === 0 ? Qe(this) : this.inAnyRange(t.map(function (r) { return [r, r + Ge] })) : pe(this, "startsWithAnyOf() only works with strings") }, e }(); function Do(e) { return It(ji.prototype, function (r, n, i) { this.db = e, this._ctx = { table: r, index: n === ":id" ? null : n, or: i }; var a = e._deps.indexedDB; if (!a) throw new w.MissingAPI; this._cmp = this._ascending = a.cmp.bind(a), this._descending = function (o, u) { return a.cmp(u, o) }, this._max = function (o, u) { return a.cmp(o, u) > 0 ? o : u }, this._min = function (o, u) { return a.cmp(o, u) < 0 ? o : u }, this._IDBKeyRange = e._deps.IDBKeyRange }) } function ye(e) { return $(function (t) { return St(t), e(t.target.error), !1 }) } function St(e) { e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault() } var Tt = "storagemutated", Fe = "x-storagemutated-1", Ne = wt(null, Tt), Oo = function () { function e() { } return e.prototype._lock = function () { return ut(!x.global), ++this._reculock, this._reculock === 1 && !x.global && (x.lockOwnerFor = this), this }, e.prototype._unlock = function () { if (ut(!x.global), --this._reculock === 0) for (x.global || (x.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) { var t = this._blockedFuncs.shift(); try { at(t[1], t[0]) } catch { } } return this }, e.prototype._locked = function () { return this._reculock && x.lockOwnerFor !== this }, e.prototype.create = function (t) { var r = this; if (!this.mode) return this; var n = this.db.idbdb, i = this.db._state.dbOpenError; if (ut(!this.idbtrans), !t && !n) switch (i && i.name) { case "DatabaseClosedError": throw new w.DatabaseClosed(i); case "MissingAPIError": throw new w.MissingAPI(i.message, i); default: throw new w.OpenFailed(i) }if (!this.active) throw new w.TransactionInactive; return ut(this._completion._state === null), t = this.idbtrans = t || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })), t.onerror = $(function (a) { St(a), r._reject(t.error) }), t.onabort = $(function (a) { St(a), r.active && r._reject(new w.Abort(t.error)), r.active = !1, r.on("abort").fire(a) }), t.oncomplete = $(function () { r.active = !1, r._resolve(), "mutatedParts" in t && Ne.storagemutated.fire(t.mutatedParts) }), this }, e.prototype._promise = function (t, r, n) { var i = this; if (t === "readwrite" && this.mode !== "readwrite") return J(new w.ReadOnly("Transaction is readonly")); if (!this.active) return J(new w.TransactionInactive); if (this._locked()) return new E(function (o, u) { i._blockedFuncs.push([function () { i._promise(t, r, n).then(o, u) }, x]) }); if (n) return Ke(function () { var o = new E(function (u, s) { i._lock(); var c = r(u, s, i); c && c.then && c.then(u, s) }); return o.finally(function () { return i._unlock() }), o._lib = !0, o }); var a = new E(function (o, u) { var s = r(o, u, i); s && s.then && s.then(o, u) }); return a._lib = !0, a }, e.prototype._root = function () { return this.parent ? this.parent._root() : this }, e.prototype.waitFor = function (t) { var r = this._root(), n = E.resolve(t); if (r._waitingFor) r._waitingFor = r._waitingFor.then(function () { return n }); else { r._waitingFor = n, r._waitingQueue = []; var i = r.idbtrans.objectStore(r.storeNames[0]); (function o() { for (++r._spinCount; r._waitingQueue.length;)r._waitingQueue.shift()(); r._waitingFor && (i.get(-1 / 0).onsuccess = o) })() } var a = r._waitingFor; return new E(function (o, u) { n.then(function (s) { return r._waitingQueue.push($(o.bind(null, s))) }, function (s) { return r._waitingQueue.push($(u.bind(null, s))) }).finally(function () { r._waitingFor === a && (r._waitingFor = null) }) }) }, e.prototype.abort = function () { this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new w.Abort)) }, e.prototype.table = function (t) { var r = this._memoizedTables || (this._memoizedTables = {}); if (de(r, t)) return r[t]; var n = this.schema[t]; if (!n) throw new w.NotFound("Table " + t + " not part of transaction"); var i = new this.db.Table(t, n, this); return i.core = this.db.core.table(t), r[t] = i, i }, e }(); function wo(e) { return It(Oo.prototype, function (r, n, i, a, o) { var u = this; this.db = e, this.mode = r, this.storeNames = n, this.schema = i, this.chromeTransactionDurability = a, this.idbtrans = null, this.on = wt(this, "complete", "error", "abort"), this.parent = o || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new E(function (s, c) { u._resolve = s, u._reject = c }), this._completion.then(function () { u.active = !1, u.on.complete.fire() }, function (s) { var c = u.active; return u.active = !1, u.on.error.fire(s), u.parent ? u.parent._reject(s) : c && u.idbtrans && u.idbtrans.abort(), J(s) }) }) } function Kr(e, t, r, n, i, a, o) { return { name: e, keyPath: t, unique: r, multi: n, auto: i, compound: a, src: (r && !o ? "&" : "") + (n ? "*" : "") + (i ? "++" : "") + Fi(t) } } function Fi(e) { return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "" } function Ki(e, t, r) { return { name: e, primKey: t, indexes: r, mappedClass: null, idxByName: vi(r, function (n) { return [n.name, n] }) } } function Io(e) { return e.length === 1 ? e[0] : e } var kt = function (e) { try { return e.only([[]]), kt = function () { return [[]] }, [[]] } catch { return kt = function () { return Ge }, Ge } }; function Lr(e) { return e == null ? function () { } : typeof e == "string" ? Ao(e) : function (t) { return xe(t, e) } } function Ao(e) { var t = e.split("."); return t.length === 1 ? function (r) { return r[e] } : function (r) { return xe(r, e) } } function jn(e) { return [].slice.call(e) } var Mo = 0; function yt(e) { return e == null ? ":id" : typeof e == "string" ? e : "[" + e.join("+") + "]" } function Bo(e, t, r) { function n(l, p) { var v = jn(l.objectStoreNames); return { schema: { name: l.name, tables: v.map(function (d) { return p.objectStore(d) }).map(function (d) { var h = d.keyPath, _ = d.autoIncrement, m = re(h), g = h == null, C = {}, b = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g, compound: m, keyPath: h, autoIncrement: _, unique: !0, extractKey: Lr(h) }, indexes: jn(d.indexNames).map(function (y) { return d.index(y) }).map(function (y) { var S = y.name, P = y.unique, T = y.multiEntry, D = y.keyPath, k = re(D), j = { name: S, compound: k, keyPath: D, unique: P, multiEntry: T, extractKey: Lr(D) }; return C[yt(D)] = j, j }), getIndexByKeyPath: function (y) { return C[yt(y)] } }; return C[":id"] = b.primaryKey, h != null && (C[yt(h)] = b.primaryKey), b }) }, hasGetAll: v.length > 0 && "getAll" in p.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) } } function i(l) { if (l.type === 3) return null; if (l.type === 4) throw new Error("Cannot convert never type to IDBKeyRange"); var p = l.lower, v = l.upper, d = l.lowerOpen, h = l.upperOpen, _ = p === void 0 ? v === void 0 ? null : t.upperBound(v, !!h) : v === void 0 ? t.lowerBound(p, !!d) : t.bound(p, v, !!d, !!h); return _ } function a(l) { var p = l.name; function v(_) { var m = _.trans, g = _.type, C = _.keys, b = _.values, y = _.range; return new Promise(function (S, P) { S = $(S); var T = m.objectStore(p), D = T.keyPath == null, k = g === "put" || g === "add"; if (!k && g !== "delete" && g !== "deleteRange") throw new Error("Invalid operation type: " + g); var j = (C || b || { length: 1 }).length; if (C && b && C.length !== b.length) throw new Error("Given keys array must have same length as given values array."); if (j === 0) return S({ numFailures: 0, failures: {}, results: [], lastResult: void 0 }); var B, M = [], N = [], I = 0, Z = function (le) { ++I, St(le) }; if (g === "deleteRange") { if (y.type === 4) return S({ numFailures: I, failures: N, results: [], lastResult: void 0 }); y.type === 3 ? M.push(B = T.clear()) : M.push(B = T.delete(i(y))) } else { var Y = k ? D ? [b, C] : [b, null] : [C, null], H = Y[0], fe = Y[1]; if (k) for (var ie = 0; ie < j; ++ie)M.push(B = fe && fe[ie] !== void 0 ? T[g](H[ie], fe[ie]) : T[g](H[ie])), B.onerror = Z; else for (var ie = 0; ie < j; ++ie)M.push(B = T[g](H[ie])), B.onerror = Z } var he = function (le) { var we = le.target.result; M.forEach(function (W, Ie) { return W.error != null && (N[Ie] = W.error) }), S({ numFailures: I, failures: N, results: g === "delete" ? C : M.map(function (W) { return W.result }), lastResult: we }) }; B.onerror = function (le) { Z(le), he(le) }, B.onsuccess = he }) } function d(_) { var m = _.trans, g = _.values, C = _.query, b = _.reverse, y = _.unique; return new Promise(function (S, P) { S = $(S); var T = C.index, D = C.range, k = m.objectStore(p), j = T.isPrimaryKey ? k : k.index(T.name), B = b ? y ? "prevunique" : "prev" : y ? "nextunique" : "next", M = g || !("openKeyCursor" in j) ? j.openCursor(i(D), B) : j.openKeyCursor(i(D), B); M.onerror = ye(P), M.onsuccess = $(function (N) { var I = M.result; if (!I) { S(null); return } I.___id = ++Mo, I.done = !1; var Z = I.continue.bind(I), Y = I.continuePrimaryKey; Y && (Y = Y.bind(I)); var H = I.advance.bind(I), fe = function () { throw new Error("Cursor not started") }, ie = function () { throw new Error("Cursor not stopped") }; I.trans = m, I.stop = I.continue = I.continuePrimaryKey = I.advance = fe, I.fail = $(P), I.next = function () { var he = this, le = 1; return this.start(function () { return le-- ? he.continue() : he.stop() }).then(function () { return he }) }, I.start = function (he) { var le = new Promise(function (W, Ie) { W = $(W), M.onerror = ye(Ie), I.fail = Ie, I.stop = function (Ae) { I.stop = I.continue = I.continuePrimaryKey = I.advance = ie, W(Ae) } }), we = function () { if (M.result) try { he() } catch (W) { I.fail(W) } else I.done = !0, I.start = function () { throw new Error("Cursor behind last entry") }, I.stop() }; return M.onsuccess = $(function (W) { M.onsuccess = we, we() }), I.continue = Z, I.continuePrimaryKey = Y, I.advance = H, we(), le }, S(I) }, P) }) } function h(_) { return function (m) { return new Promise(function (g, C) { g = $(g); var b = m.trans, y = m.values, S = m.limit, P = m.query, T = S === 1 / 0 ? void 0 : S, D = P.index, k = P.range, j = b.objectStore(p), B = D.isPrimaryKey ? j : j.index(D.name), M = i(k); if (S === 0) return g({ result: [] }); if (_) { var N = y ? B.getAll(M, T) : B.getAllKeys(M, T); N.onsuccess = function (H) { return g({ result: H.target.result }) }, N.onerror = ye(C) } else { var I = 0, Z = y || !("openKeyCursor" in B) ? B.openCursor(M) : B.openKeyCursor(M), Y = []; Z.onsuccess = function (H) { var fe = Z.result; if (!fe) return g({ result: Y }); if (Y.push(y ? fe.value : fe.primaryKey), ++I === S) return g({ result: Y }); fe.continue() }, Z.onerror = ye(C) } }) } } return { name: p, schema: l, mutate: v, getMany: function (_) { var m = _.trans, g = _.keys; return new Promise(function (C, b) { C = $(C); for (var y = m.objectStore(p), S = g.length, P = new Array(S), T = 0, D = 0, k, j = function (I) { var Z = I.target; (P[Z._pos] = Z.result) != null, ++D === T && C(P) }, B = ye(b), M = 0; M < S; ++M) { var N = g[M]; N != null && (k = y.get(g[M]), k._pos = M, k.onsuccess = j, k.onerror = B, ++T) } T === 0 && C(P) }) }, get: function (_) { var m = _.trans, g = _.key; return new Promise(function (C, b) { C = $(C); var y = m.objectStore(p), S = y.get(g); S.onsuccess = function (P) { return C(P.target.result) }, S.onerror = ye(b) }) }, query: h(s), openCursor: d, count: function (_) { var m = _.query, g = _.trans, C = m.index, b = m.range; return new Promise(function (y, S) { var P = g.objectStore(p), T = C.isPrimaryKey ? P : P.index(C.name), D = i(b), k = D ? T.count(D) : T.count(); k.onsuccess = $(function (j) { return y(j.target.result) }), k.onerror = ye(S) }) } } } var o = n(e, r), u = o.schema, s = o.hasGetAll, c = u.tables.map(function (l) { return a(l) }), f = {}; return c.forEach(function (l) { return f[l.name] = l }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function (l) { var p = f[l]; if (!p) throw new Error("Table '" + l + "' not found"); return f[l] }, MIN_KEY: -1 / 0, MAX_KEY: kt(t), schema: u } } function jo(e, t) { return t.reduce(function (r, n) { var i = n.create; return A(A({}, r), i(r)) }, e) } function Fo(e, t, r, n) { var i = r.IDBKeyRange; r.indexedDB; var a = jo(Bo(t, i, n), e.dbcore); return { dbcore: a } } function ln(e, t) { var r = e._novip, n = t.db, i = Fo(r._middlewares, n, r._deps, t); r.core = i.dbcore, r.tables.forEach(function (a) { var o = a.name; r.core.schema.tables.some(function (u) { return u.name === o }) && (a.core = r.core.table(o), r[o] instanceof r.Table && (r[o].core = a.core)) }) } function ir(e, t, r, n) { var i = e._novip; r.forEach(function (a) { var o = n[a]; t.forEach(function (u) { var s = tn(u, a); (!s || "value" in s && s.value === void 0) && (u === i.Transaction.prototype || u instanceof i.Transaction ? De(u, a, { get: function () { return this.table(a) }, set: function (c) { pi(this, a, { value: c, writable: !0, configurable: !0, enumerable: !0 }) } }) : u[a] = new i.Table(a, o)) }) }) } function Nr(e, t) { var r = e._novip; t.forEach(function (n) { for (var i in n) n[i] instanceof r.Table && delete n[i] }) } function Ko(e, t) { return e._cfg.version - t._cfg.version } function Lo(e, t, r, n) { var i = e._dbSchema, a = e._createTransaction("readwrite", e._storeNames, i); a.create(r), a._completion.catch(n); var o = a._reject.bind(a), u = x.transless || x; Ke(function () { x.trans = a, x.transless = u, t === 0 ? (V(i).forEach(function (s) { pn(r, s, i[s].primKey, i[s].indexes) }), ln(e, r), E.follow(function () { return e.on.populate.fire(a) }).catch(o)) : No(e, t, a, r).catch(o) }) } function No(e, t, r, n) { var i = e._novip, a = [], o = i._versions, u = i._dbSchema = dn(i, i.idbdb, n), s = !1, c = o.filter(function (l) { return l._cfg.version >= t }); c.forEach(function (l) { a.push(function () { var p = u, v = l._cfg.dbschema; zr(i, p, n), zr(i, v, n), u = i._dbSchema = v; var d = Li(p, v); d.add.forEach(function (b) { pn(n, b[0], b[1].primKey, b[1].indexes) }), d.change.forEach(function (b) { if (b.recreate) throw new w.Upgrade("Not yet support for changing primary key"); var y = n.objectStore(b.name); b.add.forEach(function (S) { return Ur(y, S) }), b.change.forEach(function (S) { y.deleteIndex(S.name), Ur(y, S) }), b.del.forEach(function (S) { return y.deleteIndex(S) }) }); var h = l._cfg.contentUpgrade; if (h && l._cfg.version > t) { ln(i, n), r._memoizedTables = {}, s = !0; var _ = mi(v); d.del.forEach(function (b) { _[b] = p[b] }), Nr(i, [i.Transaction.prototype]), ir(i, [i.Transaction.prototype], V(_), _), r.schema = _; var m = rn(h); m && it(); var g, C = E.follow(function () { if (g = h(r), g && m) { var b = Oe.bind(null, null); g.then(b, b) } }); return g && typeof g.then == "function" ? E.resolve(g) : C.then(function () { return g }) } }), a.push(function (p) { if (!s || !vo) { var v = l._cfg.dbschema; zo(v, p) } Nr(i, [i.Transaction.prototype]), ir(i, [i.Transaction.prototype], i._storeNames, i._dbSchema), r.schema = i._dbSchema }) }); function f() { return a.length ? E.resolve(a.shift()(r.idbtrans)).then(f) : E.resolve() } return f().then(function () { Uo(u, n) }) } function Li(e, t) { var r = { del: [], add: [], change: [] }, n; for (n in e) t[n] || r.del.push(n); for (n in t) { var i = e[n], a = t[n]; if (!i) r.add.push([n, a]); else { var o = { name: n, def: a, recreate: !1, del: [], add: [], change: [] }; if ("" + (i.primKey.keyPath || "") != "" + (a.primKey.keyPath || "") || i.primKey.auto !== a.primKey.auto && !lr) o.recreate = !0, r.change.push(o); else { var u = i.idxByName, s = a.idxByName, c = void 0; for (c in u) s[c] || o.del.push(c); for (c in s) { var f = u[c], l = s[c]; f ? f.src !== l.src && o.change.push(l) : o.add.push(l) } (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && r.change.push(o) } } } return r } function pn(e, t, r, n) { var i = e.db.createObjectStore(t, r.keyPath ? { keyPath: r.keyPath, autoIncrement: r.auto } : { autoIncrement: r.auto }); return n.forEach(function (a) { return Ur(i, a) }), i } function Uo(e, t) { V(e).forEach(function (r) { t.db.objectStoreNames.contains(r) || pn(t, r, e[r].primKey, e[r].indexes) }) } function zo(e, t) { [].slice.call(t.db.objectStoreNames).forEach(function (r) { return e[r] == null && t.db.deleteObjectStore(r) }) } function Ur(e, t) { e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi }) } function dn(e, t, r) { var n = {}, i = ur(t.objectStoreNames, 0); return i.forEach(function (a) { for (var o = r.objectStore(a), u = o.keyPath, s = Kr(Fi(u), u || "", !1, !1, !!o.autoIncrement, u && typeof u != "string", !0), c = [], f = 0; f < o.indexNames.length; ++f) { var l = o.index(o.indexNames[f]); u = l.keyPath; var p = Kr(l.name, u, !!l.unique, !!l.multiEntry, !1, u && typeof u != "string", !1); c.push(p) } n[a] = Ki(a, s, c) }), n } function $o(e, t, r) { var n = e._novip; n.verno = t.version / 10; var i = n._dbSchema = dn(n, t, r); n._storeNames = ur(t.objectStoreNames, 0), ir(n, [n._allTables], V(i), i) } function Go(e, t) { var r = dn(e, e.idbdb, t), n = Li(r, e._dbSchema); return !(n.add.length || n.change.some(function (i) { return i.add.length || i.change.length })) } function zr(e, t, r) { for (var n = e._novip, i = r.db.objectStoreNames, a = 0; a < i.length; ++a) { var o = i[a], u = r.objectStore(o); n._hasGetAll = "getAll" in u; for (var s = 0; s < u.indexNames.length; ++s) { var c = u.indexNames[s], f = u.index(c).keyPath, l = typeof f == "string" ? f : "[" + ur(f).join("+") + "]"; if (t[o]) { var p = t[o].idxByName[l]; p && (p.name = c, delete t[o].idxByName[l], t[o].idxByName[c] = p) } } } typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && U.WorkerGlobalScope && U instanceof U.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1) } function Vo(e) { return e.split(",").map(function (t, r) { t = t.trim(); var n = t.replace(/([&*]|\+\+)/g, ""), i = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split("+") : n; return Kr(n, i || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), re(i), r === 0) }) } var Jo = function () { function e() { } return e.prototype._parseStoresSpec = function (t, r) { V(t).forEach(function (n) { if (t[n] !== null) { var i = Vo(t[n]), a = i.shift(); if (a.multi) throw new w.Schema("Primary key cannot be multi-valued"); i.forEach(function (o) { if (o.auto) throw new w.Schema("Only primary key can be marked as autoIncrement (++)"); if (!o.keyPath) throw new w.Schema("Index must have a name and cannot be an empty string") }), r[n] = Ki(n, a, i) } }) }, e.prototype.stores = function (t) { var r = this.db; this._cfg.storesSource = this._cfg.storesSource ? oe(this._cfg.storesSource, t) : t; var n = r._versions, i = {}, a = {}; return n.forEach(function (o) { oe(i, o._cfg.storesSource), a = o._cfg.dbschema = {}, o._parseStoresSpec(i, a) }), r._dbSchema = a, Nr(r, [r._allTables, r, r.Transaction.prototype]), ir(r, [r._allTables, r, r.Transaction.prototype, this._cfg.tables], V(a), a), r._storeNames = V(a), this }, e.prototype.upgrade = function (t) { return this._cfg.contentUpgrade = on(this._cfg.contentUpgrade || L, t), this }, e }(); function Ho(e) { return It(Jo.prototype, function (r) { this.db = e, this._cfg = { version: r, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null } }) } function hn(e, t) { var r = e._dbNamesDB; return r || (r = e._dbNamesDB = new gn(pr, { addons: [], indexedDB: e, IDBKeyRange: t }), r.version(1).stores({ dbnames: "name" })), r.table("dbnames") } function vn(e) { return e && typeof e.databases == "function" } function Wo(e) { var t = e.indexedDB, r = e.IDBKeyRange; return vn(t) ? Promise.resolve(t.databases()).then(function (n) { return n.map(function (i) { return i.name }).filter(function (i) { return i !== pr }) }) : hn(t, r).toCollection().primaryKeys() } function Yo(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !vn(r) && t !== pr && hn(r, n).put({ name: t }).catch(L) } function qo(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !vn(r) && t !== pr && hn(r, n).delete(t).catch(L) } function $r(e) { return Ke(function () { return x.letThrough = !0, e() }) } function Xo() { var e = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent); if (!e || !indexedDB.databases) return Promise.resolve(); var t; return new Promise(function (r) { var n = function () { return indexedDB.databases().finally(r) }; t = setInterval(n, 100), n() }).finally(function () { return clearInterval(t) }) } function Qo(e) { var t = e._state, r = e._deps.indexedDB; if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function () { return t.dbOpenError ? J(t.dbOpenError) : e }); _e && (t.openCanceller._stackHolder = qe()), t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1; var n = t.openCanceller; function i() { if (t.openCanceller !== n) throw new w.DatabaseClosed("db.open() was cancelled") } var a = t.dbReadyResolve, o = null, u = !1; return E.race([n, (typeof navigator > "u" ? E.resolve() : Xo()).then(function () { return new E(function (s, c) { if (i(), !r) throw new w.MissingAPI; var f = e.name, l = t.autoSchema ? r.open(f) : r.open(f, Math.round(e.verno * 10)); if (!l) throw new w.MissingAPI; l.onerror = ye(c), l.onblocked = $(e._fireOnBlocked), l.onupgradeneeded = $(function (p) { if (o = l.transaction, t.autoSchema && !e._options.allowEmptyDB) { l.onerror = St, o.abort(), l.result.close(); var v = r.deleteDatabase(f); v.onsuccess = v.onerror = $(function () { c(new w.NoSuchDatabase("Database " + f + " doesnt exist")) }) } else { o.onerror = ye(c); var d = p.oldVersion > Math.pow(2, 62) ? 0 : p.oldVersion; u = d < 1, e._novip.idbdb = l.result, Lo(e, d / 10, o, c) } }, c), l.onsuccess = $(function () { o = null; var p = e._novip.idbdb = l.result, v = ur(p.objectStoreNames); if (v.length > 0) try { var d = p.transaction(Io(v), "readonly"); t.autoSchema ? $o(e, p, d) : (zr(e, e._dbSchema, d), Go(e, d) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), ln(e, d) } catch { } mt.push(e), p.onversionchange = $(function (h) { t.vcFired = !0, e.on("versionchange").fire(h) }), p.onclose = $(function (h) { e.on("close").fire(h) }), u && Yo(e._deps, f), s() }, c) }) })]).then(function () { return i(), t.onReadyBeingFired = [], E.resolve($r(function () { return e.on.ready.fire(e.vip) })).then(function s() { if (t.onReadyBeingFired.length > 0) { var c = t.onReadyBeingFired.reduce(on, L); return t.onReadyBeingFired = [], E.resolve($r(function () { return c(e.vip) })).then(s) } }) }).finally(function () { t.onReadyBeingFired = null, t.isBeingOpened = !1 }).then(function () { return e }).catch(function (s) { t.dbOpenError = s; try { o && o.abort() } catch { } return n === t.openCanceller && e._close(), J(s) }).finally(function () { t.openComplete = !0, a() }) } function Gr(e) { var t = function (o) { return e.next(o) }, r = function (o) { return e.throw(o) }, n = a(t), i = a(r); function a(o) { return function (u) { var s = o(u), c = s.value; return s.done ? c : !c || typeof c.then != "function" ? re(c) ? Promise.all(c).then(n, i) : n(c) : c.then(n, i) } } return a(t)() } function Zo(e, t, r) { var n = arguments.length; if (n < 2) throw new w.InvalidArgument("Too few arguments"); for (var i = new Array(n - 1); --n;)i[n - 1] = arguments[n]; r = i.pop(); var a = yi(i); return [e, a, r] } function Ni(e, t, r, n, i) { return E.resolve().then(function () { var a = x.transless || x, o = e._createTransaction(t, r, e._dbSchema, n), u = { trans: o, transless: a }; if (n) o.idbtrans = n.idbtrans; else try { o.create(), e._state.PR1398_maxLoop = 3 } catch (l) { return l.name === an.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return Ni(e, t, r, null, i) })) : J(l) } var s = rn(i); s && it(); var c, f = E.follow(function () { if (c = i.call(o, o), c) if (s) { var l = Oe.bind(null, null); c.then(l, l) } else typeof c.next == "function" && typeof c.throw == "function" && (c = Gr(c)) }, u); return (c && typeof c.then == "function" ? E.resolve(c).then(function (l) { return o.active ? l : J(new w.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")) }) : f.then(function () { return c })).then(function (l) { return n && o._resolve(), o._completion.then(function () { return l }) }).catch(function (l) { return o._reject(l), J(l) }) }) } function Kt(e, t, r) { for (var n = re(e) ? e.slice() : [e], i = 0; i < r; ++i)n.push(t); return n } function es(e) { return A(A({}, e), { table: function (t) { var r = e.table(t), n = r.schema, i = {}, a = []; function o(h, _, m) { var g = yt(h), C = i[g] = i[g] || [], b = h == null ? 0 : typeof h == "string" ? 1 : h.length, y = _ > 0, S = A(A({}, m), { isVirtual: y, keyTail: _, keyLength: b, extractKey: Lr(h), unique: !y && m.unique }); if (C.push(S), S.isPrimaryKey || a.push(S), b > 1) { var P = b === 2 ? h[0] : h.slice(0, b - 1); o(P, _ + 1, m) } return C.sort(function (T, D) { return T.keyTail - D.keyTail }), S } var u = o(n.primaryKey.keyPath, 0, n.primaryKey); i[":id"] = [u]; for (var s = 0, c = n.indexes; s < c.length; s++) { var f = c[s]; o(f.keyPath, 0, f) } function l(h) { var _ = i[yt(h)]; return _ && _[0] } function p(h, _) { return { type: h.type === 1 ? 2 : h.type, lower: Kt(h.lower, h.lowerOpen ? e.MAX_KEY : e.MIN_KEY, _), lowerOpen: !0, upper: Kt(h.upper, h.upperOpen ? e.MIN_KEY : e.MAX_KEY, _), upperOpen: !0 } } function v(h) { var _ = h.query.index; return _.isVirtual ? A(A({}, h), { query: { index: _, range: p(h.query.range, _.keyTail) } }) : h } var d = A(A({}, r), { schema: A(A({}, n), { primaryKey: u, indexes: a, getIndexByKeyPath: l }), count: function (h) { return r.count(v(h)) }, query: function (h) { return r.query(v(h)) }, openCursor: function (h) { var _ = h.query.index, m = _.keyTail, g = _.isVirtual, C = _.keyLength; if (!g) return r.openCursor(h); function b(y) { function S(T) { T != null ? y.continue(Kt(T, h.reverse ? e.MAX_KEY : e.MIN_KEY, m)) : h.unique ? y.continue(y.key.slice(0, C).concat(h.reverse ? e.MIN_KEY : e.MAX_KEY, m)) : y.continue() } var P = Object.create(y, { continue: { value: S }, continuePrimaryKey: { value: function (T, D) { y.continuePrimaryKey(Kt(T, e.MAX_KEY, m), D) } }, primaryKey: { get: function () { return y.primaryKey } }, key: { get: function () { var T = y.key; return C === 1 ? T[0] : T.slice(0, C) } }, value: { get: function () { return y.value } } }); return P } return r.openCursor(v(h)).then(function (y) { return y && b(y) }) } }); return d } }) } var ts = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: es }; function mn(e, t, r, n) { return r = r || {}, n = n || "", V(e).forEach(function (i) { if (!de(t, i)) r[n + i] = void 0; else { var a = e[i], o = t[i]; if (typeof a == "object" && typeof o == "object" && a && o) { var u = Pr(a), s = Pr(o); u !== s ? r[n + i] = t[i] : u === "Object" ? mn(a, o, r, n + i + ".") : a !== o && (r[n + i] = t[i]) } else a !== o && (r[n + i] = t[i]) } }), V(t).forEach(function (i) { de(e, i) || (r[n + i] = t[i]) }), r } function rs(e, t) { return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey) } var ns = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function (e) { return A(A({}, e), { table: function (t) { var r = e.table(t), n = r.schema.primaryKey, i = A(A({}, r), { mutate: function (a) { var o = x.trans, u = o.table(t).hook, s = u.deleting, c = u.creating, f = u.updating; switch (a.type) { case "add": if (c.fire === L) break; return o._promise("readwrite", function () { return l(a) }, !0); case "put": if (c.fire === L && f.fire === L) break; return o._promise("readwrite", function () { return l(a) }, !0); case "delete": if (s.fire === L) break; return o._promise("readwrite", function () { return l(a) }, !0); case "deleteRange": if (s.fire === L) break; return o._promise("readwrite", function () { return p(a) }, !0) }return r.mutate(a); function l(d) { var h = x.trans, _ = d.keys || rs(n, d); if (!_) throw new Error("Keys missing"); return d = d.type === "add" || d.type === "put" ? A(A({}, d), { keys: _ }) : A({}, d), d.type !== "delete" && (d.values = Tr([], d.values, !0)), d.keys && (d.keys = Tr([], d.keys, !0)), is(r, d, _).then(function (m) { var g = _.map(function (C, b) { var y = m[b], S = { onerror: null, onsuccess: null }; if (d.type === "delete") s.fire.call(S, C, y, h); else if (d.type === "add" || y === void 0) { var P = c.fire.call(S, C, d.values[b], h); C == null && P != null && (C = P, d.keys[b] = C, n.outbound || me(d.values[b], n.keyPath, C)) } else { var T = mn(y, d.values[b]), D = f.fire.call(S, T, C, y, h); if (D) { var k = d.values[b]; Object.keys(D).forEach(function (j) { de(k, j) ? k[j] = D[j] : me(k, j, D[j]) }) } } return S }); return r.mutate(d).then(function (C) { for (var b = C.failures, y = C.results, S = C.numFailures, P = C.lastResult, T = 0; T < _.length; ++T) { var D = y ? y[T] : _[T], k = g[T]; D == null ? k.onerror && k.onerror(b[T]) : k.onsuccess && k.onsuccess(d.type === "put" && m[T] ? d.values[T] : D) } return { failures: b, results: y, numFailures: S, lastResult: P } }).catch(function (C) { return g.forEach(function (b) { return b.onerror && b.onerror(C) }), Promise.reject(C) }) }) } function p(d) { return v(d.trans, d.range, 1e4) } function v(d, h, _) { return r.query({ trans: d, values: !1, query: { index: n, range: h }, limit: _ }).then(function (m) { var g = m.result; return l({ type: "delete", keys: g, trans: d }).then(function (C) { return C.numFailures > 0 ? Promise.reject(C.failures[0]) : g.length < _ ? { failures: [], numFailures: 0, lastResult: void 0 } : v(d, A(A({}, h), { lower: g[g.length - 1], lowerOpen: !0 }), _) }) }) } } }); return i } }) } }; function is(e, t, r) { return t.type === "add" ? Promise.resolve([]) : e.getMany({ trans: t.trans, keys: r, cache: "immutable" }) } function Ui(e, t, r) { try { if (!t || t.keys.length < e.length) return null; for (var n = [], i = 0, a = 0; i < t.keys.length && a < e.length; ++i)ae(t.keys[i], e[a]) === 0 && (n.push(r ? Rt(t.values[i]) : t.values[i]), ++a); return n.length === e.length ? n : null } catch { return null } } var as = { stack: "dbcore", level: -1, create: function (e) { return { table: function (t) { var r = e.table(t); return A(A({}, r), { getMany: function (n) { if (!n.cache) return r.getMany(n); var i = Ui(n.keys, n.trans._cache, n.cache === "clone"); return i ? E.resolve(i) : r.getMany(n).then(function (a) { return n.trans._cache = { keys: n.keys, values: n.cache === "clone" ? Rt(a) : a }, a }) }, mutate: function (n) { return n.type !== "add" && (n.trans._cache = null), r.mutate(n) } }) } } } }, br; function yn(e) { return !("from" in e) } var Te = function (e, t) { if (this) oe(this, arguments.length ? { d: 1, from: e, to: arguments.length > 1 ? t : e } : { d: 0 }); else { var r = new Te; return e && "d" in e && oe(r, e), r } }; tt(Te.prototype, (br = { add: function (e) { return ar(this, e), this }, addKey: function (e) { return Pt(this, e, e), this }, addKeys: function (e) { var t = this; return e.forEach(function (r) { return Pt(t, r, r) }), this } }, br[Er] = function () { return Vr(this) }, br)); function Pt(e, t, r) { var n = ae(t, r); if (!isNaN(n)) { if (n > 0) throw RangeError(); if (yn(e)) return oe(e, { from: t, to: r, d: 1 }); var i = e.l, a = e.r; if (ae(r, e.from) < 0) return i ? Pt(i, t, r) : e.l = { from: t, to: r, d: 1, l: null, r: null }, Fn(e); if (ae(t, e.to) > 0) return a ? Pt(a, t, r) : e.r = { from: t, to: r, d: 1, l: null, r: null }, Fn(e); ae(t, e.from) < 0 && (e.from = t, e.l = null, e.d = a ? a.d + 1 : 1), ae(r, e.to) > 0 && (e.to = r, e.r = null, e.d = e.l ? e.l.d + 1 : 1); var o = !e.r; i && !e.l && ar(e, i), a && o && ar(e, a) } } function ar(e, t) { function r(n, i) { var a = i.from, o = i.to, u = i.l, s = i.r; Pt(n, a, o), u && r(n, u), s && r(n, s) } yn(t) || r(e, t) } function os(e, t) { var r = Vr(t), n = r.next(); if (n.done) return !1; for (var i = n.value, a = Vr(e), o = a.next(i.from), u = o.value; !n.done && !o.done;) { if (ae(u.from, i.to) <= 0 && ae(u.to, i.from) >= 0) return !0; ae(i.from, u.from) < 0 ? i = (n = r.next(u.from)).value : u = (o = a.next(i.from)).value } return !1 } function Vr(e) { var t = yn(e) ? null : { s: 0, n: e }; return { next: function (r) { for (var n = arguments.length > 0; t;)switch (t.s) { case 0: if (t.s = 1, n) for (; t.n.l && ae(r, t.n.from) < 0;)t = { up: t, n: t.n.l, s: 1 }; else for (; t.n.l;)t = { up: t, n: t.n.l, s: 1 }; case 1: if (t.s = 2, !n || ae(r, t.n.to) <= 0) return { value: t.n, done: !1 }; case 2: if (t.n.r) { t.s = 3, t = { up: t, n: t.n.r, s: 0 }; continue } case 3: t = t.up }return { done: !0 } } } } function Fn(e) { var t, r, n = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((r = e.l) === null || r === void 0 ? void 0 : r.d) || 0), i = n > 1 ? "r" : n < -1 ? "l" : ""; if (i) { var a = i === "r" ? "l" : "r", o = A({}, e), u = e[i]; e.from = u.from, e.to = u.to, e[i] = u[i], o[i] = u[a], e[a] = o, o.d = Kn(o) } e.d = Kn(e) } function Kn(e) { var t = e.r, r = e.l; return (t ? r ? Math.max(t.d, r.d) : t.d : r ? r.d : 0) + 1 } var ss = { stack: "dbcore", level: 0, create: function (e) { var t = e.schema.name, r = new Te(e.MIN_KEY, e.MAX_KEY); return A(A({}, e), { table: function (n) { var i = e.table(n), a = i.schema, o = a.primaryKey, u = o.extractKey, s = o.outbound, c = A(A({}, i), { mutate: function (p) { var v = p.trans, d = v.mutatedParts || (v.mutatedParts = {}), h = function (P) { var T = "idb://" + t + "/" + n + "/" + P; return d[T] || (d[T] = new Te) }, _ = h(""), m = h(":dels"), g = p.type, C = p.type === "deleteRange" ? [p.range] : p.type === "delete" ? [p.keys] : p.values.length < 50 ? [[], p.values] : [], b = C[0], y = C[1], S = p.trans._cache; return i.mutate(p).then(function (P) { if (re(b)) { g !== "delete" && (b = P.results), _.addKeys(b); var T = Ui(b, S); !T && g !== "add" && m.addKeys(b), (T || y) && cs(h, a, T, y) } else if (b) { var D = { from: b.lower, to: b.upper }; m.add(D), _.add(D) } else _.add(r), m.add(r), a.indexes.forEach(function (k) { return h(k.name).add(r) }); return P }) } }), f = function (p) { var v, d, h = p.query, _ = h.index, m = h.range; return [_, new Te((v = m.lower) !== null && v !== void 0 ? v : e.MIN_KEY, (d = m.upper) !== null && d !== void 0 ? d : e.MAX_KEY)] }, l = { get: function (p) { return [o, new Te(p.key)] }, getMany: function (p) { return [o, new Te().addKeys(p.keys)] }, count: f, query: f, openCursor: f }; return V(l).forEach(function (p) { c[p] = function (v) { var d = x.subscr; if (d) { var h = function (S) { var P = "idb://" + t + "/" + n + "/" + S; return d[P] || (d[P] = new Te) }, _ = h(""), m = h(":dels"), g = l[p](v), C = g[0], b = g[1]; if (h(C.name || "").add(b), !C.isPrimaryKey) if (p === "count") m.add(r); else { var y = p === "query" && s && v.values && i.query(A(A({}, v), { values: !1 })); return i[p].apply(this, arguments).then(function (S) { if (p === "query") { if (s && v.values) return y.then(function (k) { var j = k.result; return _.addKeys(j), S }); var P = v.values ? S.result.map(u) : S.result; v.values ? _.addKeys(P) : m.addKeys(P) } else if (p === "openCursor") { var T = S, D = v.values; return T && Object.create(T, { key: { get: function () { return m.addKey(T.primaryKey), T.key } }, primaryKey: { get: function () { var k = T.primaryKey; return m.addKey(k), k } }, value: { get: function () { return D && _.addKey(T.primaryKey), T.value } } }) } return S }) } } return i[p].apply(this, arguments) } }), c } }) } }; function cs(e, t, r, n) { function i(a) { var o = e(a.name || ""); function u(c) { return c != null ? a.extractKey(c) : null } var s = function (c) { return a.multiEntry && re(c) ? c.forEach(function (f) { return o.addKey(f) }) : o.addKey(c) }; (r || n).forEach(function (c, f) { var l = r && u(r[f]), p = n && u(n[f]); ae(l, p) !== 0 && (l != null && s(l), p != null && s(p)) }) } t.indexes.forEach(i) } var gn = function () { function e(t, r) { var n = this; this._middlewares = {}, this.verno = 0; var i = e.dependencies; this._options = r = A({ addons: e.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange }, r), this._deps = { indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange }; var a = r.addons; this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this; var o = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: L, dbReadyPromise: null, cancelOpen: L, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 }; o.dbReadyPromise = new E(function (u) { o.dbReadyResolve = u }), o.openCanceller = new E(function (u, s) { o.cancelOpen = s }), this._state = o, this.name = t, this.on = wt(this, "populate", "blocked", "versionchange", "close", { ready: [on, L] }), this.on.ready.subscribe = di(this.on.ready.subscribe, function (u) { return function (s, c) { e.vip(function () { var f = n._state; if (f.openComplete) f.dbOpenError || E.resolve().then(s), c && u(s); else if (f.onReadyBeingFired) f.onReadyBeingFired.push(s), c && u(s); else { u(s); var l = n; c || u(function p() { l.on.ready.unsubscribe(s), l.on.ready.unsubscribe(p) }) } }) } }), this.Collection = To(this), this.Table = go(this), this.Transaction = wo(this), this.Version = Ho(this), this.WhereClause = Do(this), this.on("versionchange", function (u) { u.newVersion > 0 ? console.warn("Another connection wants to upgrade database '" + n.name + "'. Closing db now to resume the upgrade.") : console.warn("Another connection wants to delete database '" + n.name + "'. Closing db now to resume the delete request."), n.close() }), this.on("blocked", function (u) { !u.newVersion || u.newVersion < u.oldVersion ? console.warn("Dexie.delete('" + n.name + "') was blocked") : console.warn("Upgrade '" + n.name + "' blocked by other connection holding version " + u.oldVersion / 10) }), this._maxKey = kt(r.IDBKeyRange), this._createTransaction = function (u, s, c, f) { return new n.Transaction(u, s, c, n._options.chromeTransactionDurability, f) }, this._fireOnBlocked = function (u) { n.on("blocked").fire(u), mt.filter(function (s) { return s.name === n.name && s !== n && !s._state.vcFired }).map(function (s) { return s.on("versionchange").fire(u) }) }, this.use(ts), this.use(ns), this.use(ss), this.use(as), this.vip = Object.create(this, { _vip: { value: !0 } }), a.forEach(function (u) { return u(n) }) } return e.prototype.version = function (t) { if (isNaN(t) || t < .1) throw new w.Type("Given version is not a positive number"); if (t = Math.round(t * 10) / 10, this.idbdb || this._state.isBeingOpened) throw new w.Schema("Cannot add version when database is open"); this.verno = Math.max(this.verno, t); var r = this._versions, n = r.filter(function (i) { return i._cfg.version === t })[0]; return n || (n = new this.Version(t), r.push(n), r.sort(Ko), n.stores({}), this._state.autoSchema = !1, n) }, e.prototype._whenReady = function (t) { var r = this; return this.idbdb && (this._state.openComplete || x.letThrough || this._vip) ? t() : new E(function (n, i) { if (r._state.openComplete) return i(new w.DatabaseClosed(r._state.dbOpenError)); if (!r._state.isBeingOpened) { if (!r._options.autoOpen) { i(new w.DatabaseClosed); return } r.open().catch(L) } r._state.dbReadyPromise.then(n, i) }).then(t) }, e.prototype.use = function (t) { var r = t.stack, n = t.create, i = t.level, a = t.name; a && this.unuse({ stack: r, name: a }); var o = this._middlewares[r] || (this._middlewares[r] = []); return o.push({ stack: r, create: n, level: i == null ? 10 : i, name: a }), o.sort(function (u, s) { return u.level - s.level }), this }, e.prototype.unuse = function (t) { var r = t.stack, n = t.name, i = t.create; return r && this._middlewares[r] && (this._middlewares[r] = this._middlewares[r].filter(function (a) { return i ? a.create !== i : n ? a.name !== n : !1 })), this }, e.prototype.open = function () { return Qo(this) }, e.prototype._close = function () { var t = this._state, r = mt.indexOf(this); if (r >= 0 && mt.splice(r, 1), this.idbdb) { try { this.idbdb.close() } catch { } this._novip.idbdb = null } t.dbReadyPromise = new E(function (n) { t.dbReadyResolve = n }), t.openCanceller = new E(function (n, i) { t.cancelOpen = i }) }, e.prototype.close = function () { this._close(); var t = this._state; this._options.autoOpen = !1, t.dbOpenError = new w.DatabaseClosed, t.isBeingOpened && t.cancelOpen(t.dbOpenError) }, e.prototype.delete = function () { var t = this, r = arguments.length > 0, n = this._state; return new E(function (i, a) { var o = function () { t.close(); var u = t._deps.indexedDB.deleteDatabase(t.name); u.onsuccess = $(function () { qo(t._deps, t.name), i() }), u.onerror = ye(a), u.onblocked = t._fireOnBlocked }; if (r) throw new w.InvalidArgument("Arguments not allowed in db.delete()"); n.isBeingOpened ? n.dbReadyPromise.then(o) : o() }) }, e.prototype.backendDB = function () { return this.idbdb }, e.prototype.isOpen = function () { return this.idbdb !== null }, e.prototype.hasBeenClosed = function () { var t = this._state.dbOpenError; return t && t.name === "DatabaseClosed" }, e.prototype.hasFailed = function () { return this._state.dbOpenError !== null }, e.prototype.dynamicallyOpened = function () { return this._state.autoSchema }, Object.defineProperty(e.prototype, "tables", { get: function () { var t = this; return V(this._allTables).map(function (r) { return t._allTables[r] }) }, enumerable: !1, configurable: !0 }), e.prototype.transaction = function () { var t = Zo.apply(this, arguments); return this._transaction.apply(this, t) }, e.prototype._transaction = function (t, r, n) { var i = this, a = x.trans; (!a || a.db !== this || t.indexOf("!") !== -1) && (a = null); var o = t.indexOf("?") !== -1; t = t.replace("!", "").replace("?", ""); var u, s; try { if (s = r.map(function (f) { var l = f instanceof i.Table ? f.name : f; if (typeof l != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed"); return l }), t == "r" || t === vr) u = vr; else if (t == "rw" || t == mr) u = mr; else throw new w.InvalidArgument("Invalid transaction mode: " + t); if (a) { if (a.mode === vr && u === mr) if (o) a = null; else throw new w.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY"); a && s.forEach(function (f) { if (a && a.storeNames.indexOf(f) === -1) if (o) a = null; else throw new w.SubTransaction("Table " + f + " not included in parent transaction.") }), o && a && !a.active && (a = null) } } catch (f) { return a ? a._promise(null, function (l, p) { p(f) }) : J(f) } var c = Ni.bind(null, this, u, s, a, n); return a ? a._promise(u, c, "lock") : x.trans ? at(x.transless, function () { return i._whenReady(c) }) : this._whenReady(c) }, e.prototype.table = function (t) { if (!de(this._allTables, t)) throw new w.InvalidTable("Table " + t + " does not exist"); return this._allTables[t] }, e }(), us = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", fs = function () { function e(t) { this._subscribe = t } return e.prototype.subscribe = function (t, r, n) { return this._subscribe(!t || typeof t == "function" ? { next: t, error: r, complete: n } : t) }, e.prototype[us] = function () { return this }, e }(); function zi(e, t) { return V(t).forEach(function (r) { var n = e[r] || (e[r] = new Te); ar(n, t[r]) }), e } function ls(e) { return new fs(function (t) { var r = rn(e); function n(v) { r && it(); var d = function () { return Ke(e, { subscr: v, trans: null }) }, h = x.trans ? at(x.transless, d) : d(); return r && h.then(Oe, Oe), h } var i = !1, a = {}, o = {}, u = { get closed() { return i }, unsubscribe: function () { i = !0, Ne.storagemutated.unsubscribe(l) } }; t.start && t.start(u); var s = !1, c = !1; function f() { return V(o).some(function (v) { return a[v] && os(a[v], o[v]) }) } var l = function (v) { zi(a, v), f() && p() }, p = function () { if (!(s || i)) { a = {}; var v = {}, d = n(v); c || (Ne(Tt, l), c = !0), s = !0, Promise.resolve(d).then(function (h) { s = !1, !i && (f() ? p() : (a = {}, o = v, t.next && t.next(h))) }, function (h) { s = !1, t.error && t.error(h), u.unsubscribe() }) } }; return p(), u }) } var Jr; try { Jr = { indexedDB: U.indexedDB || U.mozIndexedDB || U.webkitIndexedDB || U.msIndexedDB, IDBKeyRange: U.IDBKeyRange || U.webkitIDBKeyRange } } catch { Jr = { indexedDB: null, IDBKeyRange: null } } var $e = gn; tt($e, A(A({}, fr), { delete: function (e) { var t = new $e(e, { addons: [] }); return t.delete() }, exists: function (e) { return new $e(e, { addons: [] }).open().then(function (t) { return t.close(), !0 }).catch("NoSuchDatabaseError", function () { return !1 }) }, getDatabaseNames: function (e) { try { return Wo($e.dependencies).then(e) } catch { return J(new w.MissingAPI) } }, defineClass: function () { function e(t) { oe(this, t) } return e }, ignoreTransaction: function (e) { return x.trans ? at(x.transless, e) : e() }, vip: $r, async: function (e) { return function () { try { var t = Gr(e.apply(this, arguments)); return !t || typeof t.then != "function" ? E.resolve(t) : t } catch (r) { return J(r) } } }, spawn: function (e, t, r) { try { var n = Gr(e.apply(r, t || [])); return !n || typeof n.then != "function" ? E.resolve(n) : n } catch (i) { return J(i) } }, currentTransaction: { get: function () { return x.trans || null } }, waitFor: function (e, t) { var r = E.resolve(typeof e == "function" ? $e.ignoreTransaction(e) : e).timeout(t || 6e4); return x.trans ? x.trans.waitFor(r) : r }, Promise: E, debug: { get: function () { return _e }, set: function (e) { _i(e, e === "dexie" ? function () { return !0 } : Ai) } }, derive: rt, extend: oe, props: tt, override: di, Events: wt, on: Ne, liveQuery: ls, extendObservabilitySet: zi, getByKeyPath: xe, setByKeyPath: me, delByKeyPath: za, shallowClone: mi, deepClone: Rt, getObjectDiff: mn, cmp: ae, asap: hi, minKey: Fr, addons: [], connections: mt, errnames: an, dependencies: Jr, semVer: wn, version: wn.split(".").map(function (e) { return parseInt(e) }).reduce(function (e, t, r) { return e + t / Math.pow(10, r * 2) }) })); $e.maxKey = kt($e.dependencies.IDBKeyRange); typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ne(Tt, function (e) { if (!Ee) { var t; lr ? (t = document.createEvent("CustomEvent"), t.initCustomEvent(Fe, !0, !0, e)) : t = new CustomEvent(Fe, { detail: e }), Ee = !0, dispatchEvent(t), Ee = !1 } }), addEventListener(Fe, function (e) { var t = e.detail; Ee || or(t) })); function or(e) { var t = Ee; try { Ee = !0, Ne.storagemutated.fire(e) } finally { Ee = t } } var Ee = !1; if (typeof BroadcastChannel < "u") { var Ln = new BroadcastChannel(Fe); Ne(Tt, function (e) { Ee || Ln.postMessage(e) }), Ln.onmessage = function (e) { e.data && or(e.data) } } else if (typeof self < "u" && typeof navigator < "u") { Ne(Tt, function (e) { try { Ee || (typeof localStorage < "u" && localStorage.setItem(Fe, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && Tr([], self.clients.matchAll({ includeUncontrolled: !0 }), !0).forEach(function (t) { return t.postMessage({ type: Fe, changedParts: e }) })) } catch { } }), typeof addEventListener < "u" && addEventListener("storage", function (e) { if (e.key === Fe) { var t = JSON.parse(e.newValue); t && or(t.changedParts) } }); var Nn = self.document && navigator.serviceWorker; Nn && Nn.addEventListener("message", ps) } function ps(e) { var t = e.data; t && t.type === Fe && or(t.changedParts) } E.rejectionMapper = Xa; _i(_e, Ai); class $i { constructor(t) { z(this, "id"); z(this, "peerID"); z(this, "apiKey"); this.id = t } async save(t) { await ge.networking.update(this.id, t) } async add() { await ge.networking.add(this) } remove() { ge.networking.delete(this.id) } } class ds extends gn { constructor() { super("NanofactoryDatabase"); z(this, "printer"); z(this, "networking"); this.version(1).stores({ printer: "id", networking: "id, peerID, apiKey" }), this.printer.mapToClass(Gi), this.networking.mapToClass($i) } } let ge; async function hs() { ge = new ds, ge.open() } var lt = (e => (e.operational = "Operational", e.offline = "Offline", e.printing = "Printing", e.error = "Error", e.paused = "Paused", e))(lt || {}); class Gi { constructor(t) { z(this, "id"); z(this, "name"); z(this, "color"); z(this, "model"); z(this, "volume"); z(this, "heatedBed"); z(this, "heatedChamber"); z(this, "axes"); z(this, "extruder"); z(this, "state"); z(this, "bedLevellingGraph"); z(this, "position"); z(this, "connectionOptions"); z(this, "temperatureHistory"); z(this, "filamentID"); z(this, "isQueuePaused"); z(this, "queuePausedReason"); z(this, "nanofactoryInstallDate"); this.id = t, this.name = "", this.model = "", this.volume = { formFactor: "rectangular", centerOrigin: "center", width: 0, depth: 0, height: 0 }, this.heatedBed = !0, this.heatedChamber = !1, this.nanofactoryInstallDate = new Date, this.state = { status: "Offline" }, this.connectionOptions = { ports: [], baudrates: [], printerProfiles: [], portPreference: "auto", baudratePreference: "auto", printerProfilePreference: "_default", autoconnect: !1 }, this.temperatureHistory = [], this.axes = { x: { inverted: !1, speed: 0 }, y: { inverted: !1, speed: 0 }, z: { inverted: !1, speed: 0 }, e: { inverted: !1, speed: 0 } }, this.extruder = { count: 1, offsets: [] }, this.position = { x: 0, y: 0, z: 0, e: 0, relative: !1, speed: 0 }, this.filamentID = "", this.isQueuePaused = !0, this.queuePausedReason = "Printer has not been assigned a job" } async save(t) { await ge.printer.update(this.id, t) } async add() { await ge.printer.add(this) } remove() { ge.printer.delete(this.id) } toString() { return `${this.model} ${this.name} status: ${this.state.status}` } } async function vs() { console.log("Save printer profile called"); let e = await Vi(); e.id = ke.id, await Ve.save(e) } async function ms() { await Ve.save({ connectionOptions: await Ji() }) } async function ys() { await Ve.save({ state: { status: await _n() } }) } function gs(e) { return e.includes("Operational") ? lt.operational : e.includes("Printing") ? lt.printing : e.includes("Paused") ? lt.paused : lt.offline } async function Vi() { try { return await (await fetch("http://localhost:5000/api/printerprofiles/_default", { method: "GET", headers: { "X-API-KEY": K.apiKey } })).json() } catch (e) { return console.error(e), {} } } async function Ji() { try { return await (await fetch("http://localhost:5000/api/connection", { method: "GET", headers: { "X-API-KEY": K.apiKey } })).json() } catch (e) { return console.error(e), {} } } async function _n() { try { return gs((await (await fetch("http://localhost:5000/api/printer", { method: "GET", headers: { "X-API-KEY": K.apiKey } })).json()).state.text) } catch { return "Offline" } } function _s(e, t, r, n) { let i = { command: "connect", save: n, autoconnect: r }; e.includes("auto") || (i.port = e), t.includes("auto") || (i.baudrate = parseInt(t)), fetch("http://localhost:5000/api/connection", { method: "POST", headers: { "X-API-KEY": K.apiKey, "Content-Type": "application/json" }, body: JSON.stringify(i) }) } function bs() { fetch("http://localhost:5000/api/connection", { method: "POST", headers: { "X-API-KEY": K.apiKey, "Content-Type": "application/json" }, body: JSON.stringify({ command: "disconnect" }) }) } function Hi(e, t, r) { const n = { label: r, metadata: e, serialization: "json", reliable: !0 }, i = ke.connect(e, n); i.on("open", function () { i.send(JSON.stringify(t)), console.log("Sent:", t) }), i.on("error", function (a) { console.error("Could not send data: " + a) }) } function Cs(e, t, r, n) { switch (e = JSON.parse(e), n = JSON.parse(n), r) { case je.syncAllRequest: Ss(t); break; case je.connectPrinter: _s(e.port, e.baudrate, e.autoconnect, e.save); break; case je.disconnectPrinter: bs(); break; case je.jobCreated: break; case je.handshakeRequest: Ts(t); break; default: console.log("Unhandled label: " + r); break } } async function Ss(e) { let t = { printer_profile: {}, connection_options: {}, printer_state: {}, current_position: { x: 0, y: 0, z: 0, e: 0, speed: 0, relative: !1 }, bed_levelling_data: [], queue_state: { isQueuePaused: !1, queuePausedReason: "testing" }, current_job: { id: "" }, print_queue: [], jobs_history: [], current_filament: { current_filament: {} }, scripts: {} }; t.printer_profile = await Vi(), t.connection_options = (await Ji()).options, t.printer_state = { status: await _n() }, Hi(e, t, je.syncAllResponse) } async function Ts(e) { Hi(e, { status: await _n() }, je.handshakeResponse) } var bn = { exports: {} }; (function (e) { var t = {}; t.useBlobBuilder = function () { try { return new Blob([]), !1 } catch { return !0 } }(), t.useArrayBufferView = !t.useBlobBuilder && function () { try { return new Blob([new Uint8Array([])]).size === 0 } catch { return !0 } }(), e.exports.binaryFeatures = t; var r = e.exports.BlobBuilder; typeof window < "u" && (r = e.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder); function n() { this._pieces = [], this._parts = [] } n.prototype.append = function (i) { typeof i == "number" ? this._pieces.push(i) : (this.flush(), this._parts.push(i)) }, n.prototype.flush = function () { if (this._pieces.length > 0) { var i = new Uint8Array(this._pieces); t.useArrayBufferView || (i = i.buffer), this._parts.push(i), this._pieces = [] } }, n.prototype.getBuffer = function () { if (this.flush(), t.useBlobBuilder) { for (var i = new r, a = 0, o = this._parts.length; a < o; a++)i.append(this._parts[a]); return i.getBlob() } else return new Blob(this._parts) }, e.exports.BufferBuilder = n })(bn); var ks = bn.exports.BufferBuilder, Un = bn.exports.binaryFeatures, Ps = { unpack: function (e) { var t = new X(e); return t.unpack() }, pack: function (e) { var t = new Q; t.pack(e); var r = t.getBuffer(); return r } }, zn = Ps; function X(e) { this.index = 0, this.dataBuffer = e, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength } X.prototype.unpack = function () { var e = this.unpack_uint8(); if (e < 128) return e; if ((e ^ 224) < 32) return (e ^ 224) - 32; var t; if ((t = e ^ 160) <= 15) return this.unpack_raw(t); if ((t = e ^ 176) <= 15) return this.unpack_string(t); if ((t = e ^ 144) <= 15) return this.unpack_array(t); if ((t = e ^ 128) <= 15) return this.unpack_map(t); switch (e) { case 192: return null; case 193: return; case 194: return !1; case 195: return !0; case 202: return this.unpack_float(); case 203: return this.unpack_double(); case 204: return this.unpack_uint8(); case 205: return this.unpack_uint16(); case 206: return this.unpack_uint32(); case 207: return this.unpack_uint64(); case 208: return this.unpack_int8(); case 209: return this.unpack_int16(); case 210: return this.unpack_int32(); case 211: return this.unpack_int64(); case 212: return; case 213: return; case 214: return; case 215: return; case 216: return t = this.unpack_uint16(), this.unpack_string(t); case 217: return t = this.unpack_uint32(), this.unpack_string(t); case 218: return t = this.unpack_uint16(), this.unpack_raw(t); case 219: return t = this.unpack_uint32(), this.unpack_raw(t); case 220: return t = this.unpack_uint16(), this.unpack_array(t); case 221: return t = this.unpack_uint32(), this.unpack_array(t); case 222: return t = this.unpack_uint16(), this.unpack_map(t); case 223: return t = this.unpack_uint32(), this.unpack_map(t) } }; X.prototype.unpack_uint8 = function () { var e = this.dataView[this.index] & 255; return this.index++, e }; X.prototype.unpack_uint16 = function () { var e = this.read(2), t = (e[0] & 255) * 256 + (e[1] & 255); return this.index += 2, t }; X.prototype.unpack_uint32 = function () { var e = this.read(4), t = ((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]; return this.index += 4, t }; X.prototype.unpack_uint64 = function () { var e = this.read(8), t = ((((((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]) * 256 + e[4]) * 256 + e[5]) * 256 + e[6]) * 256 + e[7]; return this.index += 8, t }; X.prototype.unpack_int8 = function () { var e = this.unpack_uint8(); return e < 128 ? e : e - (1 << 8) }; X.prototype.unpack_int16 = function () { var e = this.unpack_uint16(); return e < 32768 ? e : e - (1 << 16) }; X.prototype.unpack_int32 = function () { var e = this.unpack_uint32(); return e < Math.pow(2, 31) ? e : e - Math.pow(2, 32) }; X.prototype.unpack_int64 = function () { var e = this.unpack_uint64(); return e < Math.pow(2, 63) ? e : e - Math.pow(2, 64) }; X.prototype.unpack_raw = function (e) { if (this.length < this.index + e) throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + e + " " + this.length); var t = this.dataBuffer.slice(this.index, this.index + e); return this.index += e, t }; X.prototype.unpack_string = function (e) { for (var t = this.read(e), r = 0, n = "", i, a; r < e;)i = t[r], i < 128 ? (n += String.fromCharCode(i), r++) : (i ^ 192) < 32 ? (a = (i ^ 192) << 6 | t[r + 1] & 63, n += String.fromCharCode(a), r += 2) : (a = (i & 15) << 12 | (t[r + 1] & 63) << 6 | t[r + 2] & 63, n += String.fromCharCode(a), r += 3); return this.index += e, n }; X.prototype.unpack_array = function (e) { for (var t = new Array(e), r = 0; r < e; r++)t[r] = this.unpack(); return t }; X.prototype.unpack_map = function (e) { for (var t = {}, r = 0; r < e; r++) { var n = this.unpack(), i = this.unpack(); t[n] = i } return t }; X.prototype.unpack_float = function () { var e = this.unpack_uint32(), t = e >> 31, r = (e >> 23 & 255) - 127, n = e & 8388607 | 8388608; return (t === 0 ? 1 : -1) * n * Math.pow(2, r - 23) }; X.prototype.unpack_double = function () { var e = this.unpack_uint32(), t = this.unpack_uint32(), r = e >> 31, n = (e >> 20 & 2047) - 1023, i = e & 1048575 | 1048576, a = i * Math.pow(2, n - 20) + t * Math.pow(2, n - 52); return (r === 0 ? 1 : -1) * a }; X.prototype.read = function (e) { var t = this.index; if (t + e <= this.length) return this.dataView.subarray(t, t + e); throw new Error("BinaryPackFailure: read index out of range") }; function Q() { this.bufferBuilder = new ks } Q.prototype.getBuffer = function () { return this.bufferBuilder.getBuffer() }; Q.prototype.pack = function (e) { var t = typeof e; if (t === "string") this.pack_string(e); else if (t === "number") Math.floor(e) === e ? this.pack_integer(e) : this.pack_double(e); else if (t === "boolean") e === !0 ? this.bufferBuilder.append(195) : e === !1 && this.bufferBuilder.append(194); else if (t === "undefined") this.bufferBuilder.append(192); else if (t === "object") if (e === null) this.bufferBuilder.append(192); else { var r = e.constructor; if (r == Array) this.pack_array(e); else if (r == Blob || r == File || e instanceof Blob || e instanceof File) this.pack_bin(e); else if (r == ArrayBuffer) Un.useArrayBufferView ? this.pack_bin(new Uint8Array(e)) : this.pack_bin(e); else if ("BYTES_PER_ELEMENT" in e) Un.useArrayBufferView ? this.pack_bin(new Uint8Array(e.buffer)) : this.pack_bin(e.buffer); else if (r == Object || r.toString().startsWith("class")) this.pack_object(e); else if (r == Date) this.pack_string(e.toString()); else if (typeof e.toBinaryPack == "function") this.bufferBuilder.append(e.toBinaryPack()); else throw new Error('Type "' + r.toString() + '" not yet supported') } else throw new Error('Type "' + t + '" not yet supported'); this.bufferBuilder.flush() }; Q.prototype.pack_bin = function (e) { var t = e.length || e.byteLength || e.size; if (t <= 15) this.pack_uint8(160 + t); else if (t <= 65535) this.bufferBuilder.append(218), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(219), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; Q.prototype.pack_string = function (e) { var t = Rs(e); if (t <= 15) this.pack_uint8(176 + t); else if (t <= 65535) this.bufferBuilder.append(216), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(217), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; Q.prototype.pack_array = function (e) { var t = e.length; if (t <= 15) this.pack_uint8(144 + t); else if (t <= 65535) this.bufferBuilder.append(220), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(221), this.pack_uint32(t); else throw new Error("Invalid length"); for (var r = 0; r < t; r++)this.pack(e[r]) }; Q.prototype.pack_integer = function (e) { if (e >= -32 && e <= 127) this.bufferBuilder.append(e & 255); else if (e >= 0 && e <= 255) this.bufferBuilder.append(204), this.pack_uint8(e); else if (e >= -128 && e <= 127) this.bufferBuilder.append(208), this.pack_int8(e); else if (e >= 0 && e <= 65535) this.bufferBuilder.append(205), this.pack_uint16(e); else if (e >= -32768 && e <= 32767) this.bufferBuilder.append(209), this.pack_int16(e); else if (e >= 0 && e <= 4294967295) this.bufferBuilder.append(206), this.pack_uint32(e); else if (e >= -2147483648 && e <= 2147483647) this.bufferBuilder.append(210), this.pack_int32(e); else if (e >= -9223372036854776e3 && e <= 9223372036854776e3) this.bufferBuilder.append(211), this.pack_int64(e); else if (e >= 0 && e <= 18446744073709552e3) this.bufferBuilder.append(207), this.pack_uint64(e); else throw new Error("Invalid integer") }; Q.prototype.pack_double = function (e) { var t = 0; e < 0 && (t = 1, e = -e); var r = Math.floor(Math.log(e) / Math.LN2), n = e / Math.pow(2, r) - 1, i = Math.floor(n * Math.pow(2, 52)), a = Math.pow(2, 32), o = t << 31 | r + 1023 << 20 | i / a & 1048575, u = i % a; this.bufferBuilder.append(203), this.pack_int32(o), this.pack_int32(u) }; Q.prototype.pack_object = function (e) { var t = Object.keys(e), r = t.length; if (r <= 15) this.pack_uint8(128 + r); else if (r <= 65535) this.bufferBuilder.append(222), this.pack_uint16(r); else if (r <= 4294967295) this.bufferBuilder.append(223), this.pack_uint32(r); else throw new Error("Invalid length"); for (var n in e) e.hasOwnProperty(n) && (this.pack(n), this.pack(e[n])) }; Q.prototype.pack_uint8 = function (e) { this.bufferBuilder.append(e) }; Q.prototype.pack_uint16 = function (e) { this.bufferBuilder.append(e >> 8), this.bufferBuilder.append(e & 255) }; Q.prototype.pack_uint32 = function (e) { var t = e & 4294967295; this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255) }; Q.prototype.pack_uint64 = function (e) { var t = e / Math.pow(2, 32), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; Q.prototype.pack_int8 = function (e) { this.bufferBuilder.append(e & 255) }; Q.prototype.pack_int16 = function (e) { this.bufferBuilder.append((e & 65280) >> 8), this.bufferBuilder.append(e & 255) }; Q.prototype.pack_int32 = function (e) { this.bufferBuilder.append(e >>> 24 & 255), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255) }; Q.prototype.pack_int64 = function (e) { var t = Math.floor(e / Math.pow(2, 32)), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; function Es(e) { var t = e.charCodeAt(0); return t <= 2047 ? "00" : t <= 65535 ? "000" : t <= 2097151 ? "0000" : t <= 67108863 ? "00000" : "000000" } function Rs(e) { return e.length > 600 ? new Blob([e]).size : e.replace(/[^\u0000-\u007F]/g, Es).length } let Wi = !0, Yi = !0; function pt(e, t, r) { const n = e.match(t); return n && n.length >= r && parseInt(n[r], 10) } function ot(e, t, r) { if (!e.RTCPeerConnection) return; const n = e.RTCPeerConnection.prototype, i = n.addEventListener; n.addEventListener = function (o, u) { if (o !== t) return i.apply(this, arguments); const s = c => { const f = r(c); f && (u.handleEvent ? u.handleEvent(f) : u(f)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(u, s), i.apply(this, [o, s]) }; const a = n.removeEventListener; n.removeEventListener = function (o, u) { if (o !== t || !this._eventMap || !this._eventMap[t]) return a.apply(this, arguments); if (!this._eventMap[t].has(u)) return a.apply(this, arguments); const s = this._eventMap[t].get(u); return this._eventMap[t].delete(u), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, a.apply(this, [o, s]) }, Object.defineProperty(n, "on" + t, { get() { return this["_on" + t] }, set(o) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), o && this.addEventListener(t, this["_on" + t] = o) }, enumerable: !0, configurable: !0 }) } function xs(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Wi = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function Ds(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Yi = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function Cn() { if (typeof window == "object") { if (Wi) return; typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments) } } function dr(e, t) { !Yi || console.warn(e + " is deprecated, please use " + t + " instead.") } function Os(e) { const t = { browser: null, version: null }; if (typeof e > "u" || !e.navigator) return t.browser = "Not a browser.", t; const { navigator: r } = e; if (r.mozGetUserMedia) t.browser = "firefox", t.version = pt(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || e.isSecureContext === !1 && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = pt(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (r.mediaDevices && r.userAgent.match(/Edge\/(\d+).(\d+)$/)) t.browser = "edge", t.version = pt(r.userAgent, /Edge\/(\d+).(\d+)$/, 2); else if (e.RTCPeerConnection && r.userAgent.match(/AppleWebKit\/(\d+)\./)) t.browser = "safari", t.version = pt(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype; else return t.browser = "Not a supported browser.", t; return t } function $n(e) { return Object.prototype.toString.call(e) === "[object Object]" } function qi(e) { return $n(e) ? Object.keys(e).reduce(function (t, r) { const n = $n(e[r]), i = n ? qi(e[r]) : e[r], a = n && !Object.keys(i).length; return i === void 0 || a ? t : Object.assign(t, { [r]: i }) }, {}) : e } function Hr(e, t, r) { !t || r.has(t.id) || (r.set(t.id, t), Object.keys(t).forEach(n => { n.endsWith("Id") ? Hr(e, e.get(t[n]), r) : n.endsWith("Ids") && t[n].forEach(i => { Hr(e, e.get(i), r) }) })) } function Gn(e, t, r) { const n = r ? "outbound-rtp" : "inbound-rtp", i = new Map; if (t === null) return i; const a = []; return e.forEach(o => { o.type === "track" && o.trackIdentifier === t.id && a.push(o) }), a.forEach(o => { e.forEach(u => { u.type === n && u.trackId === o.id && Hr(e, u, i) }) }), i } const Vn = Cn; function Xi(e, t) { const r = e && e.navigator; if (!r.mediaDevices) return; const n = function (u) { if (typeof u != "object" || u.mandatory || u.optional) return u; const s = {}; return Object.keys(u).forEach(c => { if (c === "require" || c === "advanced" || c === "mediaSource") return; const f = typeof u[c] == "object" ? u[c] : { ideal: u[c] }; f.exact !== void 0 && typeof f.exact == "number" && (f.min = f.max = f.exact); const l = function (p, v) { return p ? p + v.charAt(0).toUpperCase() + v.slice(1) : v === "deviceId" ? "sourceId" : v }; if (f.ideal !== void 0) { s.optional = s.optional || []; let p = {}; typeof f.ideal == "number" ? (p[l("min", c)] = f.ideal, s.optional.push(p), p = {}, p[l("max", c)] = f.ideal, s.optional.push(p)) : (p[l("", c)] = f.ideal, s.optional.push(p)) } f.exact !== void 0 && typeof f.exact != "number" ? (s.mandatory = s.mandatory || {}, s.mandatory[l("", c)] = f.exact) : ["min", "max"].forEach(p => { f[p] !== void 0 && (s.mandatory = s.mandatory || {}, s.mandatory[l(p, c)] = f[p]) }) }), u.advanced && (s.optional = (s.optional || []).concat(u.advanced)), s }, i = function (u, s) { if (t.version >= 61) return s(u); if (u = JSON.parse(JSON.stringify(u)), u && typeof u.audio == "object") { const c = function (f, l, p) { l in f && !(p in f) && (f[p] = f[l], delete f[l]) }; u = JSON.parse(JSON.stringify(u)), c(u.audio, "autoGainControl", "googAutoGainControl"), c(u.audio, "noiseSuppression", "googNoiseSuppression"), u.audio = n(u.audio) } if (u && typeof u.video == "object") { let c = u.video.facingMode; c = c && (typeof c == "object" ? c : { ideal: c }); const f = t.version < 66; if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && !(r.mediaDevices.getSupportedConstraints && r.mediaDevices.getSupportedConstraints().facingMode && !f)) { delete u.video.facingMode; let l; if (c.exact === "environment" || c.ideal === "environment" ? l = ["back", "rear"] : (c.exact === "user" || c.ideal === "user") && (l = ["front"]), l) return r.mediaDevices.enumerateDevices().then(p => { p = p.filter(d => d.kind === "videoinput"); let v = p.find(d => l.some(h => d.label.toLowerCase().includes(h))); return !v && p.length && l.includes("back") && (v = p[p.length - 1]), v && (u.video.deviceId = c.exact ? { exact: v.deviceId } : { ideal: v.deviceId }), u.video = n(u.video), Vn("chrome: " + JSON.stringify(u)), s(u) }) } u.video = n(u.video) } return Vn("chrome: " + JSON.stringify(u)), s(u) }, a = function (u) { return t.version >= 64 ? u : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[u.name] || u.name, message: u.message, constraint: u.constraint || u.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }, o = function (u, s, c) { i(u, f => { r.webkitGetUserMedia(f, s, l => { c && c(a(l)) }) }) }; if (r.getUserMedia = o.bind(r), r.mediaDevices.getUserMedia) { const u = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = function (s) { return i(s, c => u(c).then(f => { if (c.audio && !f.getAudioTracks().length || c.video && !f.getVideoTracks().length) throw f.getTracks().forEach(l => { l.stop() }), new DOMException("", "NotFoundError"); return f }, f => Promise.reject(a(f)))) } } } function ws(e, t) { if (!(e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices) && !!e.navigator.mediaDevices) { if (typeof t != "function") { console.error("shimGetDisplayMedia: getSourceId argument is not a function"); return } e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then(i => { const a = n.video && n.video.width, o = n.video && n.video.height, u = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: i, maxFrameRate: u || 3 } }, a && (n.video.mandatory.maxWidth = a), o && (n.video.mandatory.maxHeight = o), e.navigator.mediaDevices.getUserMedia(n) }) } } } function Qi(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function Zi(e) { if (typeof e == "object" && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(r) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = r) }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = n => { n.stream.addEventListener("addtrack", i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.track.id) : a = { track: i.track }; const o = new Event("track"); o.track = i.track, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }), n.stream.getTracks().forEach(i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.id) : a = { track: i }; const o = new Event("track"); o.track = i, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else ot(e, "track", t => (t.transceiver || Object.defineProperty(t, "transceiver", { value: { receiver: t.receiver } }), t)) } function ea(e) { if (typeof e == "object" && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { const t = function (i, a) { return { track: a, get dtmf() { return this._dtmf === void 0 && (a.kind === "audio" ? this._dtmf = i.createDTMFSender(a) : this._dtmf = null), this._dtmf }, _pc: i } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const i = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (u, s) { let c = i.apply(this, arguments); return c || (c = t(this, u), this._senders.push(c)), c }; const a = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (u) { a.apply(this, arguments); const s = this._senders.indexOf(u); s !== -1 && this._senders.splice(s, 1) } } const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (a) { this._senders = this._senders || [], r.apply(this, [a]), a.getTracks().forEach(o => { this._senders.push(t(this, o)) }) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (a) { this._senders = this._senders || [], n.apply(this, [a]), a.getTracks().forEach(o => { const u = this._senders.find(s => s.track === o); u && this._senders.splice(this._senders.indexOf(u), 1) }) } } else if (typeof e == "object" && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function ta(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [n, i, a] = arguments; if (arguments.length > 0 && typeof n == "function") return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof n != "function")) return t.apply(this, []); const o = function (s) { const c = {}; return s.result().forEach(l => { const p = { id: l.id, timestamp: l.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[l.type] || l.type }; l.names().forEach(v => { p[v] = l.stat(v) }), c[p.id] = p }), c }, u = function (s) { return new Map(Object.keys(s).map(c => [c, s[c]])) }; if (arguments.length >= 2) { const s = function (c) { i(u(o(c))) }; return t.apply(this, [s, n]) } return new Promise((s, c) => { t.apply(this, [function (f) { s(u(o(f))) }, c]) }).then(i, a) } } function ra(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!("getStats" in e.RTCRtpSender.prototype)) { const r = e.RTCPeerConnection.prototype.getSenders; r && (e.RTCPeerConnection.prototype.getSenders = function () { const a = r.apply(this, []); return a.forEach(o => o._pc = this), a }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const a = n.apply(this, arguments); return a._pc = this, a }), e.RTCRtpSender.prototype.getStats = function () { const a = this; return this._pc.getStats().then(o => Gn(o, a.track, !0)) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { const r = e.RTCPeerConnection.prototype.getReceivers; r && (e.RTCPeerConnection.prototype.getReceivers = function () { const i = r.apply(this, []); return i.forEach(a => a._pc = this), i }), ot(e, "track", n => (n.receiver._pc = n.srcElement, n)), e.RTCRtpReceiver.prototype.getStats = function () { const i = this; return this._pc.getStats().then(a => Gn(a, i.track, !1)) } } if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const n = arguments[0]; let i, a, o; return this.getSenders().forEach(u => { u.track === n && (i ? o = !0 : i = u) }), this.getReceivers().forEach(u => (u.track === n && (a ? o = !0 : a = u), u.track === n)), o || i && a ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : i ? i.getStats() : a ? a.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) } } function na(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(o => this._shimmedLocalStreams[o][0]) }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (o, u) { if (!u) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const s = t.apply(this, arguments); return this._shimmedLocalStreams[u.id] ? this._shimmedLocalStreams[u.id].indexOf(s) === -1 && this._shimmedLocalStreams[u.id].push(s) : this._shimmedLocalStreams[u.id] = [u, s], s }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (o) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o.getTracks().forEach(c => { if (this.getSenders().find(l => l.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError") }); const u = this.getSenders(); r.apply(this, arguments); const s = this.getSenders().filter(c => u.indexOf(c) === -1); this._shimmedLocalStreams[o.id] = [o].concat(s) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[o.id], n.apply(this, arguments) }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o && Object.keys(this._shimmedLocalStreams).forEach(u => { const s = this._shimmedLocalStreams[u].indexOf(o); s !== -1 && this._shimmedLocalStreams[u].splice(s, 1), this._shimmedLocalStreams[u].length === 1 && delete this._shimmedLocalStreams[u] }), i.apply(this, arguments) } } function ia(e, t) { if (!e.RTCPeerConnection) return; if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return na(e); const r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const f = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, f.map(l => this._reverseStreams[l.id]) }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (f) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, f.getTracks().forEach(l => { if (this.getSenders().find(v => v.track === l)) throw new DOMException("Track already exists.", "InvalidAccessError") }), !this._reverseStreams[f.id]) { const l = new e.MediaStream(f.getTracks()); this._streams[f.id] = l, this._reverseStreams[l.id] = f, f = l } n.apply(this, [f]) }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (f) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[f.id] || f]), delete this._reverseStreams[this._streams[f.id] ? this._streams[f.id].id : f.id], delete this._streams[f.id] }, e.RTCPeerConnection.prototype.addTrack = function (f, l) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const p = [].slice.call(arguments, 1); if (p.length !== 1 || !p[0].getTracks().find(h => h === f)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find(h => h.track === f)) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const d = this._streams[l.id]; if (d) d.addTrack(f), Promise.resolve().then(() => { this.dispatchEvent(new Event("negotiationneeded")) }); else { const h = new e.MediaStream([f]); this._streams[l.id] = h, this._reverseStreams[h.id] = l, this.addStream(h) } return this.getSenders().find(h => h.track === f) }; function a(c, f) { let l = f.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const v = c._reverseStreams[p], d = c._streams[v.id]; l = l.replace(new RegExp(d.id, "g"), v.id) }), new RTCSessionDescription({ type: f.type, sdp: l }) } function o(c, f) { let l = f.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const v = c._reverseStreams[p], d = c._streams[v.id]; l = l.replace(new RegExp(v.id, "g"), d.id) }), new RTCSessionDescription({ type: f.type, sdp: l }) } ["createOffer", "createAnswer"].forEach(function (c) { const f = e.RTCPeerConnection.prototype[c], l = { [c]() { const p = arguments; return arguments.length && typeof arguments[0] == "function" ? f.apply(this, [d => { const h = a(this, d); p[0].apply(null, [h]) }, d => { p[1] && p[1].apply(null, d) }, arguments[2]]) : f.apply(this, arguments).then(d => a(this, d)) } }; e.RTCPeerConnection.prototype[c] = l[c] }); const u = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return !arguments.length || !arguments[0].type ? u.apply(this, arguments) : (arguments[0] = o(this, arguments[0]), u.apply(this, arguments)) }; const s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { const c = s.get.apply(this); return c.type === "" ? c : a(this, c) } }), e.RTCPeerConnection.prototype.removeTrack = function (f) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!f._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (!(f._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; let p; Object.keys(this._streams).forEach(v => { this._streams[v].getTracks().find(h => f.track === h) && (p = this._streams[v]) }), p && (p.getTracks().length === 1 ? this.removeStream(this._reverseStreams[p.id]) : p.removeTrack(f.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function Wr(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), !!e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (r) { const n = e.RTCPeerConnection.prototype[r], i = { [r]() { return arguments[0] = new (r === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[r] = i[r] }) } function aa(e, t) { ot(e, "negotiationneeded", r => { const n = r.target; if (!((t.version < 72 || n.getConfiguration && n.getConfiguration().sdpSemantics === "plan-b") && n.signalingState !== "stable")) return r }) } const Jn = Object.freeze(Object.defineProperty({ __proto__: null, shimMediaStream: Qi, shimOnTrack: Zi, shimGetSendersWithDtmf: ea, shimGetStats: ta, shimSenderReceiverGetStats: ra, shimAddTrackRemoveTrackWithNative: na, shimAddTrackRemoveTrack: ia, shimPeerConnection: Wr, fixNegotiationNeeded: aa, shimGetUserMedia: Xi, shimGetDisplayMedia: ws }, Symbol.toStringTag, { value: "Module" })); function Is(e, t) { let r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(n => { if (n && (n.urls || n.url)) { let i = n.urls || n.url; n.url && !n.urls && dr("RTCIceServer.url", "RTCIceServer.urls"); const a = typeof i == "string"; return a && (i = [i]), i = i.filter(o => { if (o.indexOf("stun:") === 0) return !1; const u = o.startsWith("turn") && !o.startsWith("turn:[") && o.includes("transport=udp"); return u && !r ? (r = !0, !0) : u && !r }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } var Sn = { exports: {} }; (function (e) {
    var t = {}; t.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10) }, t.localCName = t.generateIdentifier(), t.splitLines = function (r) {
        return r.trim().split(`
`).map(function (n) { return n.trim() })
    }, t.splitSections = function (r) {
        var n = r.split(`
m=`); return n.map(function (i, a) {
            return (a > 0 ? "m=" + i : i).trim() + `\r
`})
    }, t.getDescription = function (r) { var n = t.splitSections(r); return n && n[0] }, t.getMediaSections = function (r) { var n = t.splitSections(r); return n.shift(), n }, t.matchPrefix = function (r, n) { return t.splitLines(r).filter(function (i) { return i.indexOf(n) === 0 }) }, t.parseCandidate = function (r) { var n; r.indexOf("a=candidate:") === 0 ? n = r.substring(12).split(" ") : n = r.substring(10).split(" "); for (var i = { foundation: n[0], component: parseInt(n[1], 10), protocol: n[2].toLowerCase(), priority: parseInt(n[3], 10), ip: n[4], address: n[4], port: parseInt(n[5], 10), type: n[7] }, a = 8; a < n.length; a += 2)switch (n[a]) { case "raddr": i.relatedAddress = n[a + 1]; break; case "rport": i.relatedPort = parseInt(n[a + 1], 10); break; case "tcptype": i.tcpType = n[a + 1]; break; case "ufrag": i.ufrag = n[a + 1], i.usernameFragment = n[a + 1]; break; default: i[n[a]] = n[a + 1]; break }return i }, t.writeCandidate = function (r) { var n = []; n.push(r.foundation), n.push(r.component), n.push(r.protocol.toUpperCase()), n.push(r.priority), n.push(r.address || r.ip), n.push(r.port); var i = r.type; return n.push("typ"), n.push(i), i !== "host" && r.relatedAddress && r.relatedPort && (n.push("raddr"), n.push(r.relatedAddress), n.push("rport"), n.push(r.relatedPort)), r.tcpType && r.protocol.toLowerCase() === "tcp" && (n.push("tcptype"), n.push(r.tcpType)), (r.usernameFragment || r.ufrag) && (n.push("ufrag"), n.push(r.usernameFragment || r.ufrag)), "candidate:" + n.join(" ") }, t.parseIceOptions = function (r) { return r.substr(14).split(" ") }, t.parseRtpMap = function (r) { var n = r.substr(9).split(" "), i = { payloadType: parseInt(n.shift(), 10) }; return n = n[0].split("/"), i.name = n[0], i.clockRate = parseInt(n[1], 10), i.channels = n.length === 3 ? parseInt(n[2], 10) : 1, i.numChannels = i.channels, i }, t.writeRtpMap = function (r) {
        var n = r.payloadType; r.preferredPayloadType !== void 0 && (n = r.preferredPayloadType); var i = r.channels || r.numChannels || 1; return "a=rtpmap:" + n + " " + r.name + "/" + r.clockRate + (i !== 1 ? "/" + i : "") + `\r
`}, t.parseExtmap = function (r) { var n = r.substr(9).split(" "); return { id: parseInt(n[0], 10), direction: n[0].indexOf("/") > 0 ? n[0].split("/")[1] : "sendrecv", uri: n[1] } }, t.writeExtmap = function (r) {
            return "a=extmap:" + (r.id || r.preferredId) + (r.direction && r.direction !== "sendrecv" ? "/" + r.direction : "") + " " + r.uri + `\r
`}, t.parseFmtp = function (r) { for (var n = {}, i, a = r.substr(r.indexOf(" ") + 1).split(";"), o = 0; o < a.length; o++)i = a[o].trim().split("="), n[i[0].trim()] = i[1]; return n }, t.writeFmtp = function (r) {
            var n = "", i = r.payloadType; if (r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.parameters && Object.keys(r.parameters).length) {
                var a = []; Object.keys(r.parameters).forEach(function (o) { r.parameters[o] ? a.push(o + "=" + r.parameters[o]) : a.push(o) }), n += "a=fmtp:" + i + " " + a.join(";") + `\r
`} return n
        }, t.parseRtcpFb = function (r) { var n = r.substr(r.indexOf(" ") + 1).split(" "); return { type: n.shift(), parameter: n.join(" ") } }, t.writeRtcpFb = function (r) {
            var n = "", i = r.payloadType; return r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.rtcpFeedback && r.rtcpFeedback.length && r.rtcpFeedback.forEach(function (a) {
                n += "a=rtcp-fb:" + i + " " + a.type + (a.parameter && a.parameter.length ? " " + a.parameter : "") + `\r
`}), n
        }, t.parseSsrcMedia = function (r) { var n = r.indexOf(" "), i = { ssrc: parseInt(r.substr(7, n - 7), 10) }, a = r.indexOf(":", n); return a > -1 ? (i.attribute = r.substr(n + 1, a - n - 1), i.value = r.substr(a + 1)) : i.attribute = r.substr(n + 1), i }, t.parseSsrcGroup = function (r) { var n = r.substr(13).split(" "); return { semantics: n.shift(), ssrcs: n.map(function (i) { return parseInt(i, 10) }) } }, t.getMid = function (r) { var n = t.matchPrefix(r, "a=mid:")[0]; if (n) return n.substr(6) }, t.parseFingerprint = function (r) { var n = r.substr(14).split(" "); return { algorithm: n[0].toLowerCase(), value: n[1] } }, t.getDtlsParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=fingerprint:"); return { role: "auto", fingerprints: i.map(t.parseFingerprint) } }, t.writeDtlsParameters = function (r, n) {
            var i = "a=setup:" + n + `\r
`; return r.fingerprints.forEach(function (a) {
                i += "a=fingerprint:" + a.algorithm + " " + a.value + `\r
`}), i
        }, t.parseCryptoLine = function (r) { var n = r.substr(9).split(" "); return { tag: parseInt(n[0], 10), cryptoSuite: n[1], keyParams: n[2], sessionParams: n.slice(3) } }, t.writeCryptoLine = function (r) {
            return "a=crypto:" + r.tag + " " + r.cryptoSuite + " " + (typeof r.keyParams == "object" ? t.writeCryptoKeyParams(r.keyParams) : r.keyParams) + (r.sessionParams ? " " + r.sessionParams.join(" ") : "") + `\r
`}, t.parseCryptoKeyParams = function (r) { if (r.indexOf("inline:") !== 0) return null; var n = r.substr(7).split("|"); return { keyMethod: "inline", keySalt: n[0], lifeTime: n[1], mkiValue: n[2] ? n[2].split(":")[0] : void 0, mkiLength: n[2] ? n[2].split(":")[1] : void 0 } }, t.writeCryptoKeyParams = function (r) { return r.keyMethod + ":" + r.keySalt + (r.lifeTime ? "|" + r.lifeTime : "") + (r.mkiValue && r.mkiLength ? "|" + r.mkiValue + ":" + r.mkiLength : "") }, t.getCryptoParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=crypto:"); return i.map(t.parseCryptoLine) }, t.getIceParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=ice-ufrag:")[0], a = t.matchPrefix(r + n, "a=ice-pwd:")[0]; return i && a ? { usernameFragment: i.substr(12), password: a.substr(10) } : null }, t.writeIceParameters = function (r) {
            return "a=ice-ufrag:" + r.usernameFragment + `\r
a=ice-pwd:`+ r.password + `\r
`}, t.parseRtpParameters = function (r) { for (var n = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i = t.splitLines(r), a = i[0].split(" "), o = 3; o < a.length; o++) { var u = a[o], s = t.matchPrefix(r, "a=rtpmap:" + u + " ")[0]; if (s) { var c = t.parseRtpMap(s), f = t.matchPrefix(r, "a=fmtp:" + u + " "); switch (c.parameters = f.length ? t.parseFmtp(f[0]) : {}, c.rtcpFeedback = t.matchPrefix(r, "a=rtcp-fb:" + u + " ").map(t.parseRtcpFb), n.codecs.push(c), c.name.toUpperCase()) { case "RED": case "ULPFEC": n.fecMechanisms.push(c.name.toUpperCase()); break } } } return t.matchPrefix(r, "a=extmap:").forEach(function (l) { n.headerExtensions.push(t.parseExtmap(l)) }), n }, t.writeRtpDescription = function (r, n) {
            var i = ""; i += "m=" + r + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map(function (o) { return o.preferredPayloadType !== void 0 ? o.preferredPayloadType : o.payloadType }).join(" ") + `\r
`, i += `c=IN IP4 0.0.0.0\r
`, i += `a=rtcp:9 IN IP4 0.0.0.0\r
`, n.codecs.forEach(function (o) { i += t.writeRtpMap(o), i += t.writeFmtp(o), i += t.writeRtcpFb(o) }); var a = 0; return n.codecs.forEach(function (o) { o.maxptime > a && (a = o.maxptime) }), a > 0 && (i += "a=maxptime:" + a + `\r
`), i += `a=rtcp-mux\r
`, n.headerExtensions && n.headerExtensions.forEach(function (o) { i += t.writeExtmap(o) }), i
        }, t.parseRtpEncodingParameters = function (r) { var n = [], i = t.parseRtpParameters(r), a = i.fecMechanisms.indexOf("RED") !== -1, o = i.fecMechanisms.indexOf("ULPFEC") !== -1, u = t.matchPrefix(r, "a=ssrc:").map(function (p) { return t.parseSsrcMedia(p) }).filter(function (p) { return p.attribute === "cname" }), s = u.length > 0 && u[0].ssrc, c, f = t.matchPrefix(r, "a=ssrc-group:FID").map(function (p) { var v = p.substr(17).split(" "); return v.map(function (d) { return parseInt(d, 10) }) }); f.length > 0 && f[0].length > 1 && f[0][0] === s && (c = f[0][1]), i.codecs.forEach(function (p) { if (p.name.toUpperCase() === "RTX" && p.parameters.apt) { var v = { ssrc: s, codecPayloadType: parseInt(p.parameters.apt, 10) }; s && c && (v.rtx = { ssrc: c }), n.push(v), a && (v = JSON.parse(JSON.stringify(v)), v.fec = { ssrc: s, mechanism: o ? "red+ulpfec" : "red" }, n.push(v)) } }), n.length === 0 && s && n.push({ ssrc: s }); var l = t.matchPrefix(r, "b="); return l.length && (l[0].indexOf("b=TIAS:") === 0 ? l = parseInt(l[0].substr(7), 10) : l[0].indexOf("b=AS:") === 0 ? l = parseInt(l[0].substr(5), 10) * 1e3 * .95 - 50 * 40 * 8 : l = void 0, n.forEach(function (p) { p.maxBitrate = l })), n }, t.parseRtcpParameters = function (r) { var n = {}, i = t.matchPrefix(r, "a=ssrc:").map(function (u) { return t.parseSsrcMedia(u) }).filter(function (u) { return u.attribute === "cname" })[0]; i && (n.cname = i.value, n.ssrc = i.ssrc); var a = t.matchPrefix(r, "a=rtcp-rsize"); n.reducedSize = a.length > 0, n.compound = a.length === 0; var o = t.matchPrefix(r, "a=rtcp-mux"); return n.mux = o.length > 0, n }, t.parseMsid = function (r) { var n, i = t.matchPrefix(r, "a=msid:"); if (i.length === 1) return n = i[0].substr(7).split(" "), { stream: n[0], track: n[1] }; var a = t.matchPrefix(r, "a=ssrc:").map(function (o) { return t.parseSsrcMedia(o) }).filter(function (o) { return o.attribute === "msid" }); if (a.length > 0) return n = a[0].value.split(" "), { stream: n[0], track: n[1] } }, t.parseSctpDescription = function (r) { var n = t.parseMLine(r), i = t.matchPrefix(r, "a=max-message-size:"), a; i.length > 0 && (a = parseInt(i[0].substr(19), 10)), isNaN(a) && (a = 65536); var o = t.matchPrefix(r, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: n.fmt, maxMessageSize: a }; var u = t.matchPrefix(r, "a=sctpmap:"); if (u.length > 0) { var s = t.matchPrefix(r, "a=sctpmap:")[0].substr(10).split(" "); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: a } } }, t.writeSctpDescription = function (r, n) {
            var i = []; return r.protocol !== "DTLS/SCTP" ? i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + n.port + `\r
`] : i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + n.port + " " + n.protocol + ` 65535\r
`], n.maxMessageSize !== void 0 && i.push("a=max-message-size:" + n.maxMessageSize + `\r
`), i.join("")
        }, t.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, t.writeSessionBoilerplate = function (r, n, i) {
            var a, o = n !== void 0 ? n : 2; r ? a = r : a = t.generateSessionId(); var u = i || "thisisadapterortc"; return `v=0\r
o=`+ u + " " + a + " " + o + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`}, t.writeMediaSection = function (r, n, i, a) {
            var o = t.writeRtpDescription(r.kind, n); if (o += t.writeIceParameters(r.iceGatherer.getLocalParameters()), o += t.writeDtlsParameters(r.dtlsTransport.getLocalParameters(), i === "offer" ? "actpass" : "active"), o += "a=mid:" + r.mid + `\r
`, r.direction ? o += "a=" + r.direction + `\r
`: r.rtpSender && r.rtpReceiver ? o += `a=sendrecv\r
`: r.rtpSender ? o += `a=sendonly\r
`: r.rtpReceiver ? o += `a=recvonly\r
`: o += `a=inactive\r
`, r.rtpSender) {
                var u = "msid:" + a.id + " " + r.rtpSender.track.id + `\r
`; o += "a=" + u, o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " " + u, r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " " + u, o += "a=ssrc-group:FID " + r.sendEncodingParameters[0].ssrc + " " + r.sendEncodingParameters[0].rtx.ssrc + `\r
`)
            } return o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " cname:" + t.localCName + `\r
`, r.rtpSender && r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " cname:" + t.localCName + `\r
`), o
        }, t.getDirection = function (r, n) { for (var i = t.splitLines(r), a = 0; a < i.length; a++)switch (i[a]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return i[a].substr(2) }return n ? t.getDirection(n) : "sendrecv" }, t.getKind = function (r) { var n = t.splitLines(r), i = n[0].split(" "); return i[0].substr(2) }, t.isRejected = function (r) { return r.split(" ", 2)[1] === "0" }, t.parseMLine = function (r) { var n = t.splitLines(r), i = n[0].substr(2).split(" "); return { kind: i[0], port: parseInt(i[1], 10), protocol: i[2], fmt: i.slice(3).join(" ") } }, t.parseOLine = function (r) { var n = t.matchPrefix(r, "o=")[0], i = n.substr(2).split(" "); return { username: i[0], sessionId: i[1], sessionVersion: parseInt(i[2], 10), netType: i[3], addressType: i[4], address: i[5] } }, t.isValidSDP = function (r) { if (typeof r != "string" || r.length === 0) return !1; for (var n = t.splitLines(r), i = 0; i < n.length; i++)if (n[i].length < 2 || n[i].charAt(1) !== "=") return !1; return !0 }, e.exports = t
})(Sn); const Wt = Sn.exports; var O = Sn.exports; function As(e) { return { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type } function Hn(e, t, r, n, i) {
    var a = O.writeRtpDescription(e.kind, t); if (a += O.writeIceParameters(e.iceGatherer.getLocalParameters()), a += O.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === "offer" ? "actpass" : i || "active"), a += "a=mid:" + e.mid + `\r
`, e.rtpSender && e.rtpReceiver ? a += `a=sendrecv\r
`: e.rtpSender ? a += `a=sendonly\r
`: e.rtpReceiver ? a += `a=recvonly\r
`: a += `a=inactive\r
`, e.rtpSender) {
        var o = e.rtpSender._initialTrackId || e.rtpSender.track.id; e.rtpSender._initialTrackId = o; var u = "msid:" + (n ? n.id : "-") + " " + o + `\r
`; a += "a=" + u, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + u, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + u, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + `\r
`)
    } return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + O.localCName + `\r
`, e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + O.localCName + `\r
`), a
} function Ms(e, t) { var r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(function (n) { if (n && (n.urls || n.url)) { var i = n.urls || n.url; n.url && !n.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead."); var a = typeof i == "string"; return a && (i = [i]), i = i.filter(function (o) { var u = o.indexOf("turn:") === 0 && o.indexOf("transport=udp") !== -1 && o.indexOf("turn:[") === -1 && !r; return u ? (r = !0, !0) : o.indexOf("stun:") === 0 && t >= 14393 && o.indexOf("?transport=udp") === -1 }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } function Lt(e, t) { var r = { codecs: [], headerExtensions: [], fecMechanisms: [] }, n = function (a, o) { a = parseInt(a, 10); for (var u = 0; u < o.length; u++)if (o[u].payloadType === a || o[u].preferredPayloadType === a) return o[u] }, i = function (a, o, u, s) { var c = n(a.parameters.apt, u), f = n(o.parameters.apt, s); return c && f && c.name.toLowerCase() === f.name.toLowerCase() }; return e.codecs.forEach(function (a) { for (var o = 0; o < t.codecs.length; o++) { var u = t.codecs[o]; if (a.name.toLowerCase() === u.name.toLowerCase() && a.clockRate === u.clockRate) { if (a.name.toLowerCase() === "rtx" && a.parameters && u.parameters.apt && !i(a, u, e.codecs, t.codecs)) continue; u = JSON.parse(JSON.stringify(u)), u.numChannels = Math.min(a.numChannels, u.numChannels), r.codecs.push(u), u.rtcpFeedback = u.rtcpFeedback.filter(function (s) { for (var c = 0; c < a.rtcpFeedback.length; c++)if (a.rtcpFeedback[c].type === s.type && a.rtcpFeedback[c].parameter === s.parameter) return !0; return !1 }); break } } }), e.headerExtensions.forEach(function (a) { for (var o = 0; o < t.headerExtensions.length; o++) { var u = t.headerExtensions[o]; if (a.uri === u.uri) { r.headerExtensions.push(u); break } } }), r } function Wn(e, t, r) { return { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t][e].indexOf(r) !== -1 } function Cr(e, t) { var r = e.getRemoteCandidates().find(function (n) { return t.foundation === n.foundation && t.ip === n.ip && t.port === n.port && t.priority === n.priority && t.protocol === n.protocol && t.type === n.type }); return r || e.addRemoteCandidate(t), !r } function ee(e, t) { var r = new Error(t); return r.name = e, r.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e], r } var Bs = function (e, t) {
    function r(s, c) { c.addTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", { track: s })) } function n(s, c) { c.removeTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", { track: s })) } function i(s, c, f, l) { var p = new Event("track"); p.track = c, p.receiver = f, p.transceiver = { receiver: f }, p.streams = l, e.setTimeout(function () { s._dispatchEvent("track", p) }) } var a = function (s) { var c = this, f = document.createDocumentFragment(); if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (p) { c[p] = f[p].bind(f) }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", s = JSON.parse(JSON.stringify(s || {})), this.usingBundle = s.bundlePolicy === "max-bundle", s.rtcpMuxPolicy === "negotiate") throw ee("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported"); switch (s.rtcpMuxPolicy || (s.rtcpMuxPolicy = "require"), s.iceTransportPolicy) { case "all": case "relay": break; default: s.iceTransportPolicy = "all"; break }switch (s.bundlePolicy) { case "balanced": case "max-compat": case "max-bundle": break; default: s.bundlePolicy = "balanced"; break }if (s.iceServers = Ms(s.iceServers || [], t), this._iceGatherers = [], s.iceCandidatePoolSize) for (var l = s.iceCandidatePoolSize; l > 0; l--)this._iceGatherers.push(new e.RTCIceGatherer({ iceServers: s.iceServers, gatherPolicy: s.iceTransportPolicy })); else s.iceCandidatePoolSize = 0; this._config = s, this.transceivers = [], this._sdpSessionId = O.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1 }; Object.defineProperty(a.prototype, "localDescription", { configurable: !0, get: function () { return this._localDescription } }), Object.defineProperty(a.prototype, "remoteDescription", { configurable: !0, get: function () { return this._remoteDescription } }), a.prototype.onicecandidate = null, a.prototype.onaddstream = null, a.prototype.ontrack = null, a.prototype.onremovestream = null, a.prototype.onsignalingstatechange = null, a.prototype.oniceconnectionstatechange = null, a.prototype.onconnectionstatechange = null, a.prototype.onicegatheringstatechange = null, a.prototype.onnegotiationneeded = null, a.prototype.ondatachannel = null, a.prototype._dispatchEvent = function (s, c) { this._isClosed || (this.dispatchEvent(c), typeof this["on" + s] == "function" && this["on" + s](c)) }, a.prototype._emitGatheringStateChange = function () { var s = new Event("icegatheringstatechange"); this._dispatchEvent("icegatheringstatechange", s) }, a.prototype.getConfiguration = function () { return this._config }, a.prototype.getLocalStreams = function () { return this.localStreams }, a.prototype.getRemoteStreams = function () { return this.remoteStreams }, a.prototype._createTransceiver = function (s, c) { var f = this.transceivers.length > 0, l = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: s, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: !0 }; if (this.usingBundle && f) l.iceTransport = this.transceivers[0].iceTransport, l.dtlsTransport = this.transceivers[0].dtlsTransport; else { var p = this._createIceAndDtlsTransports(); l.iceTransport = p.iceTransport, l.dtlsTransport = p.dtlsTransport } return c || this.transceivers.push(l), l }, a.prototype.addTrack = function (s, c) { if (this._isClosed) throw ee("InvalidStateError", "Attempted to call addTrack on a closed peerconnection."); var f = this.transceivers.find(function (v) { return v.track === s }); if (f) throw ee("InvalidAccessError", "Track already exists."); for (var l, p = 0; p < this.transceivers.length; p++)!this.transceivers[p].track && this.transceivers[p].kind === s.kind && (l = this.transceivers[p]); return l || (l = this._createTransceiver(s.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(c) === -1 && this.localStreams.push(c), l.track = s, l.stream = c, l.rtpSender = new e.RTCRtpSender(s, l.dtlsTransport), l.rtpSender }, a.prototype.addStream = function (s) { var c = this; if (t >= 15025) s.getTracks().forEach(function (l) { c.addTrack(l, s) }); else { var f = s.clone(); s.getTracks().forEach(function (l, p) { var v = f.getTracks()[p]; l.addEventListener("enabled", function (d) { v.enabled = d.enabled }) }), f.getTracks().forEach(function (l) { c.addTrack(l, f) }) } }, a.prototype.removeTrack = function (s) { if (this._isClosed) throw ee("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection."); if (!(s instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender."); var c = this.transceivers.find(function (p) { return p.rtpSender === s }); if (!c) throw ee("InvalidAccessError", "Sender was not created by this connection."); var f = c.stream; c.rtpSender.stop(), c.rtpSender = null, c.track = null, c.stream = null; var l = this.transceivers.map(function (p) { return p.stream }); l.indexOf(f) === -1 && this.localStreams.indexOf(f) > -1 && this.localStreams.splice(this.localStreams.indexOf(f), 1), this._maybeFireNegotiationNeeded() }, a.prototype.removeStream = function (s) { var c = this; s.getTracks().forEach(function (f) { var l = c.getSenders().find(function (p) { return p.track === f }); l && c.removeTrack(l) }) }, a.prototype.getSenders = function () { return this.transceivers.filter(function (s) { return !!s.rtpSender }).map(function (s) { return s.rtpSender }) }, a.prototype.getReceivers = function () { return this.transceivers.filter(function (s) { return !!s.rtpReceiver }).map(function (s) { return s.rtpReceiver }) }, a.prototype._createIceGatherer = function (s, c) { var f = this; if (c && s > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var l = new e.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(l, "state", { value: "new", writable: !0 }), this.transceivers[s].bufferedCandidateEvents = [], this.transceivers[s].bufferCandidates = function (p) { var v = !p.candidate || Object.keys(p.candidate).length === 0; l.state = v ? "completed" : "gathering", f.transceivers[s].bufferedCandidateEvents !== null && f.transceivers[s].bufferedCandidateEvents.push(p) }, l.addEventListener("localcandidate", this.transceivers[s].bufferCandidates), l }, a.prototype._gather = function (s, c) {
        var f = this, l = this.transceivers[c].iceGatherer; if (!l.onlocalcandidate) {
            var p = this.transceivers[c].bufferedCandidateEvents; this.transceivers[c].bufferedCandidateEvents = null, l.removeEventListener("localcandidate", this.transceivers[c].bufferCandidates), l.onlocalcandidate = function (v) {
                if (!(f.usingBundle && c > 0)) {
                    var d = new Event("icecandidate"); d.candidate = { sdpMid: s, sdpMLineIndex: c }; var h = v.candidate, _ = !h || Object.keys(h).length === 0; if (_) (l.state === "new" || l.state === "gathering") && (l.state = "completed"); else { l.state === "new" && (l.state = "gathering"), h.component = 1, h.ufrag = l.getLocalParameters().usernameFragment; var m = O.writeCandidate(h); d.candidate = Object.assign(d.candidate, O.parseCandidate(m)), d.candidate.candidate = m, d.candidate.toJSON = function () { return { candidate: d.candidate.candidate, sdpMid: d.candidate.sdpMid, sdpMLineIndex: d.candidate.sdpMLineIndex, usernameFragment: d.candidate.usernameFragment } } } var g = O.getMediaSections(f._localDescription.sdp); _ ? g[d.candidate.sdpMLineIndex] += `a=end-of-candidates\r
`: g[d.candidate.sdpMLineIndex] += "a=" + d.candidate.candidate + `\r
`, f._localDescription.sdp = O.getDescription(f._localDescription.sdp) + g.join(""); var C = f.transceivers.every(function (b) { return b.iceGatherer && b.iceGatherer.state === "completed" }); f.iceGatheringState !== "gathering" && (f.iceGatheringState = "gathering", f._emitGatheringStateChange()), _ || f._dispatchEvent("icecandidate", d), C && (f._dispatchEvent("icecandidate", new Event("icecandidate")), f.iceGatheringState = "complete", f._emitGatheringStateChange())
                }
            }, e.setTimeout(function () { p.forEach(function (v) { l.onlocalcandidate(v) }) }, 0)
        }
    }, a.prototype._createIceAndDtlsTransports = function () { var s = this, c = new e.RTCIceTransport(null); c.onicestatechange = function () { s._updateIceConnectionState(), s._updateConnectionState() }; var f = new e.RTCDtlsTransport(c); return f.ondtlsstatechange = function () { s._updateConnectionState() }, f.onerror = function () { Object.defineProperty(f, "state", { value: "failed", writable: !0 }), s._updateConnectionState() }, { iceTransport: c, dtlsTransport: f } }, a.prototype._disposeIceAndDtlsTransports = function (s) { var c = this.transceivers[s].iceGatherer; c && (delete c.onlocalcandidate, delete this.transceivers[s].iceGatherer); var f = this.transceivers[s].iceTransport; f && (delete f.onicestatechange, delete this.transceivers[s].iceTransport); var l = this.transceivers[s].dtlsTransport; l && (delete l.ondtlsstatechange, delete l.onerror, delete this.transceivers[s].dtlsTransport) }, a.prototype._transceive = function (s, c, f) { var l = Lt(s.localCapabilities, s.remoteCapabilities); c && s.rtpSender && (l.encodings = s.sendEncodingParameters, l.rtcp = { cname: O.localCName, compound: s.rtcpParameters.compound }, s.recvEncodingParameters.length && (l.rtcp.ssrc = s.recvEncodingParameters[0].ssrc), s.rtpSender.send(l)), f && s.rtpReceiver && l.codecs.length > 0 && (s.kind === "video" && s.recvEncodingParameters && t < 15019 && s.recvEncodingParameters.forEach(function (p) { delete p.rtx }), s.recvEncodingParameters.length ? l.encodings = s.recvEncodingParameters : l.encodings = [{}], l.rtcp = { compound: s.rtcpParameters.compound }, s.rtcpParameters.cname && (l.rtcp.cname = s.rtcpParameters.cname), s.sendEncodingParameters.length && (l.rtcp.ssrc = s.sendEncodingParameters[0].ssrc), s.rtpReceiver.receive(l)) }, a.prototype.setLocalDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(ee("TypeError", 'Unsupported type "' + s.type + '"')); if (!Wn("setLocalDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(ee("InvalidStateError", "Can not set local " + s.type + " in state " + c.signalingState)); var f, l; if (s.type === "offer") f = O.splitSections(s.sdp), l = f.shift(), f.forEach(function (v, d) { var h = O.parseRtpParameters(v); c.transceivers[d].localCapabilities = h }), c.transceivers.forEach(function (v, d) { c._gather(v.mid, d) }); else if (s.type === "answer") { f = O.splitSections(c._remoteDescription.sdp), l = f.shift(); var p = O.matchPrefix(l, "a=ice-lite").length > 0; f.forEach(function (v, d) { var h = c.transceivers[d], _ = h.iceGatherer, m = h.iceTransport, g = h.dtlsTransport, C = h.localCapabilities, b = h.remoteCapabilities, y = O.isRejected(v) && O.matchPrefix(v, "a=bundle-only").length === 0; if (!y && !h.rejected) { var S = O.getIceParameters(v, l), P = O.getDtlsParameters(v, l); p && (P.role = "server"), (!c.usingBundle || d === 0) && (c._gather(h.mid, d), m.state === "new" && m.start(_, S, p ? "controlling" : "controlled"), g.state === "new" && g.start(P)); var T = Lt(C, b); c._transceive(h, T.codecs.length > 0, !1) } }) } return c._localDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-local-offer") : c._updateSignalingState("stable"), Promise.resolve() }, a.prototype.setRemoteDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(ee("TypeError", 'Unsupported type "' + s.type + '"')); if (!Wn("setRemoteDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(ee("InvalidStateError", "Can not set remote " + s.type + " in state " + c.signalingState)); var f = {}; c.remoteStreams.forEach(function (m) { f[m.id] = m }); var l = [], p = O.splitSections(s.sdp), v = p.shift(), d = O.matchPrefix(v, "a=ice-lite").length > 0, h = O.matchPrefix(v, "a=group:BUNDLE ").length > 0; c.usingBundle = h; var _ = O.matchPrefix(v, "a=ice-options:")[0]; return _ ? c.canTrickleIceCandidates = _.substr(14).split(" ").indexOf("trickle") >= 0 : c.canTrickleIceCandidates = !1, p.forEach(function (m, g) { var C = O.splitLines(m), b = O.getKind(m), y = O.isRejected(m) && O.matchPrefix(m, "a=bundle-only").length === 0, S = C[0].substr(2).split(" ")[2], P = O.getDirection(m, v), T = O.parseMsid(m), D = O.getMid(m) || O.generateIdentifier(); if (y || b === "application" && (S === "DTLS/SCTP" || S === "UDP/DTLS/SCTP")) { c.transceivers[g] = { mid: D, kind: b, protocol: S, rejected: !0 }; return } !y && c.transceivers[g] && c.transceivers[g].rejected && (c.transceivers[g] = c._createTransceiver(b, !0)); var k, j, B, M, N, I, Z, Y, H, fe = O.parseRtpParameters(m), ie, he; y || (ie = O.getIceParameters(m, v), he = O.getDtlsParameters(m, v), he.role = "client"), Z = O.parseRtpEncodingParameters(m); var le = O.parseRtcpParameters(m), we = O.matchPrefix(m, "a=end-of-candidates", v).length > 0, W = O.matchPrefix(m, "a=candidate:").map(function (ce) { return O.parseCandidate(ce) }).filter(function (ce) { return ce.component === 1 }); if ((s.type === "offer" || s.type === "answer") && !y && h && g > 0 && c.transceivers[g] && (c._disposeIceAndDtlsTransports(g), c.transceivers[g].iceGatherer = c.transceivers[0].iceGatherer, c.transceivers[g].iceTransport = c.transceivers[0].iceTransport, c.transceivers[g].dtlsTransport = c.transceivers[0].dtlsTransport, c.transceivers[g].rtpSender && c.transceivers[g].rtpSender.setTransport(c.transceivers[0].dtlsTransport), c.transceivers[g].rtpReceiver && c.transceivers[g].rtpReceiver.setTransport(c.transceivers[0].dtlsTransport)), s.type === "offer" && !y) { k = c.transceivers[g] || c._createTransceiver(b), k.mid = D, k.iceGatherer || (k.iceGatherer = c._createIceGatherer(g, h)), W.length && k.iceTransport.state === "new" && (we && (!h || g === 0) ? k.iceTransport.setRemoteCandidates(W) : W.forEach(function (ce) { Cr(k.iceTransport, ce) })), Y = e.RTCRtpReceiver.getCapabilities(b), t < 15019 && (Y.codecs = Y.codecs.filter(function (ce) { return ce.name !== "rtx" })), I = k.sendEncodingParameters || [{ ssrc: (2 * g + 2) * 1001 }]; var Ie = !1; if (P === "sendrecv" || P === "sendonly") { if (Ie = !k.rtpReceiver, N = k.rtpReceiver || new e.RTCRtpReceiver(k.dtlsTransport, b), Ie) { var Ae; H = N.track, T && T.stream === "-" || (T ? (f[T.stream] || (f[T.stream] = new e.MediaStream, Object.defineProperty(f[T.stream], "id", { get: function () { return T.stream } })), Object.defineProperty(H, "id", { get: function () { return T.track } }), Ae = f[T.stream]) : (f.default || (f.default = new e.MediaStream), Ae = f.default)), Ae && (r(H, Ae), k.associatedRemoteMediaStreams.push(Ae)), l.push([H, N, Ae]) } } else k.rtpReceiver && k.rtpReceiver.track && (k.associatedRemoteMediaStreams.forEach(function (ce) { var En = ce.getTracks().find(function (Ba) { return Ba.id === k.rtpReceiver.track.id }); En && n(En, ce) }), k.associatedRemoteMediaStreams = []); k.localCapabilities = Y, k.remoteCapabilities = fe, k.rtpReceiver = N, k.rtcpParameters = le, k.sendEncodingParameters = I, k.recvEncodingParameters = Z, c._transceive(c.transceivers[g], !1, Ie) } else if (s.type === "answer" && !y) { k = c.transceivers[g], j = k.iceGatherer, B = k.iceTransport, M = k.dtlsTransport, N = k.rtpReceiver, I = k.sendEncodingParameters, Y = k.localCapabilities, c.transceivers[g].recvEncodingParameters = Z, c.transceivers[g].remoteCapabilities = fe, c.transceivers[g].rtcpParameters = le, W.length && B.state === "new" && ((d || we) && (!h || g === 0) ? B.setRemoteCandidates(W) : W.forEach(function (ce) { Cr(k.iceTransport, ce) })), (!h || g === 0) && (B.state === "new" && B.start(j, ie, "controlling"), M.state === "new" && M.start(he)); var Aa = Lt(k.localCapabilities, k.remoteCapabilities), Ma = Aa.codecs.filter(function (ce) { return ce.name.toLowerCase() === "rtx" }).length; !Ma && k.sendEncodingParameters[0].rtx && delete k.sendEncodingParameters[0].rtx, c._transceive(k, P === "sendrecv" || P === "recvonly", P === "sendrecv" || P === "sendonly"), N && (P === "sendrecv" || P === "sendonly") ? (H = N.track, T ? (f[T.stream] || (f[T.stream] = new e.MediaStream), r(H, f[T.stream]), l.push([H, N, f[T.stream]])) : (f.default || (f.default = new e.MediaStream), r(H, f.default), l.push([H, N, f.default]))) : delete k.rtpReceiver } }), c._dtlsRole === void 0 && (c._dtlsRole = s.type === "offer" ? "active" : "passive"), c._remoteDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-remote-offer") : c._updateSignalingState("stable"), Object.keys(f).forEach(function (m) { var g = f[m]; if (g.getTracks().length) { if (c.remoteStreams.indexOf(g) === -1) { c.remoteStreams.push(g); var C = new Event("addstream"); C.stream = g, e.setTimeout(function () { c._dispatchEvent("addstream", C) }) } l.forEach(function (b) { var y = b[0], S = b[1]; g.id === b[2].id && i(c, y, S, [g]) }) } }), l.forEach(function (m) { m[2] || i(c, m[0], m[1], []) }), e.setTimeout(function () { !(c && c.transceivers) || c.transceivers.forEach(function (m) { m.iceTransport && m.iceTransport.state === "new" && m.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), m.iceTransport.addRemoteCandidate({})) }) }, 4e3), Promise.resolve() }, a.prototype.close = function () { this.transceivers.forEach(function (s) { s.iceTransport && s.iceTransport.stop(), s.dtlsTransport && s.dtlsTransport.stop(), s.rtpSender && s.rtpSender.stop(), s.rtpReceiver && s.rtpReceiver.stop() }), this._isClosed = !0, this._updateSignalingState("closed") }, a.prototype._updateSignalingState = function (s) { this.signalingState = s; var c = new Event("signalingstatechange"); this._dispatchEvent("signalingstatechange", c) }, a.prototype._maybeFireNegotiationNeeded = function () { var s = this; this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, e.setTimeout(function () { if (s.needNegotiation) { s.needNegotiation = !1; var c = new Event("negotiationneeded"); s._dispatchEvent("negotiationneeded", c) } }, 0)) }, a.prototype._updateIceConnectionState = function () { var s, c = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (l) { l.iceTransport && !l.rejected && c[l.iceTransport.state]++ }), s = "new", c.failed > 0 ? s = "failed" : c.checking > 0 ? s = "checking" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 ? s = "connected" : c.completed > 0 && (s = "completed"), s !== this.iceConnectionState) { this.iceConnectionState = s; var f = new Event("iceconnectionstatechange"); this._dispatchEvent("iceconnectionstatechange", f) } }, a.prototype._updateConnectionState = function () { var s, c = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (l) { l.iceTransport && l.dtlsTransport && !l.rejected && (c[l.iceTransport.state]++, c[l.dtlsTransport.state]++) }), c.connected += c.completed, s = "new", c.failed > 0 ? s = "failed" : c.connecting > 0 ? s = "connecting" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 && (s = "connected"), s !== this.connectionState) { this.connectionState = s; var f = new Event("connectionstatechange"); this._dispatchEvent("connectionstatechange", f) } }, a.prototype.createOffer = function () {
        var s = this; if (s._isClosed) return Promise.reject(ee("InvalidStateError", "Can not call createOffer after close")); var c = s.transceivers.filter(function (d) { return d.kind === "audio" }).length, f = s.transceivers.filter(function (d) { return d.kind === "video" }).length, l = arguments[0]; if (l) { if (l.mandatory || l.optional) throw new TypeError("Legacy mandatory/optional constraints not supported."); l.offerToReceiveAudio !== void 0 && (l.offerToReceiveAudio === !0 ? c = 1 : l.offerToReceiveAudio === !1 ? c = 0 : c = l.offerToReceiveAudio), l.offerToReceiveVideo !== void 0 && (l.offerToReceiveVideo === !0 ? f = 1 : l.offerToReceiveVideo === !1 ? f = 0 : f = l.offerToReceiveVideo) } for (s.transceivers.forEach(function (d) { d.kind === "audio" ? (c--, c < 0 && (d.wantReceive = !1)) : d.kind === "video" && (f--, f < 0 && (d.wantReceive = !1)) }); c > 0 || f > 0;)c > 0 && (s._createTransceiver("audio"), c--), f > 0 && (s._createTransceiver("video"), f--); var p = O.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.transceivers.forEach(function (d, h) { var _ = d.track, m = d.kind, g = d.mid || O.generateIdentifier(); d.mid = g, d.iceGatherer || (d.iceGatherer = s._createIceGatherer(h, s.usingBundle)); var C = e.RTCRtpSender.getCapabilities(m); t < 15019 && (C.codecs = C.codecs.filter(function (y) { return y.name !== "rtx" })), C.codecs.forEach(function (y) { y.name === "H264" && y.parameters["level-asymmetry-allowed"] === void 0 && (y.parameters["level-asymmetry-allowed"] = "1"), d.remoteCapabilities && d.remoteCapabilities.codecs && d.remoteCapabilities.codecs.forEach(function (S) { y.name.toLowerCase() === S.name.toLowerCase() && y.clockRate === S.clockRate && (y.preferredPayloadType = S.payloadType) }) }), C.headerExtensions.forEach(function (y) { var S = d.remoteCapabilities && d.remoteCapabilities.headerExtensions || []; S.forEach(function (P) { y.uri === P.uri && (y.id = P.id) }) }); var b = d.sendEncodingParameters || [{ ssrc: (2 * h + 1) * 1001 }]; _ && t >= 15019 && m === "video" && !b[0].rtx && (b[0].rtx = { ssrc: b[0].ssrc + 1 }), d.wantReceive && (d.rtpReceiver = new e.RTCRtpReceiver(d.dtlsTransport, m)), d.localCapabilities = C, d.sendEncodingParameters = b }), s._config.bundlePolicy !== "max-compat" && (p += "a=group:BUNDLE " + s.transceivers.map(function (d) { return d.mid }).join(" ") + `\r
`), p += `a=ice-options:trickle\r
`, s.transceivers.forEach(function (d, h) {
            p += Hn(d, d.localCapabilities, "offer", d.stream, s._dtlsRole), p += `a=rtcp-rsize\r
`, d.iceGatherer && s.iceGatheringState !== "new" && (h === 0 || !s.usingBundle) && (d.iceGatherer.getLocalCandidates().forEach(function (_) {
                _.component = 1, p += "a=" + O.writeCandidate(_) + `\r
`}), d.iceGatherer.state === "completed" && (p += `a=end-of-candidates\r
`))
        }); var v = new e.RTCSessionDescription({ type: "offer", sdp: p }); return Promise.resolve(v)
    }, a.prototype.createAnswer = function () {
        var s = this; if (s._isClosed) return Promise.reject(ee("InvalidStateError", "Can not call createAnswer after close")); if (!(s.signalingState === "have-remote-offer" || s.signalingState === "have-local-pranswer")) return Promise.reject(ee("InvalidStateError", "Can not call createAnswer in signalingState " + s.signalingState)); var c = O.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.usingBundle && (c += "a=group:BUNDLE " + s.transceivers.map(function (p) { return p.mid }).join(" ") + `\r
`), c += `a=ice-options:trickle\r
`; var f = O.getMediaSections(s._remoteDescription.sdp).length; s.transceivers.forEach(function (p, v) {
            if (!(v + 1 > f)) {
                if (p.rejected) {
                    p.kind === "application" ? p.protocol === "DTLS/SCTP" ? c += `m=application 0 DTLS/SCTP 5000\r
`: c += "m=application 0 " + p.protocol + ` webrtc-datachannel\r
`: p.kind === "audio" ? c += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
`: p.kind === "video" && (c += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), c += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:`+ p.mid + `\r
`; return
                } if (p.stream) { var d; p.kind === "audio" ? d = p.stream.getAudioTracks()[0] : p.kind === "video" && (d = p.stream.getVideoTracks()[0]), d && t >= 15019 && p.kind === "video" && !p.sendEncodingParameters[0].rtx && (p.sendEncodingParameters[0].rtx = { ssrc: p.sendEncodingParameters[0].ssrc + 1 }) } var h = Lt(p.localCapabilities, p.remoteCapabilities), _ = h.codecs.filter(function (m) { return m.name.toLowerCase() === "rtx" }).length; !_ && p.sendEncodingParameters[0].rtx && delete p.sendEncodingParameters[0].rtx, c += Hn(p, h, "answer", p.stream, s._dtlsRole), p.rtcpParameters && p.rtcpParameters.reducedSize && (c += `a=rtcp-rsize\r
`)
            }
        }); var l = new e.RTCSessionDescription({ type: "answer", sdp: c }); return Promise.resolve(l)
    }, a.prototype.addIceCandidate = function (s) {
        var c = this, f; return s && !(s.sdpMLineIndex !== void 0 || s.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function (l, p) {
            if (c._remoteDescription) if (!s || s.candidate === "") for (var v = 0; v < c.transceivers.length && !(!c.transceivers[v].rejected && (c.transceivers[v].iceTransport.addRemoteCandidate({}), f = O.getMediaSections(c._remoteDescription.sdp), f[v] += `a=end-of-candidates\r
`, c._remoteDescription.sdp = O.getDescription(c._remoteDescription.sdp) + f.join(""), c.usingBundle)); v++); else {
                var d = s.sdpMLineIndex; if (s.sdpMid) { for (var h = 0; h < c.transceivers.length; h++)if (c.transceivers[h].mid === s.sdpMid) { d = h; break } } var _ = c.transceivers[d]; if (_) {
                    if (_.rejected) return l(); var m = Object.keys(s.candidate).length > 0 ? O.parseCandidate(s.candidate) : {}; if (m.protocol === "tcp" && (m.port === 0 || m.port === 9) || m.component && m.component !== 1) return l(); if ((d === 0 || d > 0 && _.iceTransport !== c.transceivers[0].iceTransport) && !Cr(_.iceTransport, m)) return p(ee("OperationError", "Can not add ICE candidate")); var g = s.candidate.trim(); g.indexOf("a=") === 0 && (g = g.substr(2)), f = O.getMediaSections(c._remoteDescription.sdp), f[d] += "a=" + (m.type ? g : "end-of-candidates") + `\r
`, c._remoteDescription.sdp = O.getDescription(c._remoteDescription.sdp) + f.join("")
                } else return p(ee("OperationError", "Can not add ICE candidate"))
            } else return p(ee("InvalidStateError", "Can not add ICE candidate without a remote description")); l()
        })
    }, a.prototype.getStats = function (s) { if (s && s instanceof e.MediaStreamTrack) { var c = null; if (this.transceivers.forEach(function (l) { l.rtpSender && l.rtpSender.track === s ? c = l.rtpSender : l.rtpReceiver && l.rtpReceiver.track === s && (c = l.rtpReceiver) }), !c) throw ee("InvalidAccessError", "Invalid selector."); return c.getStats() } var f = []; return this.transceivers.forEach(function (l) { ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function (p) { l[p] && f.push(l[p].getStats()) }) }), Promise.all(f).then(function (l) { var p = new Map; return l.forEach(function (v) { v.forEach(function (d) { p.set(d.id, d) }) }), p }) }; var o = ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"]; o.forEach(function (s) { var c = e[s]; if (c && c.prototype && c.prototype.getStats) { var f = c.prototype.getStats; c.prototype.getStats = function () { return f.apply(this).then(function (l) { var p = new Map; return Object.keys(l).forEach(function (v) { l[v].type = As(l[v]), p.set(v, l[v]) }), p }) } } }); var u = ["createOffer", "createAnswer"]; return u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var f = arguments; return typeof f[0] == "function" || typeof f[1] == "function" ? c.apply(this, [arguments[2]]).then(function (l) { typeof f[0] == "function" && f[0].apply(null, [l]) }, function (l) { typeof f[1] == "function" && f[1].apply(null, [l]) }) : c.apply(this, arguments) } }), u = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var f = arguments; return typeof f[1] == "function" || typeof f[2] == "function" ? c.apply(this, arguments).then(function () { typeof f[1] == "function" && f[1].apply(null) }, function (l) { typeof f[2] == "function" && f[2].apply(null, [l]) }) : c.apply(this, arguments) } }), ["getStats"].forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var f = arguments; return typeof f[1] == "function" ? c.apply(this, arguments).then(function () { typeof f[1] == "function" && f[1].apply(null) }) : c.apply(this, arguments) } }), a
}; function oa(e) { const t = e && e.navigator, r = function (i) { return { name: { PermissionDeniedError: "NotAllowedError" }[i.name] || i.name, message: i.message, constraint: i.constraint, toString() { return this.name } } }, n = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (i) { return n(i).catch(a => Promise.reject(r(a))) } } function sa(e) { "getDisplayMedia" in e.navigator && (!e.navigator.mediaDevices || e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator))) } function Yr(e, t) { if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function (i) { return i }), e.RTCSessionDescription || (e.RTCSessionDescription = function (i) { return i }), t.version < 15025)) { const n = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled"); Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", { set(i) { n.set.call(this, i); const a = new Event("enabled"); a.enabled = i, this.dispatchEvent(a) } }) } e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype) && Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf } }), e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender); const r = Bs(e, t.version); e.RTCPeerConnection = function (i) { return i && i.iceServers && (i.iceServers = Is(i.iceServers, t.version), Cn("ICE servers after filtering:", i.iceServers)), new r(i) }, e.RTCPeerConnection.prototype = r.prototype } function ca(e) { e.RTCRtpSender && !("replaceTrack" in e.RTCRtpSender.prototype) && (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack) } const Yn = Object.freeze(Object.defineProperty({ __proto__: null, shimPeerConnection: Yr, shimReplaceTrack: ca, shimGetUserMedia: oa, shimGetDisplayMedia: sa }, Symbol.toStringTag, { value: "Module" })); function ua(e, t) { const r = e && e.navigator, n = e && e.MediaStreamTrack; if (r.getUserMedia = function (i, a, o) { dr("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r.mediaDevices.getUserMedia(i).then(a, o) }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) { const i = function (o, u, s) { u in o && !(s in o) && (o[s] = o[u], delete o[u]) }, a = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (o) { return typeof o == "object" && typeof o.audio == "object" && (o = JSON.parse(JSON.stringify(o)), i(o.audio, "autoGainControl", "mozAutoGainControl"), i(o.audio, "noiseSuppression", "mozNoiseSuppression")), a(o) }, n && n.prototype.getSettings) { const o = n.prototype.getSettings; n.prototype.getSettings = function () { const u = o.apply(this, arguments); return i(u, "mozAutoGainControl", "autoGainControl"), i(u, "mozNoiseSuppression", "noiseSuppression"), u } } if (n && n.prototype.applyConstraints) { const o = n.prototype.applyConstraints; n.prototype.applyConstraints = function (u) { return this.kind === "audio" && typeof u == "object" && (u = JSON.parse(JSON.stringify(u)), i(u, "autoGainControl", "mozAutoGainControl"), i(u, "noiseSuppression", "mozNoiseSuppression")), o.apply(this, [u]) } } } } function js(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || !e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = function (n) { if (!(n && n.video)) { const i = new DOMException("getDisplayMedia without video constraints is undefined"); return i.name = "NotFoundError", i.code = 8, Promise.reject(i) } return n.video === !0 ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n) }) } function fa(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function qr(e, t) { if (typeof e != "object" || !(e.RTCPeerConnection || e.mozRTCPeerConnection)) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (i) { const a = e.RTCPeerConnection.prototype[i], o = { [i]() { return arguments[0] = new (i === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), a.apply(this, arguments) } }; e.RTCPeerConnection.prototype[i] = o[i] }); const r = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [a, o, u] = arguments; return n.apply(this, [a || null]).then(s => { if (t.version < 53 && !o) try { s.forEach(c => { c.type = r[c.type] || c.type }) } catch (c) { if (c.name !== "TypeError") throw c; s.forEach((f, l) => { s.set(l, Object.assign({}, f, { type: r[f.type] || f.type })) }) } return s }).then(o, u) } } function la(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const i = t.apply(this, []); return i.forEach(a => a._pc = this), i }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const i = r.apply(this, arguments); return i._pc = this, i }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function pa(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }), ot(e, "track", r => (r.receiver._pc = r.srcElement, r)), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function da(e) { !e.RTCPeerConnection || "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { dr("removeStream", "removeTrack"), this.getSenders().forEach(n => { n.track && r.getTracks().includes(n.track) && this.removeTrack(n) }) }) } function ha(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function va(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const n = arguments[1], i = n && "sendEncodings" in n; i && n.sendEncodings.forEach(o => { if ("rid" in o && !/^[a-z0-9]{0,16}$/i.test(o.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in o && !(parseFloat(o.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in o && !(parseFloat(o.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") }); const a = t.apply(this, arguments); if (i) { const { sender: o } = a, u = o.getParameters(); (!("encodings" in u) || u.encodings.length === 1 && Object.keys(u.encodings[0]).length === 0) && (u.encodings = n.sendEncodings, o.sendEncodings = n.sendEncodings, this.setParametersPromises.push(o.setParameters(u).then(() => { delete o.sendEncodings }).catch(() => { delete o.sendEncodings }))) } return a }) } function ma(e) { if (!(typeof e == "object" && e.RTCRtpSender)) return; const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const n = t.apply(this, arguments); return "encodings" in n || (n.encodings = [].concat(this.sendEncodings || [{}])), n }) } function ya(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } function ga(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } const qn = Object.freeze(Object.defineProperty({ __proto__: null, shimOnTrack: fa, shimPeerConnection: qr, shimSenderGetStats: la, shimReceiverGetStats: pa, shimRemoveStream: da, shimRTCDataChannel: ha, shimAddTransceiver: va, shimGetParameters: ma, shimCreateOffer: ya, shimCreateAnswer: ga, shimGetUserMedia: ua, shimGetDisplayMedia: js }, Symbol.toStringTag, { value: "Module" })); function _a(e) { if (!(typeof e != "object" || !e.RTCPeerConnection)) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (n) { this._localStreams || (this._localStreams = []), this._localStreams.includes(n) || this._localStreams.push(n), n.getAudioTracks().forEach(i => t.call(this, i, n)), n.getVideoTracks().forEach(i => t.call(this, i, n)) }, e.RTCPeerConnection.prototype.addTrack = function (n, ...i) { return i && i.forEach(a => { this._localStreams ? this._localStreams.includes(a) || this._localStreams.push(a) : this._localStreams = [a] }), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { this._localStreams || (this._localStreams = []); const n = this._localStreams.indexOf(r); if (n === -1) return; this._localStreams.splice(n, 1); const i = r.getTracks(); this.getSenders().forEach(a => { i.includes(a.track) && this.removeTrack(a) }) }) } } function ba(e) { if (!(typeof e != "object" || !e.RTCPeerConnection) && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(r) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = r), this.addEventListener("track", this._onaddstreampoly = n => { n.streams.forEach(i => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(i)) return; this._remoteStreams.push(i); const a = new Event("addstream"); a.stream = i, this.dispatchEvent(a) }) }) } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const n = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (i) { i.streams.forEach(a => { if (n._remoteStreams || (n._remoteStreams = []), n._remoteStreams.indexOf(a) >= 0) return; n._remoteStreams.push(a); const o = new Event("addstream"); o.stream = a, n.dispatchEvent(o) }) }), t.apply(n, arguments) } } } function Ca(e) { if (typeof e != "object" || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer, i = t.setLocalDescription, a = t.setRemoteDescription, o = t.addIceCandidate; t.createOffer = function (c, f) { const l = arguments.length >= 2 ? arguments[2] : arguments[0], p = r.apply(this, [l]); return f ? (p.then(c, f), Promise.resolve()) : p }, t.createAnswer = function (c, f) { const l = arguments.length >= 2 ? arguments[2] : arguments[0], p = n.apply(this, [l]); return f ? (p.then(c, f), Promise.resolve()) : p }; let u = function (s, c, f) { const l = i.apply(this, [s]); return f ? (l.then(c, f), Promise.resolve()) : l }; t.setLocalDescription = u, u = function (s, c, f) { const l = a.apply(this, [s]); return f ? (l.then(c, f), Promise.resolve()) : l }, t.setRemoteDescription = u, u = function (s, c, f) { const l = o.apply(this, [s]); return f ? (l.then(c, f), Promise.resolve()) : l }, t.addIceCandidate = u } function Sa(e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const r = t.mediaDevices, n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = i => n(Ta(i)) } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (n, i, a) { t.mediaDevices.getUserMedia(n).then(i, a) }.bind(t)) } function Ta(e) { return e && e.video !== void 0 ? Object.assign({}, e, { video: qi(e.video) }) : e } function ka(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection; e.RTCPeerConnection = function (n, i) { if (n && n.iceServers) { const a = []; for (let o = 0; o < n.iceServers.length; o++) { let u = n.iceServers[o]; !u.hasOwnProperty("urls") && u.hasOwnProperty("url") ? (dr("RTCIceServer.url", "RTCIceServer.urls"), u = JSON.parse(JSON.stringify(u)), u.urls = u.url, delete u.url, a.push(u)) : a.push(n.iceServers[o]) } n.iceServers = a } return new t(n, i) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get() { return t.generateCertificate } }) } function Pa(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function Ea(e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (n) { if (n) { typeof n.offerToReceiveAudio < "u" && (n.offerToReceiveAudio = !!n.offerToReceiveAudio); const i = this.getTransceivers().find(o => o.receiver.track.kind === "audio"); n.offerToReceiveAudio === !1 && i ? i.direction === "sendrecv" ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : i.direction === "recvonly" && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : n.offerToReceiveAudio === !0 && !i && this.addTransceiver("audio"), typeof n.offerToReceiveVideo < "u" && (n.offerToReceiveVideo = !!n.offerToReceiveVideo); const a = this.getTransceivers().find(o => o.receiver.track.kind === "video"); n.offerToReceiveVideo === !1 && a ? a.direction === "sendrecv" ? a.setDirection ? a.setDirection("sendonly") : a.direction = "sendonly" : a.direction === "recvonly" && (a.setDirection ? a.setDirection("inactive") : a.direction = "inactive") : n.offerToReceiveVideo === !0 && !a && this.addTransceiver("video") } return t.apply(this, arguments) } } function Ra(e) { typeof e != "object" || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } const Xn = Object.freeze(Object.defineProperty({ __proto__: null, shimLocalStreamsAPI: _a, shimRemoteStreamsAPI: ba, shimCallbacksAPI: Ca, shimGetUserMedia: Sa, shimConstraints: Ta, shimRTCIceServerUrls: ka, shimTrackEventTransceiver: Pa, shimCreateOfferLegacy: Ea, shimAudioContext: Ra }, Symbol.toStringTag, { value: "Module" })); function Yt(e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (n) { if (typeof n == "object" && n.candidate && n.candidate.indexOf("a=") === 0 && (n = JSON.parse(JSON.stringify(n)), n.candidate = n.candidate.substr(2)), n.candidate && n.candidate.length) { const i = new t(n), a = Wt.parseCandidate(n.candidate), o = Object.assign(i, a); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(n) }, e.RTCIceCandidate.prototype = t.prototype, ot(e, "icecandidate", r => (r.candidate && Object.defineProperty(r, "candidate", { value: new e.RTCIceCandidate(r.candidate), writable: "false" }), r)) } function dt(e, t) { if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp } }); const r = function (u) { if (!u || !u.sdp) return !1; const s = Wt.splitSections(u.sdp); return s.shift(), s.some(c => { const f = Wt.parseMLine(c); return f && f.kind === "application" && f.protocol.indexOf("SCTP") !== -1 }) }, n = function (u) { const s = u.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (s === null || s.length < 2) return -1; const c = parseInt(s[1], 10); return c !== c ? -1 : c }, i = function (u) { let s = 65536; return t.browser === "firefox" && (t.version < 57 ? u === -1 ? s = 16384 : s = 2147483637 : t.version < 60 ? s = t.version === 57 ? 65535 : 65536 : s = 2147483637), s }, a = function (u, s) { let c = 65536; t.browser === "firefox" && t.version === 57 && (c = 65535); const f = Wt.matchPrefix(u.sdp, "a=max-message-size:"); return f.length > 0 ? c = parseInt(f[0].substr(19), 10) : t.browser === "firefox" && s !== -1 && (c = 2147483637), c }, o = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, t.browser === "chrome" && t.version >= 76) { const { sdpSemantics: s } = this.getConfiguration(); s === "plan-b" && Object.defineProperty(this, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (r(arguments[0])) { const s = n(arguments[0]), c = i(s), f = a(arguments[0], s); let l; c === 0 && f === 0 ? l = Number.POSITIVE_INFINITY : c === 0 || f === 0 ? l = Math.max(c, f) : l = Math.min(c, f); const p = {}; Object.defineProperty(p, "maxMessageSize", { get() { return l } }), this._sctp = p } return o.apply(this, arguments) } } function ht(e) { if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return; function t(n, i) { const a = n.send; n.send = function () { const u = arguments[0], s = u.length || u.size || u.byteLength; if (n.readyState === "open" && i.sctp && s > i.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + i.sctp.maxMessageSize + " bytes)"); return a.apply(n, arguments) } } const r = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const i = r.apply(this, arguments); return t(i, this), i }, ot(e, "datachannel", n => (t(n.channel, n.target), n)) } function Xr(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(r) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), r && this.addEventListener("connectionstatechange", this._onconnectionstatechange = r) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach(r => { const n = t[r]; t[r] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = i => { const a = i.target; if (a._lastConnectionState !== a.connectionState) { a._lastConnectionState = a.connectionState; const o = new Event("connectionstatechange", i); a.dispatchEvent(o) } return i }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } }) } function Qr(e, t) {
    if (!e.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605) return; const r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (i) {
        if (i && i.sdp && i.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
            const a = i.sdp.split(`
`).filter(o => o.trim() !== "a=extmap-allow-mixed").join(`
`); e.RTCSessionDescription && i instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: i.type, sdp: a }) : i.sdp = a
        } return r.apply(this, arguments)
    }
} function qt(e, t) { if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype)) return; const r = e.RTCPeerConnection.prototype.addIceCandidate; !r || r.length === 0 || (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } const Fs = Object.freeze(Object.defineProperty({ __proto__: null, shimRTCIceCandidate: Yt, shimMaxMessageSize: dt, shimSendThrowTypeError: ht, shimConnectionState: Xr, removeExtmapAllowMixed: Qr, shimAddIceCandidateNullOrEmpty: qt }, Symbol.toStringTag, { value: "Module" })); function Ks({ window: e } = {}, t = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }) { const r = Cn, n = Os(e), i = { browserDetails: n, commonShim: Fs, extractVersion: pt, disableLog: xs, disableWarnings: Ds }; switch (n.browser) { case "chrome": if (!Jn || !Wr || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), i; if (n.version === null) return r("Chrome shim can not determine version, not shimming."), i; r("adapter.js shimming chrome."), i.browserShim = Jn, qt(e, n), Xi(e, n), Qi(e), Wr(e, n), Zi(e), ia(e, n), ea(e), ta(e), ra(e), aa(e, n), Yt(e), Xr(e), dt(e, n), ht(e), Qr(e, n); break; case "firefox": if (!qn || !qr || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), i; r("adapter.js shimming firefox."), i.browserShim = qn, qt(e, n), ua(e, n), qr(e, n), fa(e), da(e), la(e), pa(e), ha(e), va(e), ma(e), ya(e), ga(e), Yt(e), Xr(e), dt(e, n), ht(e); break; case "edge": if (!Yn || !Yr || !t.shimEdge) return r("MS edge shim is not included in this adapter release."), i; r("adapter.js shimming edge."), i.browserShim = Yn, oa(e), sa(e), Yr(e, n), ca(e), dt(e, n), ht(e); break; case "safari": if (!Xn || !t.shimSafari) return r("Safari shim is not included in this adapter release."), i; r("adapter.js shimming safari."), i.browserShim = Xn, qt(e, n), ka(e), Ea(e), Ca(e), _a(e), ba(e), Pa(e), Sa(e), Ra(e), Yt(e), dt(e, n), ht(e), Qr(e, n); break; default: r("Unsupported browser!"); break }return i } const Qn = Ks({ window: typeof window > "u" ? void 0 : window }); function be(e, t, r, n) { Object.defineProperty(e, t, { get: r, set: n, enumerable: !0, configurable: !0 }) } var Sr = Qn.default || Qn, st = new (function () {
    function e() { this.isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform), this.supportedBrowsers = ["firefox", "chrome", "safari"], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605 } return e.prototype.isWebRTCSupported = function () { return typeof RTCPeerConnection < "u" }, e.prototype.isBrowserSupported = function () { var t = this.getBrowser(), r = this.getVersion(), n = this.supportedBrowsers.includes(t); return n ? t === "chrome" ? r >= this.minChromeVersion : t === "firefox" ? r >= this.minFirefoxVersion : t === "safari" ? !this.isIOS && r >= this.minSafariVersion : !1 : !1 }, e.prototype.getBrowser = function () { return Sr.browserDetails.browser }, e.prototype.getVersion = function () { return Sr.browserDetails.version || 0 }, e.prototype.isUnifiedPlanSupported = function () { var t = this.getBrowser(), r = Sr.browserDetails.version || 0; if (t === "chrome" && r < this.minChromeVersion) return !1; if (t === "firefox" && r >= this.minFirefoxVersion) return !0; if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1; var n, i = !1; try { n = new RTCPeerConnection, n.addTransceiver("audio"), i = !0 } catch { } finally { n && n.close() } return i }, e.prototype.toString = function () {
        return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported())
    }, e
}()), Zn = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: ["turn:eu-0.turn.peerjs.com:3478", "turn:us-0.turn.peerjs.com:3478"], username: "peerjs", credential: "peerjsp" }], sdpSemantics: "unified-plan" }, Ls = function () { function e() { this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = { Chrome: 1, chrome: 1 }, this.chunkedMTU = 16300, this.defaultConfig = Zn, this.browser = st.getBrowser(), this.browserVersion = st.getVersion(), this.supports = function () { var t = { browser: st.isBrowserSupported(), webRTC: st.isWebRTCSupported(), audioVideo: !1, data: !1, binaryBlob: !1, reliable: !1 }; if (!t.webRTC) return t; var r; try { r = new RTCPeerConnection(Zn), t.audioVideo = !0; var n = void 0; try { n = r.createDataChannel("_PEERJSTEST", { ordered: !0 }), t.data = !0, t.reliable = !!n.ordered; try { n.binaryType = "blob", t.binaryBlob = !st.isIOS } catch { } } catch { } finally { n && n.close() } } catch { } finally { r && r.close() } return t }(), this.pack = zn.pack, this.unpack = zn.unpack, this._dataCount = 1 } return e.prototype.noop = function () { }, e.prototype.validateId = function (t) { return !t || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(t) }, e.prototype.chunk = function (t) { for (var r = [], n = t.size, i = Math.ceil(n / F.chunkedMTU), a = 0, o = 0; o < n;) { var u = Math.min(n, o + F.chunkedMTU), s = t.slice(o, u), c = { __peerData: this._dataCount, n: a, data: s, total: i }; r.push(c), o = u, a++ } return this._dataCount++, r }, e.prototype.blobToArrayBuffer = function (t, r) { var n = new FileReader; return n.onload = function (i) { i.target && r(i.target.result) }, n.readAsArrayBuffer(t), n }, e.prototype.binaryStringToArrayBuffer = function (t) { for (var r = new Uint8Array(t.length), n = 0; n < t.length; n++)r[n] = t.charCodeAt(n) & 255; return r.buffer }, e.prototype.randomToken = function () { return Math.random().toString(36).slice(2) }, e.prototype.isSecure = function () { return location.protocol === "https:" }, e }(), F = new Ls, xa = {}; be(xa, "Peer", () => fi, e => fi = e); var At = {}, Ns = Object.prototype.hasOwnProperty, se = "~"; function Et() { } Object.create && (Et.prototype = Object.create(null), new Et().__proto__ || (se = !1)); function Us(e, t, r) { this.fn = e, this.context = t, this.once = r || !1 } function Da(e, t, r, n, i) { if (typeof r != "function") throw new TypeError("The listener must be a function"); var a = new Us(r, n || e, i), o = se ? se + t : t; return e._events[o] ? e._events[o].fn ? e._events[o] = [e._events[o], a] : e._events[o].push(a) : (e._events[o] = a, e._eventsCount++), e } function Xt(e, t) { --e._eventsCount === 0 ? e._events = new Et : delete e._events[t] } function ne() { this._events = new Et, this._eventsCount = 0 } ne.prototype.eventNames = function () { var t = [], r, n; if (this._eventsCount === 0) return t; for (n in r = this._events) Ns.call(r, n) && t.push(se ? n.slice(1) : n); return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(r)) : t }; ne.prototype.listeners = function (t) { var r = se ? se + t : t, n = this._events[r]; if (!n) return []; if (n.fn) return [n.fn]; for (var i = 0, a = n.length, o = new Array(a); i < a; i++)o[i] = n[i].fn; return o }; ne.prototype.listenerCount = function (t) { var r = se ? se + t : t, n = this._events[r]; return n ? n.fn ? 1 : n.length : 0 }; ne.prototype.emit = function (t, r, n, i, a, o) { var u = se ? se + t : t; if (!this._events[u]) return !1; var s = this._events[u], c = arguments.length, f, l; if (s.fn) { switch (s.once && this.removeListener(t, s.fn, void 0, !0), c) { case 1: return s.fn.call(s.context), !0; case 2: return s.fn.call(s.context, r), !0; case 3: return s.fn.call(s.context, r, n), !0; case 4: return s.fn.call(s.context, r, n, i), !0; case 5: return s.fn.call(s.context, r, n, i, a), !0; case 6: return s.fn.call(s.context, r, n, i, a, o), !0 }for (l = 1, f = new Array(c - 1); l < c; l++)f[l - 1] = arguments[l]; s.fn.apply(s.context, f) } else { var p = s.length, v; for (l = 0; l < p; l++)switch (s[l].once && this.removeListener(t, s[l].fn, void 0, !0), c) { case 1: s[l].fn.call(s[l].context); break; case 2: s[l].fn.call(s[l].context, r); break; case 3: s[l].fn.call(s[l].context, r, n); break; case 4: s[l].fn.call(s[l].context, r, n, i); break; default: if (!f) for (v = 1, f = new Array(c - 1); v < c; v++)f[v - 1] = arguments[v]; s[l].fn.apply(s[l].context, f) } } return !0 }; ne.prototype.on = function (t, r, n) { return Da(this, t, r, n, !1) }; ne.prototype.once = function (t, r, n) { return Da(this, t, r, n, !0) }; ne.prototype.removeListener = function (t, r, n, i) { var a = se ? se + t : t; if (!this._events[a]) return this; if (!r) return Xt(this, a), this; var o = this._events[a]; if (o.fn) o.fn === r && (!i || o.once) && (!n || o.context === n) && Xt(this, a); else { for (var u = 0, s = [], c = o.length; u < c; u++)(o[u].fn !== r || i && !o[u].once || n && o[u].context !== n) && s.push(o[u]); s.length ? this._events[a] = s.length === 1 ? s[0] : s : Xt(this, a) } return this }; ne.prototype.removeAllListeners = function (t) { var r; return t ? (r = se ? se + t : t, this._events[r] && Xt(this, r)) : (this._events = new Et, this._eventsCount = 0), this }; ne.prototype.off = ne.prototype.removeListener; ne.prototype.addListener = ne.prototype.on; ne.prefixed = se; ne.EventEmitter = ne; At = ne; var R = {}; be(R, "LogLevel", () => ue, e => ue = e); be(R, "default", () => ei, e => ei = e); var Ue = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, ze = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, zs = "PeerJS: ", ue; (function (e) { e[e.Disabled = 0] = "Disabled", e[e.Errors = 1] = "Errors", e[e.Warnings = 2] = "Warnings", e[e.All = 3] = "All" })(ue || (ue = {})); var $s = function () { function e() { this._logLevel = ue.Disabled } return Object.defineProperty(e.prototype, "logLevel", { get: function () { return this._logLevel }, set: function (t) { this._logLevel = t }, enumerable: !1, configurable: !0 }), e.prototype.log = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= ue.All && this._print.apply(this, ze([ue.All], Ue(t), !1)) }, e.prototype.warn = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= ue.Warnings && this._print.apply(this, ze([ue.Warnings], Ue(t), !1)) }, e.prototype.error = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= ue.Errors && this._print.apply(this, ze([ue.Errors], Ue(t), !1)) }, e.prototype.setLogFunction = function (t) { this._print = t }, e.prototype._print = function (t) { for (var r = [], n = 1; n < arguments.length; n++)r[n - 1] = arguments[n]; var i = ze([zs], Ue(r), !1); for (var a in i) i[a] instanceof Error && (i[a] = "(" + i[a].name + ") " + i[a].message); t >= ue.All ? console.log.apply(console, ze([], Ue(i), !1)) : t >= ue.Warnings ? console.warn.apply(console, ze(["WARNING"], Ue(i), !1)) : t >= ue.Errors && console.error.apply(console, ze(["ERROR"], Ue(i), !1)) }, e }(), ei = new $s, Oa = {}; be(Oa, "Socket", () => ti, e => ti = e); var ve; (function (e) { e.Data = "data", e.Media = "media" })(ve || (ve = {})); var G; (function (e) { e.BrowserIncompatible = "browser-incompatible", e.Disconnected = "disconnected", e.InvalidID = "invalid-id", e.InvalidKey = "invalid-key", e.Network = "network", e.PeerUnavailable = "peer-unavailable", e.SslUnavailable = "ssl-unavailable", e.ServerError = "server-error", e.SocketError = "socket-error", e.SocketClosed = "socket-closed", e.UnavailableID = "unavailable-id", e.WebRTC = "webrtc" })(G || (G = {})); var Se; (function (e) { e.Binary = "binary", e.BinaryUTF8 = "binary-utf8", e.JSON = "json" })(Se || (Se = {})); var Re; (function (e) { e.Message = "message", e.Disconnected = "disconnected", e.Error = "error", e.Close = "close" })(Re || (Re = {})); var q; (function (e) { e.Heartbeat = "HEARTBEAT", e.Candidate = "CANDIDATE", e.Offer = "OFFER", e.Answer = "ANSWER", e.Open = "OPEN", e.Error = "ERROR", e.IdTaken = "ID-TAKEN", e.InvalidKey = "INVALID-KEY", e.Leave = "LEAVE", e.Expire = "EXPIRE" })(q || (q = {})); var Tn = {}; Tn = JSON.parse('{"name":"peerjs","version":"1.4.7","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xFCckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}'); var Gs = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Vs = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Js = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, Hs = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, ti = function (e) { Gs(t, e); function t(r, n, i, a, o, u) { u === void 0 && (u = 5e3); var s = e.call(this) || this; s.pingInterval = u, s._disconnected = !0, s._messagesQueue = []; var c = r ? "wss://" : "ws://"; return s._baseUrl = c + n + ":" + i + a + "peerjs?key=" + o, s } return t.prototype.start = function (r, n) { var i = this; this._id = r; var a = "".concat(this._baseUrl, "&id=").concat(r, "&token=").concat(n); !!this._socket || !this._disconnected || (this._socket = new WebSocket(a + "&version=" + Tn.version), this._disconnected = !1, this._socket.onmessage = function (o) { var u; try { u = JSON.parse(o.data), R.default.log("Server message received:", u) } catch { R.default.log("Invalid server message", o.data); return } i.emit(Re.Message, u) }, this._socket.onclose = function (o) { i._disconnected || (R.default.log("Socket closed.", o), i._cleanup(), i._disconnected = !0, i.emit(Re.Disconnected)) }, this._socket.onopen = function () { i._disconnected || (i._sendQueuedMessages(), R.default.log("Socket open"), i._scheduleHeartbeat()) }) }, t.prototype._scheduleHeartbeat = function () { var r = this; this._wsPingTimer = setTimeout(function () { r._sendHeartbeat() }, this.pingInterval) }, t.prototype._sendHeartbeat = function () { if (!this._wsOpen()) { R.default.log("Cannot send heartbeat, because socket closed"); return } var r = JSON.stringify({ type: q.Heartbeat }); this._socket.send(r), this._scheduleHeartbeat() }, t.prototype._wsOpen = function () { return !!this._socket && this._socket.readyState === 1 }, t.prototype._sendQueuedMessages = function () { var r, n, i = Js([], Vs(this._messagesQueue), !1); this._messagesQueue = []; try { for (var a = Hs(i), o = a.next(); !o.done; o = a.next()) { var u = o.value; this.send(u) } } catch (s) { r = { error: s } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } }, t.prototype.send = function (r) { if (!this._disconnected) { if (!this._id) { this._messagesQueue.push(r); return } if (!r.type) { this.emit(Re.Error, "Invalid message"); return } if (!!this._wsOpen()) { var n = JSON.stringify(r); this._socket.send(n) } } }, t.prototype.close = function () { this._disconnected || (this._cleanup(), this._disconnected = !0) }, t.prototype._cleanup = function () { this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer) }, t }(At.EventEmitter), Zr = {}; be(Zr, "MediaConnection", () => ii, e => ii = e); var kn = {}; be(kn, "Negotiator", () => ri, e => ri = e); var sr = function () { return sr = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, sr.apply(this, arguments) }, Nt = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(f) { try { c(n.next(f)) } catch (l) { o(l) } } function s(f) { try { c(n.throw(f)) } catch (l) { o(l) } } function c(f) { f.done ? a(f.value) : i(f.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, Ut = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (f) { return s([c, f]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (f) { c = [6, f], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, ri = function () { function e(t) { this.connection = t } return e.prototype.startConnection = function (t) { var r = this._startPeerConnection(); if (this.connection.peerConnection = r, this.connection.type === ve.Media && t._stream && this._addTracksToConnection(t._stream, r), t.originator) { if (this.connection.type === ve.Data) { var n = this.connection, i = { ordered: !!t.reliable }, a = r.createDataChannel(n.label, i); n.initialize(a) } this._makeOffer() } else this.handleSDP("OFFER", t.sdp) }, e.prototype._startPeerConnection = function () { R.default.log("Creating RTCPeerConnection."); var t = new RTCPeerConnection(this.connection.provider.options.config); return this._setupListeners(t), t }, e.prototype._setupListeners = function (t) { var r = this, n = this.connection.peer, i = this.connection.connectionId, a = this.connection.type, o = this.connection.provider; R.default.log("Listening for ICE candidates."), t.onicecandidate = function (u) { !u.candidate || !u.candidate.candidate || (R.default.log("Received ICE candidates for ".concat(n, ":"), u.candidate), o.socket.send({ type: q.Candidate, payload: { candidate: u.candidate, type: a, connectionId: i }, dst: n })) }, t.oniceconnectionstatechange = function () { switch (t.iceConnectionState) { case "failed": R.default.log("iceConnectionState is failed, closing connections to " + n), r.connection.emit("error", new Error("Negotiation of connection to " + n + " failed.")), r.connection.close(); break; case "closed": R.default.log("iceConnectionState is closed, closing connections to " + n), r.connection.emit("error", new Error("Connection to " + n + " closed.")), r.connection.close(); break; case "disconnected": R.default.log("iceConnectionState changed to disconnected on the connection with " + n); break; case "completed": t.onicecandidate = F.noop; break }r.connection.emit("iceStateChanged", t.iceConnectionState) }, R.default.log("Listening for data channel"), t.ondatachannel = function (u) { R.default.log("Received data channel"); var s = u.channel, c = o.getConnection(n, i); c.initialize(s) }, R.default.log("Listening for remote stream"), t.ontrack = function (u) { R.default.log("Received remote stream"); var s = u.streams[0], c = o.getConnection(n, i); if (c.type === ve.Media) { var f = c; r._addStreamToMediaConnection(s, f) } } }, e.prototype.cleanup = function () { R.default.log("Cleaning up PeerConnection to " + this.connection.peer); var t = this.connection.peerConnection; if (!!t) { this.connection.peerConnection = null, t.onicecandidate = t.oniceconnectionstatechange = t.ondatachannel = t.ontrack = function () { }; var r = t.signalingState !== "closed", n = !1; if (this.connection.type === ve.Data) { var i = this.connection, a = i.dataChannel; a && (n = !!a.readyState && a.readyState !== "closed") } (r || n) && t.close() } }, e.prototype._makeOffer = function () { return Nt(this, void 0, Promise, function () { var t, r, n, i, a, o, u; return Ut(this, function (s) { switch (s.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 7, , 8]), [4, t.createOffer(this.connection.options.constraints)]; case 2: n = s.sent(), R.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), s.label = 3; case 3: return s.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return s.sent(), R.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), i = { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, metadata: this.connection.metadata, browser: F.browser }, this.connection.type === ve.Data && (a = this.connection, i = sr(sr({}, i), { label: a.label, reliable: a.reliable, serialization: a.serialization })), r.socket.send({ type: q.Offer, payload: i, dst: this.connection.peer }), [3, 6]; case 5: return o = s.sent(), o != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (r.emitError(G.WebRTC, o), R.default.log("Failed to setLocalDescription, ", o)), [3, 6]; case 6: return [3, 8]; case 7: return u = s.sent(), r.emitError(G.WebRTC, u), R.default.log("Failed to createOffer, ", u), [3, 8]; case 8: return [2] } }) }) }, e.prototype._makeAnswer = function () { return Nt(this, void 0, Promise, function () { var t, r, n, i, a; return Ut(this, function (o) { switch (o.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, o.label = 1; case 1: return o.trys.push([1, 7, , 8]), [4, t.createAnswer()]; case 2: n = o.sent(), R.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), o.label = 3; case 3: return o.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return o.sent(), R.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), r.socket.send({ type: q.Answer, payload: { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, browser: F.browser }, dst: this.connection.peer }), [3, 6]; case 5: return i = o.sent(), r.emitError(G.WebRTC, i), R.default.log("Failed to setLocalDescription, ", i), [3, 6]; case 6: return [3, 8]; case 7: return a = o.sent(), r.emitError(G.WebRTC, a), R.default.log("Failed to create answer, ", a), [3, 8]; case 8: return [2] } }) }) }, e.prototype.handleSDP = function (t, r) { return Nt(this, void 0, Promise, function () { var n, i, a, o; return Ut(this, function (u) { switch (u.label) { case 0: r = new RTCSessionDescription(r), n = this.connection.peerConnection, i = this.connection.provider, R.default.log("Setting remote description", r), a = this, u.label = 1; case 1: return u.trys.push([1, 5, , 6]), [4, n.setRemoteDescription(r)]; case 2: return u.sent(), R.default.log("Set remoteDescription:".concat(t, " for:").concat(this.connection.peer)), t !== "OFFER" ? [3, 4] : [4, a._makeAnswer()]; case 3: u.sent(), u.label = 4; case 4: return [3, 6]; case 5: return o = u.sent(), i.emitError(G.WebRTC, o), R.default.log("Failed to setRemoteDescription, ", o), [3, 6]; case 6: return [2] } }) }) }, e.prototype.handleCandidate = function (t) { return Nt(this, void 0, Promise, function () { var r, n, i, a, o, u; return Ut(this, function (s) { switch (s.label) { case 0: R.default.log("handleCandidate:", t), r = t.candidate, n = t.sdpMLineIndex, i = t.sdpMid, a = this.connection.peerConnection, o = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 3, , 4]), [4, a.addIceCandidate(new RTCIceCandidate({ sdpMid: i, sdpMLineIndex: n, candidate: r }))]; case 2: return s.sent(), R.default.log("Added ICE candidate for:".concat(this.connection.peer)), [3, 4]; case 3: return u = s.sent(), o.emitError(G.WebRTC, u), R.default.log("Failed to handleCandidate, ", u), [3, 4]; case 4: return [2] } }) }) }, e.prototype._addTracksToConnection = function (t, r) { if (R.default.log("add tracks from stream ".concat(t.id, " to peer connection")), !r.addTrack) return R.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored."); t.getTracks().forEach(function (n) { r.addTrack(n, t) }) }, e.prototype._addStreamToMediaConnection = function (t, r) { R.default.log("add stream ".concat(t.id, " to media connection ").concat(r.connectionId)), r.addStream(t) }, e }(), Pn = {}; be(Pn, "BaseConnection", () => ni, e => ni = e); var Ws = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), ni = function (e) { Ws(t, e); function t(r, n, i) { var a = e.call(this) || this; return a.peer = r, a.provider = n, a.options = i, a._open = !1, a.metadata = i.metadata, a } return Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), t }(At.EventEmitter), Ys = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), cr = function () { return cr = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, cr.apply(this, arguments) }, qs = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, ii = function (e) { Ys(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a._localStream = a.options._stream, a.connectionId = a.options.connectionId || t.ID_PREFIX + F.randomToken(), a._negotiator = new kn.Negotiator(a), a._localStream && a._negotiator.startConnection({ _stream: a._localStream, originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return ve.Media }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "localStream", { get: function () { return this._localStream }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "remoteStream", { get: function () { return this._remoteStream }, enumerable: !1, configurable: !0 }), t.prototype.addStream = function (r) { R.default.log("Receiving stream", r), this._remoteStream = r, e.prototype.emit.call(this, "stream", r) }, t.prototype.handleMessage = function (r) { var n = r.type, i = r.payload; switch (r.type) { case q.Answer: this._negotiator.handleSDP(n, i.sdp), this._open = !0; break; case q.Candidate: this._negotiator.handleCandidate(i.candidate); break; default: R.default.warn("Unrecognized message type:".concat(n, " from peer:").concat(this.peer)); break } }, t.prototype.answer = function (r, n) { var i, a; if (n === void 0 && (n = {}), this._localStream) { R.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?"); return } this._localStream = r, n && n.sdpTransform && (this.options.sdpTransform = n.sdpTransform), this._negotiator.startConnection(cr(cr({}, this.options._payload), { _stream: r })); var o = this.provider._getMessages(this.connectionId); try { for (var u = qs(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; this.handleMessage(c) } } catch (f) { i = { error: f } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } this._open = !0 }, t.prototype.close = function () { this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.ID_PREFIX = "mc_", t }(Pn.BaseConnection), en = {}; be(en, "DataConnection", () => oi, e => oi = e); var wa = {}; be(wa, "EncodingQueue", () => ai, e => ai = e); var Xs = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), ai = function (e) { Xs(t, e); function t() { var r = e.call(this) || this; return r.fileReader = new FileReader, r._queue = [], r._processing = !1, r.fileReader.onload = function (n) { r._processing = !1, n.target && r.emit("done", n.target.result), r.doNextTask() }, r.fileReader.onerror = function (n) { R.default.error("EncodingQueue error:", n), r._processing = !1, r.destroy(), r.emit("error", n) }, r } return Object.defineProperty(t.prototype, "queue", { get: function () { return this._queue }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "size", { get: function () { return this.queue.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "processing", { get: function () { return this._processing }, enumerable: !1, configurable: !0 }), t.prototype.enque = function (r) { this.queue.push(r), !this.processing && this.doNextTask() }, t.prototype.destroy = function () { this.fileReader.abort(), this._queue = [] }, t.prototype.doNextTask = function () { this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift()))) }, t }(At.EventEmitter), Qs = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Zs = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, oi = function (e) { Qs(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a.stringify = JSON.stringify, a.parse = JSON.parse, a._buffer = [], a._bufferSize = 0, a._buffering = !1, a._chunkedData = {}, a._encodingQueue = new wa.EncodingQueue, a.connectionId = a.options.connectionId || t.ID_PREFIX + F.randomToken(), a.label = a.options.label || a.connectionId, a.serialization = a.options.serialization || Se.Binary, a.reliable = !!a.options.reliable, a._encodingQueue.on("done", function (o) { a._bufferedSend(o) }), a._encodingQueue.on("error", function () { R.default.error("DC#".concat(a.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), a.close() }), a._negotiator = new kn.Negotiator(a), a._negotiator.startConnection(a.options._payload || { originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return ve.Data }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dataChannel", { get: function () { return this._dc }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "bufferSize", { get: function () { return this._bufferSize }, enumerable: !1, configurable: !0 }), t.prototype.initialize = function (r) { this._dc = r, this._configureDataChannel() }, t.prototype._configureDataChannel = function () { var r = this; (!F.supports.binaryBlob || F.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function () { R.default.log("DC#".concat(r.connectionId, " dc connection success")), r._open = !0, r.emit("open") }, this.dataChannel.onmessage = function (n) { R.default.log("DC#".concat(r.connectionId, " dc onmessage:"), n.data), r._handleDataMessage(n) }, this.dataChannel.onclose = function () { R.default.log("DC#".concat(r.connectionId, " dc closed for:"), r.peer), r.close() } }, t.prototype._handleDataMessage = function (r) { var n = this, i = r.data, a = i.constructor, o = this.serialization === Se.Binary || this.serialization === Se.BinaryUTF8, u = i; if (o) { if (a === Blob) { F.blobToArrayBuffer(i, function (c) { var f = F.unpack(c); n.emit("data", f) }); return } else if (a === ArrayBuffer) u = F.unpack(i); else if (a === String) { var s = F.binaryStringToArrayBuffer(i); u = F.unpack(s) } } else this.serialization === Se.JSON && (u = this.parse(i)); if (u.__peerData) { this._handleChunk(u); return } e.prototype.emit.call(this, "data", u) }, t.prototype._handleChunk = function (r) { var n = r.__peerData, i = this._chunkedData[n] || { data: [], count: 0, total: r.total }; if (i.data[r.n] = r.data, i.count++, this._chunkedData[n] = i, i.total === i.count) { delete this._chunkedData[n]; var a = new Blob(i.data); this._handleDataMessage({ data: a }) } }, t.prototype.close = function () { this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.prototype.send = function (r, n) { if (!this.open) { e.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages.")); return } if (this.serialization === Se.JSON) this._bufferedSend(this.stringify(r)); else if (this.serialization === Se.Binary || this.serialization === Se.BinaryUTF8) { var i = F.pack(r); if (!n && i.size > F.chunkedMTU) { this._sendChunks(i); return } F.supports.binaryBlob ? this._bufferedSend(i) : this._encodingQueue.enque(i) } else this._bufferedSend(r) }, t.prototype._bufferedSend = function (r) { (this._buffering || !this._trySend(r)) && (this._buffer.push(r), this._bufferSize = this._buffer.length) }, t.prototype._trySend = function (r) { var n = this; if (!this.open) return !1; if (this.dataChannel.bufferedAmount > t.MAX_BUFFERED_AMOUNT) return this._buffering = !0, setTimeout(function () { n._buffering = !1, n._tryBuffer() }, 50), !1; try { this.dataChannel.send(r) } catch (i) { return R.default.error("DC#:".concat(this.connectionId, " Error when sending:"), i), this._buffering = !0, this.close(), !1 } return !0 }, t.prototype._tryBuffer = function () { if (!!this.open && this._buffer.length !== 0) { var r = this._buffer[0]; this._trySend(r) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer()) } }, t.prototype._sendChunks = function (r) { var n, i, a = F.chunk(r); R.default.log("DC#".concat(this.connectionId, " Try to send ").concat(a.length, " chunks...")); try { for (var o = Zs(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; this.send(s, !0) } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.handleMessage = function (r) { var n = r.payload; switch (r.type) { case q.Answer: this._negotiator.handleSDP(r.type, n.sdp); break; case q.Candidate: this._negotiator.handleCandidate(n.candidate); break; default: R.default.warn("Unrecognized message type:", r.type, "from peer:", this.peer); break } }, t.ID_PREFIX = "dc_", t.MAX_BUFFERED_AMOUNT = 8388608, t }(Pn.BaseConnection), Ia = {}; be(Ia, "API", () => ui, e => ui = e); var si = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(f) { try { c(n.next(f)) } catch (l) { o(l) } } function s(f) { try { c(n.throw(f)) } catch (l) { o(l) } } function c(f) { f.done ? a(f.value) : i(f.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, ci = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (f) { return s([c, f]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (f) { c = [6, f], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, ui = function () { function e(t) { this._options = t } return e.prototype._buildRequest = function (t) { var r = this._options.secure ? "https" : "http", n = this._options, i = n.host, a = n.port, o = n.path, u = n.key, s = new URL("".concat(r, "://").concat(i, ":").concat(a).concat(o).concat(u, "/").concat(t)); return s.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), s.searchParams.set("version", Tn.version), fetch(s.href, { referrerPolicy: this._options.referrerPolicy }) }, e.prototype.retrieveId = function () { return si(this, void 0, Promise, function () { var t, r, n; return ci(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("id")]; case 1: if (t = i.sent(), t.status !== 200) throw new Error("Error. Status:".concat(t.status)); return [2, t.text()]; case 2: throw r = i.sent(), R.default.error("Error retrieving ID", r), n = "", this._options.path === "/" && this._options.host !== F.CLOUD_HOST && (n = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + n); case 3: return [2] } }) }) }, e.prototype.listAllPeers = function () { return si(this, void 0, Promise, function () { var t, r, n; return ci(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("peers")]; case 1: if (t = i.sent(), t.status !== 200) throw t.status === 401 ? (r = "", this._options.host === F.CLOUD_HOST ? r = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : r = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + r)) : new Error("Error. Status:".concat(t.status)); return [2, t.json()]; case 2: throw n = i.sent(), R.default.error("Error retrieving list peers", n), new Error("Could not get list peers from the server." + n); case 3: return [2] } }) }) }, e }(), ec = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), gt = function () { return gt = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, gt.apply(this, arguments) }, ct = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, tc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, fi = function (e) { ec(t, e); function t(r, n) { var i = e.call(this) || this; i._id = null, i._lastServerId = null, i._destroyed = !1, i._disconnected = !1, i._open = !1, i._connections = new Map, i._lostMessages = new Map; var a; return r && r.constructor == Object ? n = r : r && (a = r.toString()), n = gt({ debug: 0, host: F.CLOUD_HOST, port: F.CLOUD_PORT, path: "/", key: t.DEFAULT_KEY, token: F.randomToken(), config: F.defaultConfig, referrerPolicy: "strict-origin-when-cross-origin" }, n), i._options = n, i._options.host === "/" && (i._options.host = window.location.hostname), i._options.path && (i._options.path[0] !== "/" && (i._options.path = "/" + i._options.path), i._options.path[i._options.path.length - 1] !== "/" && (i._options.path += "/")), i._options.secure === void 0 && i._options.host !== F.CLOUD_HOST ? i._options.secure = F.isSecure() : i._options.host == F.CLOUD_HOST && (i._options.secure = !0), i._options.logFunction && R.default.setLogFunction(i._options.logFunction), R.default.logLevel = i._options.debug || 0, i._api = new Ia.API(n), i._socket = i._createServerConnection(), !F.supports.audioVideo && !F.supports.data ? (i._delayedAbort(G.BrowserIncompatible, "The current browser does not support WebRTC"), i) : !!a && !F.validateId(a) ? (i._delayedAbort(G.InvalidID, 'ID "'.concat(a, '" is invalid')), i) : (a ? i._initialize(a) : i._api.retrieveId().then(function (o) { return i._initialize(o) }).catch(function (o) { return i._abort(G.ServerError, o) }), i) } return Object.defineProperty(t.prototype, "id", { get: function () { return this._id }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "options", { get: function () { return this._options }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "socket", { get: function () { return this._socket }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "connections", { get: function () { var r, n, i = Object.create(null); try { for (var a = ct(this._connections), o = a.next(); !o.done; o = a.next()) { var u = tc(o.value, 2), s = u[0], c = u[1]; i[s] = c } } catch (f) { r = { error: f } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } return i }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "destroyed", { get: function () { return this._destroyed }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "disconnected", { get: function () { return this._disconnected }, enumerable: !1, configurable: !0 }), t.prototype._createServerConnection = function () { var r = this, n = new Oa.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval); return n.on(Re.Message, function (i) { r._handleMessage(i) }), n.on(Re.Error, function (i) { r._abort(G.SocketError, i) }), n.on(Re.Disconnected, function () { r.disconnected || (r.emitError(G.Network, "Lost connection to server."), r.disconnect()) }), n.on(Re.Close, function () { r.disconnected || r._abort(G.SocketClosed, "Underlying socket is already closed.") }), n }, t.prototype._initialize = function (r) { this._id = r, this.socket.start(r, this._options.token) }, t.prototype._handleMessage = function (r) { var n, i, a = r.type, o = r.payload, u = r.src; switch (a) { case q.Open: this._lastServerId = this.id, this._open = !0, this.emit("open", this.id); break; case q.Error: this._abort(G.ServerError, o.msg); break; case q.IdTaken: this._abort(G.UnavailableID, 'ID "'.concat(this.id, '" is taken')); break; case q.InvalidKey: this._abort(G.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid')); break; case q.Leave: R.default.log("Received leave message from ".concat(u)), this._cleanupPeer(u), this._connections.delete(u); break; case q.Expire: this.emitError(G.PeerUnavailable, "Could not connect to peer ".concat(u)); break; case q.Offer: var d = o.connectionId, h = this.getConnection(u, d); if (h && (h.close(), R.default.warn("Offer received for existing Connection ID:".concat(d))), o.type === ve.Media) { var s = new Zr.MediaConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata }); h = s, this._addConnection(u, h), this.emit("call", s) } else if (o.type === ve.Data) { var c = new en.DataConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata, label: o.label, serialization: o.serialization, reliable: o.reliable }); h = c, this._addConnection(u, h), this.emit("connection", c) } else { R.default.warn("Received malformed connection type:".concat(o.type)); return } var f = this._getMessages(d); try { for (var l = ct(f), p = l.next(); !p.done; p = l.next()) { var v = p.value; h.handleMessage(v) } } catch (_) { n = { error: _ } } finally { try { p && !p.done && (i = l.return) && i.call(l) } finally { if (n) throw n.error } } break; default: if (!o) { R.default.warn("You received a malformed message from ".concat(u, " of type ").concat(a)); return } var d = o.connectionId, h = this.getConnection(u, d); h && h.peerConnection ? h.handleMessage(r) : d ? this._storeMessage(d, r) : R.default.warn("You received an unrecognized message:", r); break } }, t.prototype._storeMessage = function (r, n) { this._lostMessages.has(r) || this._lostMessages.set(r, []), this._lostMessages.get(r).push(n) }, t.prototype._getMessages = function (r) { var n = this._lostMessages.get(r); return n ? (this._lostMessages.delete(r), n) : [] }, t.prototype.connect = function (r, n) { if (n === void 0 && (n = {}), this.disconnected) { R.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(G.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } var i = new en.DataConnection(r, this, n); return this._addConnection(r, i), i }, t.prototype.call = function (r, n, i) { if (i === void 0 && (i = {}), this.disconnected) { R.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(G.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } if (!n) { R.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`."); return } var a = new Zr.MediaConnection(r, this, gt(gt({}, i), { _stream: n })); return this._addConnection(r, a), a }, t.prototype._addConnection = function (r, n) { R.default.log("add connection ".concat(n.type, ":").concat(n.connectionId, " to peerId:").concat(r)), this._connections.has(r) || this._connections.set(r, []), this._connections.get(r).push(n) }, t.prototype._removeConnection = function (r) { var n = this._connections.get(r.peer); if (n) { var i = n.indexOf(r); i !== -1 && n.splice(i, 1) } this._lostMessages.delete(r.connectionId) }, t.prototype.getConnection = function (r, n) { var i, a, o = this._connections.get(r); if (!o) return null; try { for (var u = ct(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; if (c.connectionId === n) return c } } catch (f) { i = { error: f } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } return null }, t.prototype._delayedAbort = function (r, n) { var i = this; setTimeout(function () { i._abort(r, n) }, 0) }, t.prototype._abort = function (r, n) { R.default.error("Aborting!"), this.emitError(r, n), this._lastServerId ? this.disconnect() : this.destroy() }, t.prototype.emitError = function (r, n) { R.default.error("Error:", n); var i; typeof n == "string" ? i = new Error(n) : i = n, i.type = r, this.emit("error", i) }, t.prototype.destroy = function () { this.destroyed || (R.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close")) }, t.prototype._cleanup = function () { var r, n; try { for (var i = ct(this._connections.keys()), a = i.next(); !a.done; a = i.next()) { var o = a.value; this._cleanupPeer(o), this._connections.delete(o) } } catch (u) { r = { error: u } } finally { try { a && !a.done && (n = i.return) && n.call(i) } finally { if (r) throw r.error } } this.socket.removeAllListeners() }, t.prototype._cleanupPeer = function (r) { var n, i, a = this._connections.get(r); if (!!a) try { for (var o = ct(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; s.close() } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.disconnect = function () { if (!this.disconnected) { var r = this.id; R.default.log("Disconnect peer with ID:".concat(r)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = r, this._id = null, this.emit("disconnected", r) } }, t.prototype.reconnect = function () { if (this.disconnected && !this.destroyed) R.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId); else { if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed."); if (!this.disconnected && !this.open) R.default.error("In a hurry? We're still trying to make the initial connection!"); else throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!")) } }, t.prototype.listAllPeers = function (r) { var n = this; r === void 0 && (r = function (i) { }), this._api.listAllPeers().then(function (i) { return r(i) }).catch(function (i) { return n._abort(G.ServerError, i) }) }, t.DEFAULT_KEY = "peerjs", t }(At.EventEmitter), rc = xa.Peer; let ke, K, Ve; hs().then(async () => { console.log("database loaded"); let e = await ge.printer.toArray(); if (e.length > 0 && (Ve = e[0]), K = await ge.networking.get("1"), console.log(K), K || (K = new $i("1"), await K.add()), !K.peerID || !K.apiKey) { console.log("Networking conditions not satisfied"), console.log(K); let t = setInterval(async () => { window.peerID && !(K != null && K.peerID) && (K == null || K.save({ peerID: window.peerID }), Ve || (Ve = new Gi(window.peerID), Ve.add())), window.apiKey && (K == null || K.save({ apiKey: window.apiKey })), (K == null ? void 0 : K.peerID) && K.apiKey && (clearInterval(t), li()) }, 1e3) } else console.log("Networking conditions satisfied"), li() }); async function li() { console.log("startup functions called"), ke = new rc(K.peerID), nc(), await vs(), await ms(), await ys() } function nc() { ke.on("open", function (e) { console.log("Connected to peer server with id:" + e) }), ke.on("connection", function (e) { console.log("Connected with peer:" + e.peer), e.on("data", function (t) { console.log("Received Label: " + e.label), Cs(t, e.peer, e.label, e.metadata), e.close() }) }), ke.on("disconnected", function () { console.log("Disconnected from signaling server, reconnecting..."), ke.reconnect() }), ke.on("close", function () { console.log("Peer destroyed, cannot reconnect") }), ke.on("error", function (e) { console.error(e) }) }
