var Na = Object.defineProperty; var Ua = (e, t, r) => t in e ? Na(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; var R = (e, t, r) => (Ua(e, typeof t != "symbol" ? t + "" : t, r), r); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function r(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerpolicy && (a.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? a.credentials = "include" : i.crossorigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function n(i) { if (i.ep) return; i.ep = !0; const a = r(i); fetch(i.href, a) } })(); var re = (e => (e.syncAllRequest = "1", e.syncAllResponse = "2", e.profileChanged = "3", e.positionChanged = "57", e.positionChangedResponse = "4", e.positionChangedRequest = "53", e.positionChangedStop = "54", e.cameraStreamRequest = "5", e.cameraStreamResponse = "34", e.cameraStreamStop = "44", e.temperatureStreamRequest = "6", e.temperatureStreamResponse = "35", e.temperatureStreamStop = "43", e.bedLevelingRequest = "7", e.bedLevelingResponse = "8", e.terminalRequest = "9", e.terminalResponse = "10", e.terminalStop = "42", e.filamentModified = "58", e.filamentAssigned = "11", e.filamentRemoved = "12", e.filamentModifiedResponse = "40", e.filamentModifiedRequest = "52", e.filamentModifiedStop = "55", e.jobCreated = "13", e.jobFile = "41", e.jobDone = "14", e.jobCancelled = "15", e.jobFailed = "16", e.jobDeleted = "17", e.jobPause = "25", e.jobResume = "26", e.jobPrinting = "37", e.jobFilamentModified = "30", e.currentJobUpdatesResponse = "49", e.currentJobUpdatesRequest = "51", e.currentJobUpdatesStop = "56", e.jobRankChange = "18", e.actionCreated = "19", e.actionModified = "20", e.actionExecuted = "21", e.actionDeleted = "22", e.executeCustomGcode = "23", e.emergencyStop = "24", e.connectPrinter = "27", e.disconnectPrinter = "28", e.connectionOptionsChanged = "38", e.printerStateChanged = "39", e.refreshConnectionOptions = "45", e.filamentExtrude = "46", e.targetTool = "47", e.targetBed = "48", e.handshakeRequest = "50", e.handshakeResponse = "31", e.queuePaused = "29", e))(re || {}); async function za() { try { return await (await fetch("http://localhost:5000/api/printerprofiles/_default", { method: "GET", headers: { "X-API-KEY": G.apiKey } })).json() } catch (e) { return console.error(e), {} } } async function $a() { try { return await (await fetch("http://localhost:5000/api/connection", { method: "GET", headers: { "X-API-KEY": G.apiKey } })).json() } catch (e) { return console.error(e), {} } } async function Ga() { try { let t = await fetch("http://localhost:5000/api/printer?history=true&limit=" + 50, { method: "GET", headers: { "X-API-KEY": G.apiKey } }); return t.ok ? await t.json() : { state: { text: "Offline" } } } catch { return { state: { text: "Offline" } } } } function Ja(e, t, r, n) { let i = { command: "connect", save: n, autoconnect: r }; e.toLowerCase().includes("auto") || (i.port = e), t.toLowerCase().includes("auto") || (i.baudrate = parseInt(t)), fetch("http://localhost:5000/api/connection", { method: "POST", headers: { "X-API-KEY": G.apiKey, "Content-Type": "application/json" }, body: JSON.stringify(i) }) } function Va() { fetch("http://localhost:5000/api/connection", { method: "POST", headers: { "X-API-KEY": G.apiKey, "Content-Type": "application/json" }, body: JSON.stringify({ command: "disconnect" }) }) } async function Ha(e, t) { let r = new Headers; r.append("X-API-KEY", G.apiKey); let n = new File([e], t.jobName + ".gcode"), i = new FormData; i.append("file", n, t.jobName + ".gcode"), await fetch("http://localhost:5000/api/files/local", { method: "POST", headers: r, body: i }) } function Wa(e) { fetch("http://localhost:5000/api/files/local/" + encodeURIComponent(e), { method: "POST", headers: { "X-API-KEY": G.apiKey, "Content-Type": "application/json" }, body: JSON.stringify({ command: "select", print: !0 }) }) } async function vi() { return (await fetch("http://localhost:5000/api/job", { method: "GET", headers: { "X-API-KEY": G.apiKey } })).json() } function an(e, t, r) { const n = { label: r, metadata: e, serialization: "json", reliable: !0 }, i = ye.connect(e, n); i.on("open", function () { i.send(JSON.stringify(t)), console.log("Sent:", t) }), i.on("error", function (a) { console.error("Could not send data: " + a) }) }/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var M = function () { return M = Object.assign || function (t) { for (var r, n = 1, i = arguments.length; n < i; n++) { r = arguments[n]; for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]) } return t }, M.apply(this, arguments) }; function Pr(e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) } var U = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, V = Object.keys, ie = Array.isArray; typeof Promise < "u" && !U.Promise && (U.Promise = Promise); function ce(e, t) { return typeof t != "object" || V(t).forEach(function (r) { e[r] = t[r] }), e } var Ct = Object.getPrototypeOf, qa = {}.hasOwnProperty; function ve(e, t) { return qa.call(e, t) } function nt(e, t) { typeof t == "function" && (t = t(Ct(e))), (typeof Reflect > "u" ? V : Reflect.ownKeys)(t).forEach(function (r) { Oe(e, r, t[r]) }) } var mi = Object.defineProperty; function Oe(e, t, r, n) { mi(e, t, ce(r && ve(r, "get") && typeof r.get == "function" ? { get: r.get, set: r.set, configurable: !0 } : { value: r, configurable: !0, writable: !0 }, n)) } function it(e) { return { from: function (t) { return e.prototype = Object.create(t.prototype), Oe(e.prototype, "constructor", e), { extend: nt.bind(null, e.prototype) } } } } var Ya = Object.getOwnPropertyDescriptor; function on(e, t) { var r = Ya(e, t), n; return r || (n = Ct(e)) && on(n, t) } var Xa = [].slice; function lr(e, t, r) { return Xa.call(e, t, r) } function yi(e, t) { return t(e) } function lt(e) { if (!e) throw new Error("Assertion Failed") } function gi(e) { U.setImmediate ? setImmediate(e) : setTimeout(e, 0) } function bi(e, t) { return e.reduce(function (r, n, i) { var a = t(n, i); return a && (r[a[0]] = a[1]), r }, {}) } function Qa(e, t, r) { try { e.apply(null, r) } catch (n) { t && t(n) } } function we(e, t) { if (ve(e, t)) return e[t]; if (!t) return e; if (typeof t != "string") { for (var r = [], n = 0, i = t.length; n < i; ++n) { var a = we(e, t[n]); r.push(a) } return r } var o = t.indexOf("."); if (o !== -1) { var u = e[t.substr(0, o)]; return u === void 0 ? void 0 : we(u, t.substr(o + 1)) } } function be(e, t, r) { if (!(!e || t === void 0) && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) { lt(typeof r != "string" && "length" in r); for (var n = 0, i = t.length; n < i; ++n)be(e, t[n], r[n]) } else { var a = t.indexOf("."); if (a !== -1) { var o = t.substr(0, a), u = t.substr(a + 1); if (u === "") r === void 0 ? ie(e) && !isNaN(parseInt(o)) ? e.splice(o, 1) : delete e[o] : e[o] = r; else { var s = e[o]; (!s || !ve(e, o)) && (s = e[o] = {}), be(s, u, r) } } else r === void 0 ? ie(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r } } function Za(e, t) { typeof t == "string" ? be(e, t, void 0) : "length" in t && [].map.call(t, function (r) { be(e, r, void 0) }) } function _i(e) { var t = {}; for (var r in e) ve(e, r) && (t[r] = e[r]); return t } var eo = [].concat; function Ci(e) { return eo.apply([], e) } var Si = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Ci([8, 16, 32, 64].map(function (e) { return ["Int", "Uint", "Float"].map(function (t) { return t + e + "Array" }) }))).filter(function (e) { return U[e] }), to = Si.map(function (e) { return U[e] }); bi(Si, function (e) { return [e, !0] }); var Fe = null; function Dt(e) { Fe = typeof WeakMap < "u" && new WeakMap; var t = Er(e); return Fe = null, t } function Er(e) { if (!e || typeof e != "object") return e; var t = Fe && Fe.get(e); if (t) return t; if (ie(e)) { t = [], Fe && Fe.set(e, t); for (var r = 0, n = e.length; r < n; ++r)t.push(Er(e[r])) } else if (to.indexOf(e.constructor) >= 0) t = e; else { var i = Ct(e); t = i === Object.prototype ? {} : Object.create(i), Fe && Fe.set(e, t); for (var a in e) ve(e, a) && (t[a] = Er(e[a])) } return t } var ro = {}.toString; function Rr(e) { return ro.call(e).slice(8, -1) } var xr = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", no = typeof xr == "symbol" ? function (e) { var t; return e != null && (t = e[xr]) && t.apply(e) } : function () { return null }, et = {}; function Ee(e) { var t, r, n, i; if (arguments.length === 1) { if (ie(e)) return e.slice(); if (this === et && typeof e == "string") return [e]; if (i = no(e)) { for (r = []; n = i.next(), !n.done;)r.push(n.value); return r } if (e == null) return [e]; if (t = e.length, typeof t == "number") { for (r = new Array(t); t--;)r[t] = e[t]; return r } return [e] } for (t = arguments.length, r = new Array(t); t--;)r[t] = arguments[t]; return r } var sn = typeof Symbol < "u" ? function (e) { return e[Symbol.toStringTag] === "AsyncFunction" } : function () { return !1 }, Ce = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href); function Ti(e, t) { Ce = e, ki = t } var ki = function () { return !0 }, io = !new Error("").stack; function Xe() { if (io) try { throw Xe.arguments, new Error } catch (e) { return e } return new Error } function Dr(e, t) {
    var r = e.stack; return r ? (t = t || 0, r.indexOf(e.name) === 0 && (t += (e.name + e.message).split(`
`).length), r.split(`
`).slice(t).filter(ki).map(function (n) {
        return `
`+ n
    }).join("")) : ""
} var ao = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"], Pi = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], cn = ao.concat(Pi), oo = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" }; function at(e, t) { this._e = Xe(), this.name = e, this.message = t } it(at).from(Error).extend({ stack: { get: function () { return this._stack || (this._stack = this.name + ": " + this.message + Dr(this._e, 2)) } }, toString: function () { return this.name + ": " + this.message } }); function Ei(e, t) {
    return e + ". Errors: " + Object.keys(t).map(function (r) { return t[r].toString() }).filter(function (r, n, i) { return i.indexOf(r) === n }).join(`
`)
} function er(e, t, r, n) { this._e = Xe(), this.failures = t, this.failedKeys = n, this.successCount = r, this.message = Ei(e, t) } it(er).from(at); function yt(e, t) { this._e = Xe(), this.name = "BulkError", this.failures = Object.keys(t).map(function (r) { return t[r] }), this.failuresByPos = t, this.message = Ei(e, t) } it(yt).from(at); var un = cn.reduce(function (e, t) { return e[t] = t + "Error", e }, {}), so = at, I = cn.reduce(function (e, t) {
    var r = t + "Error"; function n(i, a) {
        this._e = Xe(), this.name = r, i ? typeof i == "string" ? (this.message = "" + i + (a ? `
 `+ a : ""), this.inner = a || null) : typeof i == "object" && (this.message = i.name + " " + i.message, this.inner = i) : (this.message = oo[t] || r, this.inner = null)
    } return it(n).from(so), e[t] = n, e
}, {}); I.Syntax = SyntaxError; I.Type = TypeError; I.Range = RangeError; var wn = Pi.reduce(function (e, t) { return e[t + "Error"] = I[t], e }, {}); function co(e, t) { if (!e || e instanceof at || e instanceof TypeError || e instanceof SyntaxError || !e.name || !wn[e.name]) return e; var r = new wn[e.name](t || e.message, e); return "stack" in e && Oe(r, "stack", { get: function () { return this.inner.stack } }), r } var pr = cn.reduce(function (e, t) { return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = I[t]), e }, {}); pr.ModifyError = er; pr.DexieError = at; pr.BulkError = yt; function L() { } function wt(e) { return e } function uo(e, t) { return e == null || e === wt ? t : function (r) { return t(e(r)) } } function qe(e, t) { return function () { e.apply(this, arguments), t.apply(this, arguments) } } function fo(e, t) { return e === L ? t : function () { var r = e.apply(this, arguments); r !== void 0 && (arguments[0] = r); var n = this.onsuccess, i = this.onerror; this.onsuccess = null, this.onerror = null; var a = t.apply(this, arguments); return n && (this.onsuccess = this.onsuccess ? qe(n, this.onsuccess) : n), i && (this.onerror = this.onerror ? qe(i, this.onerror) : i), a !== void 0 ? a : r } } function lo(e, t) { return e === L ? t : function () { e.apply(this, arguments); var r = this.onsuccess, n = this.onerror; this.onsuccess = this.onerror = null, t.apply(this, arguments), r && (this.onsuccess = this.onsuccess ? qe(r, this.onsuccess) : r), n && (this.onerror = this.onerror ? qe(n, this.onerror) : n) } } function po(e, t) { return e === L ? t : function (r) { var n = e.apply(this, arguments); ce(r, n); var i = this.onsuccess, a = this.onerror; this.onsuccess = null, this.onerror = null; var o = t.apply(this, arguments); return i && (this.onsuccess = this.onsuccess ? qe(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? qe(a, this.onerror) : a), n === void 0 ? o === void 0 ? void 0 : o : ce(n, o) } } function ho(e, t) { return e === L ? t : function () { return t.apply(this, arguments) === !1 ? !1 : e.apply(this, arguments) } } function fn(e, t) { return e === L ? t : function () { var r = e.apply(this, arguments); if (r && typeof r.then == "function") { for (var n = this, i = arguments.length, a = new Array(i); i--;)a[i] = arguments[i]; return r.then(function () { return t.apply(n, a) }) } return t.apply(this, arguments) } } var St = {}, vo = 100, mo = 20, Ri = 100, ln = typeof Promise > "u" ? [] : function () { var e = Promise.resolve(); if (typeof crypto > "u" || !crypto.subtle) return [e, Ct(e), e]; var t = crypto.subtle.digest("SHA-512", new Uint8Array([0])); return [t, Ct(t), e] }(), wr = ln[0], tr = ln[1], Or = ln[2], xi = tr && tr.then, Gt = wr && wr.constructor, pn = !!Or, Ir = !1, yo = Or ? function () { Or.then(jt) } : U.setImmediate ? setImmediate.bind(null, jt) : U.MutationObserver ? function () { var e = document.createElement("div"); new MutationObserver(function () { jt(), e = null }).observe(e, { attributes: !0 }), e.setAttribute("i", "1") } : function () { setTimeout(jt, 0) }, Tt = function (e, t) { pt.push([e, t]), rr && (yo(), rr = !1) }, Ar = !0, rr = !0, He = [], Jt = [], Mr = null, Br = wt, rt = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: An, pgp: !1, env: {}, finalize: function () { this.unhandleds.forEach(function (e) { try { An(e[0], e[1]) } catch { } }) } }, D = rt, pt = [], We = 0, Vt = []; function E(e) { if (typeof this != "object") throw new TypeError("Promises must be constructed via new"); this._listeners = [], this.onuncatched = L, this._lib = !1; var t = this._PSD = D; if (Ce && (this._stackHolder = Xe(), this._prev = null, this._numPrev = 0), typeof e != "function") { if (e !== St) throw new TypeError("Not a function"); this._state = arguments[1], this._value = arguments[2], this._state === !1 && Fr(this, this._value); return } this._state = null, this._value = null, ++t.ref, wi(this, e) } var jr = { get: function () { var e = D, t = nr; function r(n, i) { var a = this, o = !e.global && (e !== D || t !== nr), u = o && !Ie(), s = new E(function (c, f) { dn(a, new Di(ar(n, e, o, u), ar(i, e, o, u), c, f, e)) }); return Ce && Ai(s, this), s } return r.prototype = St, r }, set: function (e) { Oe(this, "then", e && e.prototype === St ? jr : { get: function () { return e }, set: jr.set }) } }; nt(E.prototype, {
    then: jr, _then: function (e, t) { dn(this, new Di(null, null, e, t, D)) }, catch: function (e) { if (arguments.length === 1) return this.then(null, e); var t = arguments[0], r = arguments[1]; return typeof t == "function" ? this.then(null, function (n) { return n instanceof t ? r(n) : Ht(n) }) : this.then(null, function (n) { return n && n.name === t ? r(n) : Ht(n) }) }, finally: function (e) { return this.then(function (t) { return e(), t }, function (t) { return e(), Ht(t) }) }, stack: {
        get: function () {
            if (this._stack) return this._stack; try {
                Ir = !0; var e = Ii(this, [], mo), t = e.join(`
From previous: `); return this._state !== null && (this._stack = t), t
            } finally { Ir = !1 }
        }
    }, timeout: function (e, t) { var r = this; return e < 1 / 0 ? new E(function (n, i) { var a = setTimeout(function () { return i(new I.Timeout(t)) }, e); r.then(n, i).finally(clearTimeout.bind(null, a)) }) : this }
}); typeof Symbol < "u" && Symbol.toStringTag && Oe(E.prototype, Symbol.toStringTag, "Dexie.Promise"); rt.env = Mi(); function Di(e, t, r, n, i) { this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = r, this.reject = n, this.psd = i } nt(E, { all: function () { var e = Ee.apply(null, arguments).map(ir); return new E(function (t, r) { e.length === 0 && t([]); var n = e.length; e.forEach(function (i, a) { return E.resolve(i).then(function (o) { e[a] = o, --n || t(e) }, r) }) }) }, resolve: function (e) { if (e instanceof E) return e; if (e && typeof e.then == "function") return new E(function (r, n) { e.then(r, n) }); var t = new E(St, !0, e); return Ai(t, Mr), t }, reject: Ht, race: function () { var e = Ee.apply(null, arguments).map(ir); return new E(function (t, r) { e.map(function (n) { return E.resolve(n).then(t, r) }) }) }, PSD: { get: function () { return D }, set: function (e) { return D = e } }, totalEchoes: { get: function () { return nr } }, newPSD: Le, usePSD: st, scheduler: { get: function () { return Tt }, set: function (e) { Tt = e } }, rejectionMapper: { get: function () { return Br }, set: function (e) { Br = e } }, follow: function (e, t) { return new E(function (r, n) { return Le(function (i, a) { var o = D; o.unhandleds = [], o.onunhandled = a, o.finalize = qe(function () { var u = this; bo(function () { u.unhandleds.length === 0 ? i() : a(u.unhandleds[0]) }) }, o.finalize), e() }, t, r, n) }) } }); Gt && (Gt.allSettled && Oe(E, "allSettled", function () { var e = Ee.apply(null, arguments).map(ir); return new E(function (t) { e.length === 0 && t([]); var r = e.length, n = new Array(r); e.forEach(function (i, a) { return E.resolve(i).then(function (o) { return n[a] = { status: "fulfilled", value: o } }, function (o) { return n[a] = { status: "rejected", reason: o } }).then(function () { return --r || t(n) }) }) }) }), Gt.any && typeof AggregateError < "u" && Oe(E, "any", function () { var e = Ee.apply(null, arguments).map(ir); return new E(function (t, r) { e.length === 0 && r(new AggregateError([])); var n = e.length, i = new Array(n); e.forEach(function (a, o) { return E.resolve(a).then(function (u) { return t(u) }, function (u) { i[o] = u, --n || r(new AggregateError(i)) }) }) }) })); function wi(e, t) { try { t(function (r) { if (e._state === null) { if (r === e) throw new TypeError("A promise cannot be resolved with itself."); var n = e._lib && Ot(); r && typeof r.then == "function" ? wi(e, function (i, a) { r instanceof E ? r._then(i, a) : r.then(i, a) }) : (e._state = !0, e._value = r, Oi(e)), n && It() } }, Fr.bind(null, e)) } catch (r) { Fr(e, r) } } function Fr(e, t) { if (Jt.push(t), e._state === null) { var r = e._lib && Ot(); t = Br(t), e._state = !1, e._value = t, Ce && t !== null && typeof t == "object" && !t._promise && Qa(function () { var n = on(t, "stack"); t._promise = e, Oe(t, "stack", { get: function () { return Ir ? n && (n.get ? n.get.apply(t) : n.value) : e.stack } }) }), _o(e), Oi(e), r && It() } } function Oi(e) { var t = e._listeners; e._listeners = []; for (var r = 0, n = t.length; r < n; ++r)dn(e, t[r]); var i = e._PSD; --i.ref || i.finalize(), We === 0 && (++We, Tt(function () { --We === 0 && hn() }, [])) } function dn(e, t) { if (e._state === null) { e._listeners.push(t); return } var r = e._state ? t.onFulfilled : t.onRejected; if (r === null) return (e._state ? t.resolve : t.reject)(e._value); ++t.psd.ref, ++We, Tt(go, [r, e, t]) } function go(e, t, r) { try { Mr = t; var n, i = t._value; t._state ? n = e(i) : (Jt.length && (Jt = []), n = e(i), Jt.indexOf(i) === -1 && Co(t)), r.resolve(n) } catch (a) { r.reject(a) } finally { Mr = null, --We === 0 && hn(), --r.psd.ref || r.psd.finalize() } } function Ii(e, t, r) { if (t.length === r) return t; var n = ""; if (e._state === !1) { var i = e._value, a, o; i != null ? (a = i.name || "Error", o = i.message || i, n = Dr(i, 0)) : (a = i, o = ""), t.push(a + (o ? ": " + o : "") + n) } return Ce && (n = Dr(e._stackHolder, 2), n && t.indexOf(n) === -1 && t.push(n), e._prev && Ii(e._prev, t, r)), t } function Ai(e, t) { var r = t ? t._numPrev + 1 : 0; r < vo && (e._prev = t, e._numPrev = r) } function jt() { Ot() && It() } function Ot() { var e = Ar; return Ar = !1, rr = !1, e } function It() { var e, t, r; do for (; pt.length > 0;)for (e = pt, pt = [], r = e.length, t = 0; t < r; ++t) { var n = e[t]; n[0].apply(null, n[1]) } while (pt.length > 0); Ar = !0, rr = !0 } function hn() { var e = He; He = [], e.forEach(function (n) { n._PSD.onunhandled.call(null, n._value, n) }); for (var t = Vt.slice(0), r = t.length; r;)t[--r]() } function bo(e) { function t() { e(), Vt.splice(Vt.indexOf(t), 1) } Vt.push(t), ++We, Tt(function () { --We === 0 && hn() }, []) } function _o(e) { He.some(function (t) { return t._value === e._value }) || He.push(e) } function Co(e) { for (var t = He.length; t;)if (He[--t]._value === e._value) { He.splice(t, 1); return } } function Ht(e) { return new E(St, !1, e) } function $(e, t) { var r = D; return function () { var n = Ot(), i = D; try { return Ne(r, !0), e.apply(this, arguments) } catch (a) { t && t(a) } finally { Ne(i, !1), n && It() } } } var ne = { awaits: 0, echoes: 0, id: 0 }, So = 0, Wt = [], mr = 0, nr = 0, To = 0; function Le(e, t, r, n) { var i = D, a = Object.create(i); a.parent = i, a.ref = 0, a.global = !1, a.id = ++To; var o = rt.env; a.env = pn ? { Promise: E, PromiseProp: { value: E, configurable: !0, writable: !0 }, all: E.all, race: E.race, allSettled: E.allSettled, any: E.any, resolve: E.resolve, reject: E.reject, nthen: On(o.nthen, a), gthen: On(o.gthen, a) } : {}, t && ce(a, t), ++i.ref, a.finalize = function () { --this.parent.ref || this.parent.finalize() }; var u = st(a, e, r, n); return a.ref === 0 && a.finalize(), u } function ot() { return ne.id || (ne.id = ++So), ++ne.awaits, ne.echoes += Ri, ne.id } function Ie() { return ne.awaits ? (--ne.awaits === 0 && (ne.id = 0), ne.echoes = ne.awaits * Ri, !0) : !1 } ("" + xi).indexOf("[native code]") === -1 && (ot = Ie = L); function ir(e) { return ne.echoes && e && e.constructor === Gt ? (ot(), e.then(function (t) { return Ie(), t }, function (t) { return Ie(), H(t) })) : e } function ko(e) { ++nr, (!ne.echoes || --ne.echoes === 0) && (ne.echoes = ne.id = 0), Wt.push(D), Ne(e, !0) } function Po() { var e = Wt[Wt.length - 1]; Wt.pop(), Ne(e, !1) } function Ne(e, t) { var r = D; if ((t ? ne.echoes && (!mr++ || e !== D) : mr && (!--mr || e !== D)) && Bi(t ? ko.bind(null, e) : Po), e !== D && (D = e, r === rt && (rt.env = Mi()), pn)) { var n = rt.env.Promise, i = e.env; tr.then = i.nthen, n.prototype.then = i.gthen, (r.global || e.global) && (Object.defineProperty(U, "Promise", i.PromiseProp), n.all = i.all, n.race = i.race, n.resolve = i.resolve, n.reject = i.reject, i.allSettled && (n.allSettled = i.allSettled), i.any && (n.any = i.any)) } } function Mi() { var e = U.Promise; return pn ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(U, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject, nthen: tr.then, gthen: e.prototype.then } : {} } function st(e, t, r, n, i) { var a = D; try { return Ne(e, !0), t(r, n, i) } finally { Ne(a, !1) } } function Bi(e) { xi.call(wr, e) } function ar(e, t, r, n) { return typeof e != "function" ? e : function () { var i = D; r && ot(), Ne(t, !0); try { return e.apply(this, arguments) } finally { Ne(i, !1), n && Bi(Ie) } } } function On(e, t) { return function (r, n) { return e.call(this, ar(r, t), ar(n, t)) } } var In = "unhandledrejection"; function An(e, t) { var r; try { r = t.onuncatched(e) } catch { } if (r !== !1) try { var n, i = { promise: t, reason: e }; if (U.document && document.createEvent ? (n = document.createEvent("Event"), n.initEvent(In, !0, !0), ce(n, i)) : U.CustomEvent && (n = new CustomEvent(In, { detail: i }), ce(n, i)), n && U.dispatchEvent && (dispatchEvent(n), !U.PromiseRejectionEvent && U.onunhandledrejection)) try { U.onunhandledrejection(n) } catch { } Ce && n && !n.defaultPrevented && console.warn("Unhandled rejection: " + (e.stack || e)) } catch { } } var H = E.reject; function Kr(e, t, r, n) { if (!e.idbdb || !e._state.openComplete && !D.letThrough && !e._vip) { if (e._state.openComplete) return H(new I.DatabaseClosed(e._state.dbOpenError)); if (!e._state.isBeingOpened) { if (!e._options.autoOpen) return H(new I.DatabaseClosed); e.open().catch(L) } return e._state.dbReadyPromise.then(function () { return Kr(e, t, r, n) }) } else { var i = e._createTransaction(t, r, e._dbSchema); try { i.create(), e._state.PR1398_maxLoop = 3 } catch (a) { return a.name === un.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return Kr(e, t, r, n) })) : H(a) } return i._promise(t, function (a, o) { return Le(function () { return D.trans = i, n(a, o, i) }) }).then(function (a) { return i._completion.then(function () { return a }) }) } } var Mn = "3.2.2", Je = String.fromCharCode(65535), Lr = -1 / 0, Te = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", ji = "String expected.", gt = [], dr = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), Eo = dr, Ro = dr, Fi = function (e) { return !/(dexie\.js|dexie\.min\.js)/.test(e) }, hr = "__dbnames", yr = "readonly", gr = "readwrite"; function Ye(e, t) { return e ? t ? function () { return e.apply(this, arguments) && t.apply(this, arguments) } : e : t } var Ki = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 }; function Ft(e) { return typeof e == "string" && !/\./.test(e) ? function (t) { return t[e] === void 0 && e in t && (t = Dt(t), delete t[e]), t } : function (t) { return t } } var xo = function () { function e() { } return e.prototype._trans = function (t, r, n) { var i = this._tx || D.trans, a = this.name; function o(s, c, f) { if (!f.schema[a]) throw new I.NotFound("Table " + a + " not part of transaction"); return r(f.idbtrans, f) } var u = Ot(); try { return i && i.db === this.db ? i === D.trans ? i._promise(t, o, n) : Le(function () { return i._promise(t, o, n) }, { trans: i, transless: D.transless || D }) : Kr(this.db, t, [this.name], o) } finally { u && It() } }, e.prototype.get = function (t, r) { var n = this; return t && t.constructor === Object ? this.where(t).first(r) : this._trans("readonly", function (i) { return n.core.get({ trans: i, key: t }).then(function (a) { return n.hook.reading.fire(a) }) }).then(r) }, e.prototype.where = function (t) { if (typeof t == "string") return new this.db.WhereClause(this, t); if (ie(t)) return new this.db.WhereClause(this, "[" + t.join("+") + "]"); var r = V(t); if (r.length === 1) return this.where(r[0]).equals(t[r[0]]); var n = this.schema.indexes.concat(this.schema.primKey).filter(function (f) { return f.compound && r.every(function (l) { return f.keyPath.indexOf(l) >= 0 }) && f.keyPath.every(function (l) { return r.indexOf(l) >= 0 }) })[0]; if (n && this.db._maxKey !== Je) return this.where(n.name).equals(n.keyPath.map(function (f) { return t[f] })); !n && Ce && console.warn("The query " + JSON.stringify(t) + " on " + this.name + " would benefit of a " + ("compound index [" + r.join("+") + "]")); var i = this.schema.idxByName, a = this.db._deps.indexedDB; function o(f, l) { try { return a.cmp(f, l) === 0 } catch { return !1 } } var u = r.reduce(function (f, l) { var p = f[0], v = f[1], d = i[l], h = t[l]; return [p || d, p || !d ? Ye(v, d && d.multi ? function (b) { var m = we(b, l); return ie(m) && m.some(function (g) { return o(h, g) }) } : function (b) { return o(h, we(b, l)) }) : v] }, [null, null]), s = u[0], c = u[1]; return s ? this.where(s.name).equals(t[s.keyPath]).filter(c) : n ? this.filter(c) : this.where(r).equals("") }, e.prototype.filter = function (t) { return this.toCollection().and(t) }, e.prototype.count = function (t) { return this.toCollection().count(t) }, e.prototype.offset = function (t) { return this.toCollection().offset(t) }, e.prototype.limit = function (t) { return this.toCollection().limit(t) }, e.prototype.each = function (t) { return this.toCollection().each(t) }, e.prototype.toArray = function (t) { return this.toCollection().toArray(t) }, e.prototype.toCollection = function () { return new this.db.Collection(new this.db.WhereClause(this)) }, e.prototype.orderBy = function (t) { return new this.db.Collection(new this.db.WhereClause(this, ie(t) ? "[" + t.join("+") + "]" : t)) }, e.prototype.reverse = function () { return this.toCollection().reverse() }, e.prototype.mapToClass = function (t) { this.schema.mappedClass = t; var r = function (n) { if (!n) return n; var i = Object.create(t.prototype); for (var a in n) if (ve(n, a)) try { i[a] = n[a] } catch { } return i }; return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook("reading", r), t }, e.prototype.defineClass = function () { function t(r) { ce(this, r) } return this.mapToClass(t) }, e.prototype.add = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Ft(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "add", keys: r != null ? [r] : null, values: [u] }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { be(t, o, s) } catch { } return s }) }, e.prototype.update = function (t, r) { if (typeof t == "object" && !ie(t)) { var n = we(t, this.schema.primKey.keyPath); if (n === void 0) return H(new I.InvalidArgument("Given object does not contain its primary key")); try { typeof r != "function" ? V(r).forEach(function (i) { be(t, i, r[i]) }) : r(t, { value: t, primKey: n }) } catch { } return this.where(":id").equals(n).modify(r) } else return this.where(":id").equals(t).modify(r) }, e.prototype.put = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Ft(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "put", values: [u], keys: r != null ? [r] : null }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { be(t, o, s) } catch { } return s }) }, e.prototype.delete = function (t) { var r = this; return this._trans("readwrite", function (n) { return r.core.mutate({ trans: n, type: "delete", keys: [t] }) }).then(function (n) { return n.numFailures ? E.reject(n.failures[0]) : void 0 }) }, e.prototype.clear = function () { var t = this; return this._trans("readwrite", function (r) { return t.core.mutate({ trans: r, type: "deleteRange", range: Ki }) }).then(function (r) { return r.numFailures ? E.reject(r.failures[0]) : void 0 }) }, e.prototype.bulkGet = function (t) { var r = this; return this._trans("readonly", function (n) { return r.core.getMany({ keys: t, trans: n }).then(function (i) { return i.map(function (a) { return r.hook.reading.fire(a) }) }) }) }, e.prototype.bulkAdd = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, f = s.keyPath; if (f && a) throw new I.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new I.InvalidArgument("Arguments objects and keys must have the same length"); var l = t.length, p = f && c ? t.map(Ft(f)) : t; return i.core.mutate({ trans: u, type: "add", keys: a, values: p, wantResults: o }).then(function (v) { var d = v.numFailures, h = v.results, b = v.lastResult, m = v.failures, g = o ? h : b; if (d === 0) return g; throw new yt(i.name + ".bulkAdd(): " + d + " of " + l + " operations failed", m) }) }) }, e.prototype.bulkPut = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, f = s.keyPath; if (f && a) throw new I.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new I.InvalidArgument("Arguments objects and keys must have the same length"); var l = t.length, p = f && c ? t.map(Ft(f)) : t; return i.core.mutate({ trans: u, type: "put", keys: a, values: p, wantResults: o }).then(function (v) { var d = v.numFailures, h = v.results, b = v.lastResult, m = v.failures, g = o ? h : b; if (d === 0) return g; throw new yt(i.name + ".bulkPut(): " + d + " of " + l + " operations failed", m) }) }) }, e.prototype.bulkDelete = function (t) { var r = this, n = t.length; return this._trans("readwrite", function (i) { return r.core.mutate({ trans: i, type: "delete", keys: t }) }).then(function (i) { var a = i.numFailures, o = i.lastResult, u = i.failures; if (a === 0) return o; throw new yt(r.name + ".bulkDelete(): " + a + " of " + n + " operations failed", u) }) }, e }(); function At(e) { var t = {}, r = function (u, s) { if (s) { for (var c = arguments.length, f = new Array(c - 1); --c;)f[c - 1] = arguments[c]; return t[u].subscribe.apply(null, f), e } else if (typeof u == "string") return t[u] }; r.addEventType = a; for (var n = 1, i = arguments.length; n < i; ++n)a(arguments[n]); return r; function a(u, s, c) { if (typeof u == "object") return o(u); s || (s = ho), c || (c = L); var f = { subscribers: [], fire: c, subscribe: function (l) { f.subscribers.indexOf(l) === -1 && (f.subscribers.push(l), f.fire = s(f.fire, l)) }, unsubscribe: function (l) { f.subscribers = f.subscribers.filter(function (p) { return p !== l }), f.fire = f.subscribers.reduce(s, c) } }; return t[u] = r[u] = f, f } function o(u) { V(u).forEach(function (s) { var c = u[s]; if (ie(c)) a(s, u[s][0], u[s][1]); else if (c === "asap") var f = a(s, wt, function () { for (var p = arguments.length, v = new Array(p); p--;)v[p] = arguments[p]; f.subscribers.forEach(function (d) { gi(function () { d.apply(null, v) }) }) }); else throw new I.InvalidArgument("Invalid event config") }) } } function Mt(e, t) { return it(t).from({ prototype: e }), t } function Do(e) { return Mt(xo.prototype, function (r, n, i) { this.db = e, this._tx = i, this.name = r, this.schema = n, this.hook = e._allTables[r] ? e._allTables[r].hook : At(null, { creating: [fo, L], reading: [uo, wt], updating: [po, L], deleting: [lo, L] }) }) } function Qe(e, t) { return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter) } function br(e, t) { e.filter = Ye(e.filter, t) } function _r(e, t, r) { var n = e.replayFilter; e.replayFilter = n ? function () { return Ye(n(), t()) } : t, e.justLimit = r && !n } function wo(e, t) { e.isMatch = Ye(e.isMatch, t) } function qt(e, t) { if (e.isPrimKey) return t.primaryKey; var r = t.getIndexByKeyPath(e.index); if (!r) throw new I.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed"); return r } function Bn(e, t, r) { var n = qt(e, t.schema); return t.openCursor({ trans: r, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: n, range: e.range } }) } function Kt(e, t, r, n) { var i = e.replayFilter ? Ye(e.filter, e.replayFilter()) : e.filter; if (e.or) { var a = {}, o = function (u, s, c) { if (!i || i(s, c, function (p) { return s.stop(p) }, function (p) { return s.fail(p) })) { var f = s.primaryKey, l = "" + f; l === "[object ArrayBuffer]" && (l = "" + new Uint8Array(f)), ve(a, l) || (a[l] = !0, t(u, s, c)) } }; return Promise.all([e.or._iterate(o, r), jn(Bn(e, n, r), e.algorithm, o, !e.keysOnly && e.valueMapper)]) } else return jn(Bn(e, n, r), Ye(e.algorithm, i), t, !e.keysOnly && e.valueMapper) } function jn(e, t, r, n) { var i = n ? function (o, u, s) { return r(n(o), u, s) } : r, a = $(i); return e.then(function (o) { if (o) return o.start(function () { var u = function () { return o.continue() }; (!t || t(o, function (s) { return u = s }, function (s) { o.stop(s), u = L }, function (s) { o.fail(s), u = L })) && a(o.value, o, function (s) { return u = s }), u() }) }) } function se(e, t) { try { var r = Fn(e), n = Fn(t); if (r !== n) return r === "Array" ? 1 : n === "Array" ? -1 : r === "binary" ? 1 : n === "binary" ? -1 : r === "string" ? 1 : n === "string" ? -1 : r === "Date" ? 1 : n !== "Date" ? NaN : -1; switch (r) { case "number": case "Date": case "string": return e > t ? 1 : e < t ? -1 : 0; case "binary": return Io(Kn(e), Kn(t)); case "Array": return Oo(e, t) } } catch { } return NaN } function Oo(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a) { var o = se(e[a], t[a]); if (o !== 0) return o } return r === n ? 0 : r < n ? -1 : 1 } function Io(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a)if (e[a] !== t[a]) return e[a] < t[a] ? -1 : 1; return r === n ? 0 : r < n ? -1 : 1 } function Fn(e) { var t = typeof e; if (t !== "object") return t; if (ArrayBuffer.isView(e)) return "binary"; var r = Rr(e); return r === "ArrayBuffer" ? "binary" : r } function Kn(e) { return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e) } var Ao = function () { function e() { } return e.prototype._read = function (t, r) { var n = this._ctx; return n.error ? n.table._trans(null, H.bind(null, n.error)) : n.table._trans("readonly", t).then(r) }, e.prototype._write = function (t) { var r = this._ctx; return r.error ? r.table._trans(null, H.bind(null, r.error)) : r.table._trans("readwrite", t, "locked") }, e.prototype._addAlgorithm = function (t) { var r = this._ctx; r.algorithm = Ye(r.algorithm, t) }, e.prototype._iterate = function (t, r) { return Kt(this._ctx, t, r, this._ctx.table.core) }, e.prototype.clone = function (t) { var r = Object.create(this.constructor.prototype), n = Object.create(this._ctx); return t && ce(n, t), r._ctx = n, r }, e.prototype.raw = function () { return this._ctx.valueMapper = null, this }, e.prototype.each = function (t) { var r = this._ctx; return this._read(function (n) { return Kt(r, t, n, r.table.core) }) }, e.prototype.count = function (t) { var r = this; return this._read(function (n) { var i = r._ctx, a = i.table.core; if (Qe(i, !0)) return a.count({ trans: n, query: { index: qt(i, a.schema), range: i.range } }).then(function (u) { return Math.min(u, i.limit) }); var o = 0; return Kt(i, function () { return ++o, !1 }, n, a).then(function () { return o }) }).then(t) }, e.prototype.sortBy = function (t, r) { var n = t.split(".").reverse(), i = n[0], a = n.length - 1; function o(c, f) { return f ? o(c[n[f]], f - 1) : c[i] } var u = this._ctx.dir === "next" ? 1 : -1; function s(c, f) { var l = o(c, a), p = o(f, a); return l < p ? -u : l > p ? u : 0 } return this.toArray(function (c) { return c.sort(s) }).then(r) }, e.prototype.toArray = function (t) { var r = this; return this._read(function (n) { var i = r._ctx; if (i.dir === "next" && Qe(i, !0) && i.limit > 0) { var a = i.valueMapper, o = qt(i, i.table.core.schema); return i.table.core.query({ trans: n, limit: i.limit, values: !0, query: { index: o, range: i.range } }).then(function (s) { var c = s.result; return a ? c.map(a) : c }) } else { var u = []; return Kt(i, function (s) { return u.push(s) }, n, i.table.core).then(function () { return u }) } }, t) }, e.prototype.offset = function (t) { var r = this._ctx; return t <= 0 ? this : (r.offset += t, Qe(r) ? _r(r, function () { var n = t; return function (i, a) { return n === 0 ? !0 : n === 1 ? (--n, !1) : (a(function () { i.advance(n), n = 0 }), !1) } }) : _r(r, function () { var n = t; return function () { return --n < 0 } }), this) }, e.prototype.limit = function (t) { return this._ctx.limit = Math.min(this._ctx.limit, t), _r(this._ctx, function () { var r = t; return function (n, i, a) { return --r <= 0 && i(a), r >= 0 } }, !0), this }, e.prototype.until = function (t, r) { return br(this._ctx, function (n, i, a) { return t(n.value) ? (i(a), r) : !0 }), this }, e.prototype.first = function (t) { return this.limit(1).toArray(function (r) { return r[0] }).then(t) }, e.prototype.last = function (t) { return this.reverse().first(t) }, e.prototype.filter = function (t) { return br(this._ctx, function (r) { return t(r.value) }), wo(this._ctx, t), this }, e.prototype.and = function (t) { return this.filter(t) }, e.prototype.or = function (t) { return new this.db.WhereClause(this._ctx.table, t, this) }, e.prototype.reverse = function () { return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this }, e.prototype.desc = function () { return this.reverse() }, e.prototype.eachKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.key, i) }) }, e.prototype.eachUniqueKey = function (t) { return this._ctx.unique = "unique", this.eachKey(t) }, e.prototype.eachPrimaryKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.primaryKey, i) }) }, e.prototype.keys = function (t) { var r = this._ctx; r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.key) }).then(function () { return n }).then(t) }, e.prototype.primaryKeys = function (t) { var r = this._ctx; if (r.dir === "next" && Qe(r, !0) && r.limit > 0) return this._read(function (i) { var a = qt(r, r.table.core.schema); return r.table.core.query({ trans: i, values: !1, limit: r.limit, query: { index: a, range: r.range } }) }).then(function (i) { var a = i.result; return a }).then(t); r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.primaryKey) }).then(function () { return n }).then(t) }, e.prototype.uniqueKeys = function (t) { return this._ctx.unique = "unique", this.keys(t) }, e.prototype.firstKey = function (t) { return this.limit(1).keys(function (r) { return r[0] }).then(t) }, e.prototype.lastKey = function (t) { return this.reverse().firstKey(t) }, e.prototype.distinct = function () { var t = this._ctx, r = t.index && t.table.schema.idxByName[t.index]; if (!r || !r.multi) return this; var n = {}; return br(this._ctx, function (i) { var a = i.primaryKey.toString(), o = ve(n, a); return n[a] = !0, !o }), this }, e.prototype.modify = function (t) { var r = this, n = this._ctx; return this._write(function (i) { var a; if (typeof t == "function") a = t; else { var o = V(t), u = o.length; a = function (m) { for (var g = !1, C = 0; C < u; ++C) { var _ = o[C], y = t[_]; we(m, _) !== y && (be(m, _, y), g = !0) } return g } } var s = n.table.core, c = s.schema.primaryKey, f = c.outbound, l = c.extractKey, p = r.db._options.modifyChunkSize || 200, v = [], d = 0, h = [], b = function (m, g) { var C = g.failures, _ = g.numFailures; d += m - _; for (var y = 0, S = V(C); y < S.length; y++) { var P = S[y]; v.push(C[P]) } }; return r.clone().primaryKeys().then(function (m) { var g = function (C) { var _ = Math.min(p, m.length - C); return s.getMany({ trans: i, keys: m.slice(C, C + _), cache: "immutable" }).then(function (y) { for (var S = [], P = [], T = f ? [] : null, w = [], k = 0; k < _; ++k) { var F = y[k], j = { value: Dt(F), primKey: m[C + k] }; a.call(j, j.value, j) !== !1 && (j.value == null ? w.push(m[C + k]) : !f && se(l(F), l(j.value)) !== 0 ? (w.push(m[C + k]), S.push(j.value)) : (P.push(j.value), f && T.push(m[C + k]))) } var B = Qe(n) && n.limit === 1 / 0 && (typeof t != "function" || t === Cr) && { index: n.index, range: n.range }; return Promise.resolve(S.length > 0 && s.mutate({ trans: i, type: "add", values: S }).then(function (N) { for (var A in N.failures) w.splice(parseInt(A), 1); b(S.length, N) })).then(function () { return (P.length > 0 || B && typeof t == "object") && s.mutate({ trans: i, type: "put", keys: T, values: P, criteria: B, changeSpec: typeof t != "function" && t }).then(function (N) { return b(P.length, N) }) }).then(function () { return (w.length > 0 || B && t === Cr) && s.mutate({ trans: i, type: "delete", keys: w, criteria: B }).then(function (N) { return b(w.length, N) }) }).then(function () { return m.length > C + _ && g(C + p) }) }) }; return g(0).then(function () { if (v.length > 0) throw new er("Error modifying one or more objects", v, d, h); return m.length }) }) }) }, e.prototype.delete = function () { var t = this._ctx, r = t.range; return Qe(t) && (t.isPrimKey && !Ro || r.type === 3) ? this._write(function (n) { var i = t.table.core.schema.primaryKey, a = r; return t.table.core.count({ trans: n, query: { index: i, range: a } }).then(function (o) { return t.table.core.mutate({ trans: n, type: "deleteRange", range: a }).then(function (u) { var s = u.failures; u.lastResult, u.results; var c = u.numFailures; if (c) throw new er("Could not delete some values", Object.keys(s).map(function (f) { return s[f] }), o - c); return o - c }) }) }) : this.modify(Cr) }, e }(), Cr = function (e, t) { return t.value = null }; function Mo(e) { return Mt(Ao.prototype, function (r, n) { this.db = e; var i = Ki, a = null; if (n) try { i = n() } catch (c) { a = c } var o = r._ctx, u = o.table, s = u.hook.reading.fire; this._ctx = { table: u, index: o.index, isPrimKey: !o.index || u.schema.primKey.keyPath && o.index === u.schema.primKey.name, range: i, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: a, or: o.or, valueMapper: s !== wt ? s : null } }) } function Bo(e, t) { return e < t ? -1 : e === t ? 0 : 1 } function jo(e, t) { return e > t ? -1 : e === t ? 0 : 1 } function he(e, t, r) { var n = e instanceof Ni ? new e.Collection(e) : e; return n._ctx.error = r ? new r(t) : new TypeError(t), n } function Ze(e) { return new e.Collection(e, function () { return Li("") }).limit(0) } function Fo(e) { return e === "next" ? function (t) { return t.toUpperCase() } : function (t) { return t.toLowerCase() } } function Ko(e) { return e === "next" ? function (t) { return t.toLowerCase() } : function (t) { return t.toUpperCase() } } function Lo(e, t, r, n, i, a) { for (var o = Math.min(e.length, n.length), u = -1, s = 0; s < o; ++s) { var c = t[s]; if (c !== n[s]) return i(e[s], r[s]) < 0 ? e.substr(0, s) + r[s] + r.substr(s + 1) : i(e[s], n[s]) < 0 ? e.substr(0, s) + n[s] + r.substr(s + 1) : u >= 0 ? e.substr(0, u) + t[u] + r.substr(u + 1) : null; i(e[s], c) < 0 && (u = s) } return o < n.length && a === "next" ? e + r.substr(e.length) : o < e.length && a === "prev" ? e.substr(0, r.length) : u < 0 ? null : e.substr(0, u) + n[u] + r.substr(u + 1) } function Lt(e, t, r, n) { var i, a, o, u, s, c, f, l = r.length; if (!r.every(function (h) { return typeof h == "string" })) return he(e, ji); function p(h) { i = Fo(h), a = Ko(h), o = h === "next" ? Bo : jo; var b = r.map(function (m) { return { lower: a(m), upper: i(m) } }).sort(function (m, g) { return o(m.lower, g.lower) }); u = b.map(function (m) { return m.upper }), s = b.map(function (m) { return m.lower }), c = h, f = h === "next" ? "" : n } p("next"); var v = new e.Collection(e, function () { return je(u[0], s[l - 1] + n) }); v._ondirectionchange = function (h) { p(h) }; var d = 0; return v._addAlgorithm(function (h, b, m) { var g = h.key; if (typeof g != "string") return !1; var C = a(g); if (t(C, s, d)) return !0; for (var _ = null, y = d; y < l; ++y) { var S = Lo(g, C, u[y], s[y], o, c); S === null && _ === null ? d = y + 1 : (_ === null || o(_, S) > 0) && (_ = S) } return b(_ !== null ? function () { h.continue(_ + f) } : m), !1 }), v } function je(e, t, r, n) { return { type: 2, lower: e, upper: t, lowerOpen: r, upperOpen: n } } function Li(e) { return { type: 1, lower: e, upper: e } } var Ni = function () { function e() { } return Object.defineProperty(e.prototype, "Collection", { get: function () { return this._ctx.table.db.Collection }, enumerable: !1, configurable: !0 }), e.prototype.between = function (t, r, n, i) { n = n !== !1, i = i === !0; try { return this._cmp(t, r) > 0 || this._cmp(t, r) === 0 && (n || i) && !(n && i) ? Ze(this) : new this.Collection(this, function () { return je(t, r, !n, !i) }) } catch { return he(this, Te) } }, e.prototype.equals = function (t) { return t == null ? he(this, Te) : new this.Collection(this, function () { return Li(t) }) }, e.prototype.above = function (t) { return t == null ? he(this, Te) : new this.Collection(this, function () { return je(t, void 0, !0) }) }, e.prototype.aboveOrEqual = function (t) { return t == null ? he(this, Te) : new this.Collection(this, function () { return je(t, void 0, !1) }) }, e.prototype.below = function (t) { return t == null ? he(this, Te) : new this.Collection(this, function () { return je(void 0, t, !1, !0) }) }, e.prototype.belowOrEqual = function (t) { return t == null ? he(this, Te) : new this.Collection(this, function () { return je(void 0, t) }) }, e.prototype.startsWith = function (t) { return typeof t != "string" ? he(this, ji) : this.between(t, t + Je, !0, !0) }, e.prototype.startsWithIgnoreCase = function (t) { return t === "" ? this.startsWith(t) : Lt(this, function (r, n) { return r.indexOf(n[0]) === 0 }, [t], Je) }, e.prototype.equalsIgnoreCase = function (t) { return Lt(this, function (r, n) { return r === n[0] }, [t], "") }, e.prototype.anyOfIgnoreCase = function () { var t = Ee.apply(et, arguments); return t.length === 0 ? Ze(this) : Lt(this, function (r, n) { return n.indexOf(r) !== -1 }, t, "") }, e.prototype.startsWithAnyOfIgnoreCase = function () { var t = Ee.apply(et, arguments); return t.length === 0 ? Ze(this) : Lt(this, function (r, n) { return n.some(function (i) { return r.indexOf(i) === 0 }) }, t, Je) }, e.prototype.anyOf = function () { var t = this, r = Ee.apply(et, arguments), n = this._cmp; try { r.sort(n) } catch { return he(this, Te) } if (r.length === 0) return Ze(this); var i = new this.Collection(this, function () { return je(r[0], r[r.length - 1]) }); i._ondirectionchange = function (o) { n = o === "next" ? t._ascending : t._descending, r.sort(n) }; var a = 0; return i._addAlgorithm(function (o, u, s) { for (var c = o.key; n(c, r[a]) > 0;)if (++a, a === r.length) return u(s), !1; return n(c, r[a]) === 0 ? !0 : (u(function () { o.continue(r[a]) }), !1) }), i }, e.prototype.notEqual = function (t) { return this.inAnyRange([[Lr, t], [t, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 }) }, e.prototype.noneOf = function () { var t = Ee.apply(et, arguments); if (t.length === 0) return new this.Collection(this); try { t.sort(this._ascending) } catch { return he(this, Te) } var r = t.reduce(function (n, i) { return n ? n.concat([[n[n.length - 1][1], i]]) : [[Lr, i]] }, null); return r.push([t[t.length - 1], this.db._maxKey]), this.inAnyRange(r, { includeLowers: !1, includeUppers: !1 }) }, e.prototype.inAnyRange = function (t, r) { var n = this, i = this._cmp, a = this._ascending, o = this._descending, u = this._min, s = this._max; if (t.length === 0) return Ze(this); if (!t.every(function (y) { return y[0] !== void 0 && y[1] !== void 0 && a(y[0], y[1]) <= 0 })) return he(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", I.InvalidArgument); var c = !r || r.includeLowers !== !1, f = r && r.includeUppers === !0; function l(y, S) { for (var P = 0, T = y.length; P < T; ++P) { var w = y[P]; if (i(S[0], w[1]) < 0 && i(S[1], w[0]) > 0) { w[0] = u(w[0], S[0]), w[1] = s(w[1], S[1]); break } } return P === T && y.push(S), y } var p = a; function v(y, S) { return p(y[0], S[0]) } var d; try { d = t.reduce(l, []), d.sort(v) } catch { return he(this, Te) } var h = 0, b = f ? function (y) { return a(y, d[h][1]) > 0 } : function (y) { return a(y, d[h][1]) >= 0 }, m = c ? function (y) { return o(y, d[h][0]) > 0 } : function (y) { return o(y, d[h][0]) >= 0 }; function g(y) { return !b(y) && !m(y) } var C = b, _ = new this.Collection(this, function () { return je(d[0][0], d[d.length - 1][1], !c, !f) }); return _._ondirectionchange = function (y) { y === "next" ? (C = b, p = a) : (C = m, p = o), d.sort(v) }, _._addAlgorithm(function (y, S, P) { for (var T = y.key; C(T);)if (++h, h === d.length) return S(P), !1; return g(T) ? !0 : (n._cmp(T, d[h][1]) === 0 || n._cmp(T, d[h][0]) === 0 || S(function () { p === a ? y.continue(d[h][0]) : y.continue(d[h][1]) }), !1) }), _ }, e.prototype.startsWithAnyOf = function () { var t = Ee.apply(et, arguments); return t.every(function (r) { return typeof r == "string" }) ? t.length === 0 ? Ze(this) : this.inAnyRange(t.map(function (r) { return [r, r + Je] })) : he(this, "startsWithAnyOf() only works with strings") }, e }(); function No(e) { return Mt(Ni.prototype, function (r, n, i) { this.db = e, this._ctx = { table: r, index: n === ":id" ? null : n, or: i }; var a = e._deps.indexedDB; if (!a) throw new I.MissingAPI; this._cmp = this._ascending = a.cmp.bind(a), this._descending = function (o, u) { return a.cmp(u, o) }, this._max = function (o, u) { return a.cmp(o, u) > 0 ? o : u }, this._min = function (o, u) { return a.cmp(o, u) < 0 ? o : u }, this._IDBKeyRange = e._deps.IDBKeyRange }) } function _e(e) { return $(function (t) { return kt(t), e(t.target.error), !1 }) } function kt(e) { e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault() } var Pt = "storagemutated", Ke = "x-storagemutated-1", Ue = At(null, Pt), Uo = function () { function e() { } return e.prototype._lock = function () { return lt(!D.global), ++this._reculock, this._reculock === 1 && !D.global && (D.lockOwnerFor = this), this }, e.prototype._unlock = function () { if (lt(!D.global), --this._reculock === 0) for (D.global || (D.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) { var t = this._blockedFuncs.shift(); try { st(t[1], t[0]) } catch { } } return this }, e.prototype._locked = function () { return this._reculock && D.lockOwnerFor !== this }, e.prototype.create = function (t) { var r = this; if (!this.mode) return this; var n = this.db.idbdb, i = this.db._state.dbOpenError; if (lt(!this.idbtrans), !t && !n) switch (i && i.name) { case "DatabaseClosedError": throw new I.DatabaseClosed(i); case "MissingAPIError": throw new I.MissingAPI(i.message, i); default: throw new I.OpenFailed(i) }if (!this.active) throw new I.TransactionInactive; return lt(this._completion._state === null), t = this.idbtrans = t || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })), t.onerror = $(function (a) { kt(a), r._reject(t.error) }), t.onabort = $(function (a) { kt(a), r.active && r._reject(new I.Abort(t.error)), r.active = !1, r.on("abort").fire(a) }), t.oncomplete = $(function () { r.active = !1, r._resolve(), "mutatedParts" in t && Ue.storagemutated.fire(t.mutatedParts) }), this }, e.prototype._promise = function (t, r, n) { var i = this; if (t === "readwrite" && this.mode !== "readwrite") return H(new I.ReadOnly("Transaction is readonly")); if (!this.active) return H(new I.TransactionInactive); if (this._locked()) return new E(function (o, u) { i._blockedFuncs.push([function () { i._promise(t, r, n).then(o, u) }, D]) }); if (n) return Le(function () { var o = new E(function (u, s) { i._lock(); var c = r(u, s, i); c && c.then && c.then(u, s) }); return o.finally(function () { return i._unlock() }), o._lib = !0, o }); var a = new E(function (o, u) { var s = r(o, u, i); s && s.then && s.then(o, u) }); return a._lib = !0, a }, e.prototype._root = function () { return this.parent ? this.parent._root() : this }, e.prototype.waitFor = function (t) { var r = this._root(), n = E.resolve(t); if (r._waitingFor) r._waitingFor = r._waitingFor.then(function () { return n }); else { r._waitingFor = n, r._waitingQueue = []; var i = r.idbtrans.objectStore(r.storeNames[0]); (function o() { for (++r._spinCount; r._waitingQueue.length;)r._waitingQueue.shift()(); r._waitingFor && (i.get(-1 / 0).onsuccess = o) })() } var a = r._waitingFor; return new E(function (o, u) { n.then(function (s) { return r._waitingQueue.push($(o.bind(null, s))) }, function (s) { return r._waitingQueue.push($(u.bind(null, s))) }).finally(function () { r._waitingFor === a && (r._waitingFor = null) }) }) }, e.prototype.abort = function () { this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new I.Abort)) }, e.prototype.table = function (t) { var r = this._memoizedTables || (this._memoizedTables = {}); if (ve(r, t)) return r[t]; var n = this.schema[t]; if (!n) throw new I.NotFound("Table " + t + " not part of transaction"); var i = new this.db.Table(t, n, this); return i.core = this.db.core.table(t), r[t] = i, i }, e }(); function zo(e) { return Mt(Uo.prototype, function (r, n, i, a, o) { var u = this; this.db = e, this.mode = r, this.storeNames = n, this.schema = i, this.chromeTransactionDurability = a, this.idbtrans = null, this.on = At(this, "complete", "error", "abort"), this.parent = o || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new E(function (s, c) { u._resolve = s, u._reject = c }), this._completion.then(function () { u.active = !1, u.on.complete.fire() }, function (s) { var c = u.active; return u.active = !1, u.on.error.fire(s), u.parent ? u.parent._reject(s) : c && u.idbtrans && u.idbtrans.abort(), H(s) }) }) } function Nr(e, t, r, n, i, a, o) { return { name: e, keyPath: t, unique: r, multi: n, auto: i, compound: a, src: (r && !o ? "&" : "") + (n ? "*" : "") + (i ? "++" : "") + Ui(t) } } function Ui(e) { return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "" } function zi(e, t, r) { return { name: e, primKey: t, indexes: r, mappedClass: null, idxByName: bi(r, function (n) { return [n.name, n] }) } } function $o(e) { return e.length === 1 ? e[0] : e } var Et = function (e) { try { return e.only([[]]), Et = function () { return [[]] }, [[]] } catch { return Et = function () { return Je }, Je } }; function Ur(e) { return e == null ? function () { } : typeof e == "string" ? Go(e) : function (t) { return we(t, e) } } function Go(e) { var t = e.split("."); return t.length === 1 ? function (r) { return r[e] } : function (r) { return we(r, e) } } function Ln(e) { return [].slice.call(e) } var Jo = 0; function bt(e) { return e == null ? ":id" : typeof e == "string" ? e : "[" + e.join("+") + "]" } function Vo(e, t, r) { function n(l, p) { var v = Ln(l.objectStoreNames); return { schema: { name: l.name, tables: v.map(function (d) { return p.objectStore(d) }).map(function (d) { var h = d.keyPath, b = d.autoIncrement, m = ie(h), g = h == null, C = {}, _ = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g, compound: m, keyPath: h, autoIncrement: b, unique: !0, extractKey: Ur(h) }, indexes: Ln(d.indexNames).map(function (y) { return d.index(y) }).map(function (y) { var S = y.name, P = y.unique, T = y.multiEntry, w = y.keyPath, k = ie(w), F = { name: S, compound: k, keyPath: w, unique: P, multiEntry: T, extractKey: Ur(w) }; return C[bt(w)] = F, F }), getIndexByKeyPath: function (y) { return C[bt(y)] } }; return C[":id"] = _.primaryKey, h != null && (C[bt(h)] = _.primaryKey), _ }) }, hasGetAll: v.length > 0 && "getAll" in p.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) } } function i(l) { if (l.type === 3) return null; if (l.type === 4) throw new Error("Cannot convert never type to IDBKeyRange"); var p = l.lower, v = l.upper, d = l.lowerOpen, h = l.upperOpen, b = p === void 0 ? v === void 0 ? null : t.upperBound(v, !!h) : v === void 0 ? t.lowerBound(p, !!d) : t.bound(p, v, !!d, !!h); return b } function a(l) { var p = l.name; function v(b) { var m = b.trans, g = b.type, C = b.keys, _ = b.values, y = b.range; return new Promise(function (S, P) { S = $(S); var T = m.objectStore(p), w = T.keyPath == null, k = g === "put" || g === "add"; if (!k && g !== "delete" && g !== "deleteRange") throw new Error("Invalid operation type: " + g); var F = (C || _ || { length: 1 }).length; if (C && _ && C.length !== _.length) throw new Error("Given keys array must have same length as given values array."); if (F === 0) return S({ numFailures: 0, failures: {}, results: [], lastResult: void 0 }); var j, B = [], N = [], A = 0, ee = function (de) { ++A, kt(de) }; if (g === "deleteRange") { if (y.type === 4) return S({ numFailures: A, failures: N, results: [], lastResult: void 0 }); y.type === 3 ? B.push(j = T.clear()) : B.push(j = T.delete(i(y))) } else { var Y = k ? w ? [_, C] : [_, null] : [C, null], W = Y[0], pe = Y[1]; if (k) for (var oe = 0; oe < F; ++oe)B.push(j = pe && pe[oe] !== void 0 ? T[g](W[oe], pe[oe]) : T[g](W[oe])), j.onerror = ee; else for (var oe = 0; oe < F; ++oe)B.push(j = T[g](W[oe])), j.onerror = ee } var me = function (de) { var Ae = de.target.result; B.forEach(function (q, Me) { return q.error != null && (N[Me] = q.error) }), S({ numFailures: A, failures: N, results: g === "delete" ? C : B.map(function (q) { return q.result }), lastResult: Ae }) }; j.onerror = function (de) { ee(de), me(de) }, j.onsuccess = me }) } function d(b) { var m = b.trans, g = b.values, C = b.query, _ = b.reverse, y = b.unique; return new Promise(function (S, P) { S = $(S); var T = C.index, w = C.range, k = m.objectStore(p), F = T.isPrimaryKey ? k : k.index(T.name), j = _ ? y ? "prevunique" : "prev" : y ? "nextunique" : "next", B = g || !("openKeyCursor" in F) ? F.openCursor(i(w), j) : F.openKeyCursor(i(w), j); B.onerror = _e(P), B.onsuccess = $(function (N) { var A = B.result; if (!A) { S(null); return } A.___id = ++Jo, A.done = !1; var ee = A.continue.bind(A), Y = A.continuePrimaryKey; Y && (Y = Y.bind(A)); var W = A.advance.bind(A), pe = function () { throw new Error("Cursor not started") }, oe = function () { throw new Error("Cursor not stopped") }; A.trans = m, A.stop = A.continue = A.continuePrimaryKey = A.advance = pe, A.fail = $(P), A.next = function () { var me = this, de = 1; return this.start(function () { return de-- ? me.continue() : me.stop() }).then(function () { return me }) }, A.start = function (me) { var de = new Promise(function (q, Me) { q = $(q), B.onerror = _e(Me), A.fail = Me, A.stop = function (Be) { A.stop = A.continue = A.continuePrimaryKey = A.advance = oe, q(Be) } }), Ae = function () { if (B.result) try { me() } catch (q) { A.fail(q) } else A.done = !0, A.start = function () { throw new Error("Cursor behind last entry") }, A.stop() }; return B.onsuccess = $(function (q) { B.onsuccess = Ae, Ae() }), A.continue = ee, A.continuePrimaryKey = Y, A.advance = W, Ae(), de }, S(A) }, P) }) } function h(b) { return function (m) { return new Promise(function (g, C) { g = $(g); var _ = m.trans, y = m.values, S = m.limit, P = m.query, T = S === 1 / 0 ? void 0 : S, w = P.index, k = P.range, F = _.objectStore(p), j = w.isPrimaryKey ? F : F.index(w.name), B = i(k); if (S === 0) return g({ result: [] }); if (b) { var N = y ? j.getAll(B, T) : j.getAllKeys(B, T); N.onsuccess = function (W) { return g({ result: W.target.result }) }, N.onerror = _e(C) } else { var A = 0, ee = y || !("openKeyCursor" in j) ? j.openCursor(B) : j.openKeyCursor(B), Y = []; ee.onsuccess = function (W) { var pe = ee.result; if (!pe) return g({ result: Y }); if (Y.push(y ? pe.value : pe.primaryKey), ++A === S) return g({ result: Y }); pe.continue() }, ee.onerror = _e(C) } }) } } return { name: p, schema: l, mutate: v, getMany: function (b) { var m = b.trans, g = b.keys; return new Promise(function (C, _) { C = $(C); for (var y = m.objectStore(p), S = g.length, P = new Array(S), T = 0, w = 0, k, F = function (A) { var ee = A.target; (P[ee._pos] = ee.result) != null, ++w === T && C(P) }, j = _e(_), B = 0; B < S; ++B) { var N = g[B]; N != null && (k = y.get(g[B]), k._pos = B, k.onsuccess = F, k.onerror = j, ++T) } T === 0 && C(P) }) }, get: function (b) { var m = b.trans, g = b.key; return new Promise(function (C, _) { C = $(C); var y = m.objectStore(p), S = y.get(g); S.onsuccess = function (P) { return C(P.target.result) }, S.onerror = _e(_) }) }, query: h(s), openCursor: d, count: function (b) { var m = b.query, g = b.trans, C = m.index, _ = m.range; return new Promise(function (y, S) { var P = g.objectStore(p), T = C.isPrimaryKey ? P : P.index(C.name), w = i(_), k = w ? T.count(w) : T.count(); k.onsuccess = $(function (F) { return y(F.target.result) }), k.onerror = _e(S) }) } } } var o = n(e, r), u = o.schema, s = o.hasGetAll, c = u.tables.map(function (l) { return a(l) }), f = {}; return c.forEach(function (l) { return f[l.name] = l }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function (l) { var p = f[l]; if (!p) throw new Error("Table '" + l + "' not found"); return f[l] }, MIN_KEY: -1 / 0, MAX_KEY: Et(t), schema: u } } function Ho(e, t) { return t.reduce(function (r, n) { var i = n.create; return M(M({}, r), i(r)) }, e) } function Wo(e, t, r, n) { var i = r.IDBKeyRange; r.indexedDB; var a = Ho(Vo(t, i, n), e.dbcore); return { dbcore: a } } function vn(e, t) { var r = e._novip, n = t.db, i = Wo(r._middlewares, n, r._deps, t); r.core = i.dbcore, r.tables.forEach(function (a) { var o = a.name; r.core.schema.tables.some(function (u) { return u.name === o }) && (a.core = r.core.table(o), r[o] instanceof r.Table && (r[o].core = a.core)) }) } function or(e, t, r, n) { var i = e._novip; r.forEach(function (a) { var o = n[a]; t.forEach(function (u) { var s = on(u, a); (!s || "value" in s && s.value === void 0) && (u === i.Transaction.prototype || u instanceof i.Transaction ? Oe(u, a, { get: function () { return this.table(a) }, set: function (c) { mi(this, a, { value: c, writable: !0, configurable: !0, enumerable: !0 }) } }) : u[a] = new i.Table(a, o)) }) }) } function zr(e, t) { var r = e._novip; t.forEach(function (n) { for (var i in n) n[i] instanceof r.Table && delete n[i] }) } function qo(e, t) { return e._cfg.version - t._cfg.version } function Yo(e, t, r, n) { var i = e._dbSchema, a = e._createTransaction("readwrite", e._storeNames, i); a.create(r), a._completion.catch(n); var o = a._reject.bind(a), u = D.transless || D; Le(function () { D.trans = a, D.transless = u, t === 0 ? (V(i).forEach(function (s) { mn(r, s, i[s].primKey, i[s].indexes) }), vn(e, r), E.follow(function () { return e.on.populate.fire(a) }).catch(o)) : Xo(e, t, a, r).catch(o) }) } function Xo(e, t, r, n) { var i = e._novip, a = [], o = i._versions, u = i._dbSchema = yn(i, i.idbdb, n), s = !1, c = o.filter(function (l) { return l._cfg.version >= t }); c.forEach(function (l) { a.push(function () { var p = u, v = l._cfg.dbschema; Gr(i, p, n), Gr(i, v, n), u = i._dbSchema = v; var d = $i(p, v); d.add.forEach(function (_) { mn(n, _[0], _[1].primKey, _[1].indexes) }), d.change.forEach(function (_) { if (_.recreate) throw new I.Upgrade("Not yet support for changing primary key"); var y = n.objectStore(_.name); _.add.forEach(function (S) { return $r(y, S) }), _.change.forEach(function (S) { y.deleteIndex(S.name), $r(y, S) }), _.del.forEach(function (S) { return y.deleteIndex(S) }) }); var h = l._cfg.contentUpgrade; if (h && l._cfg.version > t) { vn(i, n), r._memoizedTables = {}, s = !0; var b = _i(v); d.del.forEach(function (_) { b[_] = p[_] }), zr(i, [i.Transaction.prototype]), or(i, [i.Transaction.prototype], V(b), b), r.schema = b; var m = sn(h); m && ot(); var g, C = E.follow(function () { if (g = h(r), g && m) { var _ = Ie.bind(null, null); g.then(_, _) } }); return g && typeof g.then == "function" ? E.resolve(g) : C.then(function () { return g }) } }), a.push(function (p) { if (!s || !Eo) { var v = l._cfg.dbschema; Zo(v, p) } zr(i, [i.Transaction.prototype]), or(i, [i.Transaction.prototype], i._storeNames, i._dbSchema), r.schema = i._dbSchema }) }); function f() { return a.length ? E.resolve(a.shift()(r.idbtrans)).then(f) : E.resolve() } return f().then(function () { Qo(u, n) }) } function $i(e, t) { var r = { del: [], add: [], change: [] }, n; for (n in e) t[n] || r.del.push(n); for (n in t) { var i = e[n], a = t[n]; if (!i) r.add.push([n, a]); else { var o = { name: n, def: a, recreate: !1, del: [], add: [], change: [] }; if ("" + (i.primKey.keyPath || "") != "" + (a.primKey.keyPath || "") || i.primKey.auto !== a.primKey.auto && !dr) o.recreate = !0, r.change.push(o); else { var u = i.idxByName, s = a.idxByName, c = void 0; for (c in u) s[c] || o.del.push(c); for (c in s) { var f = u[c], l = s[c]; f ? f.src !== l.src && o.change.push(l) : o.add.push(l) } (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && r.change.push(o) } } } return r } function mn(e, t, r, n) { var i = e.db.createObjectStore(t, r.keyPath ? { keyPath: r.keyPath, autoIncrement: r.auto } : { autoIncrement: r.auto }); return n.forEach(function (a) { return $r(i, a) }), i } function Qo(e, t) { V(e).forEach(function (r) { t.db.objectStoreNames.contains(r) || mn(t, r, e[r].primKey, e[r].indexes) }) } function Zo(e, t) { [].slice.call(t.db.objectStoreNames).forEach(function (r) { return e[r] == null && t.db.deleteObjectStore(r) }) } function $r(e, t) { e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi }) } function yn(e, t, r) { var n = {}, i = lr(t.objectStoreNames, 0); return i.forEach(function (a) { for (var o = r.objectStore(a), u = o.keyPath, s = Nr(Ui(u), u || "", !1, !1, !!o.autoIncrement, u && typeof u != "string", !0), c = [], f = 0; f < o.indexNames.length; ++f) { var l = o.index(o.indexNames[f]); u = l.keyPath; var p = Nr(l.name, u, !!l.unique, !!l.multiEntry, !1, u && typeof u != "string", !1); c.push(p) } n[a] = zi(a, s, c) }), n } function es(e, t, r) { var n = e._novip; n.verno = t.version / 10; var i = n._dbSchema = yn(n, t, r); n._storeNames = lr(t.objectStoreNames, 0), or(n, [n._allTables], V(i), i) } function ts(e, t) { var r = yn(e, e.idbdb, t), n = $i(r, e._dbSchema); return !(n.add.length || n.change.some(function (i) { return i.add.length || i.change.length })) } function Gr(e, t, r) { for (var n = e._novip, i = r.db.objectStoreNames, a = 0; a < i.length; ++a) { var o = i[a], u = r.objectStore(o); n._hasGetAll = "getAll" in u; for (var s = 0; s < u.indexNames.length; ++s) { var c = u.indexNames[s], f = u.index(c).keyPath, l = typeof f == "string" ? f : "[" + lr(f).join("+") + "]"; if (t[o]) { var p = t[o].idxByName[l]; p && (p.name = c, delete t[o].idxByName[l], t[o].idxByName[c] = p) } } } typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && U.WorkerGlobalScope && U instanceof U.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1) } function rs(e) { return e.split(",").map(function (t, r) { t = t.trim(); var n = t.replace(/([&*]|\+\+)/g, ""), i = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split("+") : n; return Nr(n, i || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), ie(i), r === 0) }) } var ns = function () { function e() { } return e.prototype._parseStoresSpec = function (t, r) { V(t).forEach(function (n) { if (t[n] !== null) { var i = rs(t[n]), a = i.shift(); if (a.multi) throw new I.Schema("Primary key cannot be multi-valued"); i.forEach(function (o) { if (o.auto) throw new I.Schema("Only primary key can be marked as autoIncrement (++)"); if (!o.keyPath) throw new I.Schema("Index must have a name and cannot be an empty string") }), r[n] = zi(n, a, i) } }) }, e.prototype.stores = function (t) { var r = this.db; this._cfg.storesSource = this._cfg.storesSource ? ce(this._cfg.storesSource, t) : t; var n = r._versions, i = {}, a = {}; return n.forEach(function (o) { ce(i, o._cfg.storesSource), a = o._cfg.dbschema = {}, o._parseStoresSpec(i, a) }), r._dbSchema = a, zr(r, [r._allTables, r, r.Transaction.prototype]), or(r, [r._allTables, r, r.Transaction.prototype, this._cfg.tables], V(a), a), r._storeNames = V(a), this }, e.prototype.upgrade = function (t) { return this._cfg.contentUpgrade = fn(this._cfg.contentUpgrade || L, t), this }, e }(); function is(e) { return Mt(ns.prototype, function (r) { this.db = e, this._cfg = { version: r, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null } }) } function gn(e, t) { var r = e._dbNamesDB; return r || (r = e._dbNamesDB = new Sn(hr, { addons: [], indexedDB: e, IDBKeyRange: t }), r.version(1).stores({ dbnames: "name" })), r.table("dbnames") } function bn(e) { return e && typeof e.databases == "function" } function as(e) { var t = e.indexedDB, r = e.IDBKeyRange; return bn(t) ? Promise.resolve(t.databases()).then(function (n) { return n.map(function (i) { return i.name }).filter(function (i) { return i !== hr }) }) : gn(t, r).toCollection().primaryKeys() } function os(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !bn(r) && t !== hr && gn(r, n).put({ name: t }).catch(L) } function ss(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !bn(r) && t !== hr && gn(r, n).delete(t).catch(L) } function Jr(e) { return Le(function () { return D.letThrough = !0, e() }) } function cs() { var e = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent); if (!e || !indexedDB.databases) return Promise.resolve(); var t; return new Promise(function (r) { var n = function () { return indexedDB.databases().finally(r) }; t = setInterval(n, 100), n() }).finally(function () { return clearInterval(t) }) } function us(e) { var t = e._state, r = e._deps.indexedDB; if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function () { return t.dbOpenError ? H(t.dbOpenError) : e }); Ce && (t.openCanceller._stackHolder = Xe()), t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1; var n = t.openCanceller; function i() { if (t.openCanceller !== n) throw new I.DatabaseClosed("db.open() was cancelled") } var a = t.dbReadyResolve, o = null, u = !1; return E.race([n, (typeof navigator > "u" ? E.resolve() : cs()).then(function () { return new E(function (s, c) { if (i(), !r) throw new I.MissingAPI; var f = e.name, l = t.autoSchema ? r.open(f) : r.open(f, Math.round(e.verno * 10)); if (!l) throw new I.MissingAPI; l.onerror = _e(c), l.onblocked = $(e._fireOnBlocked), l.onupgradeneeded = $(function (p) { if (o = l.transaction, t.autoSchema && !e._options.allowEmptyDB) { l.onerror = kt, o.abort(), l.result.close(); var v = r.deleteDatabase(f); v.onsuccess = v.onerror = $(function () { c(new I.NoSuchDatabase("Database " + f + " doesnt exist")) }) } else { o.onerror = _e(c); var d = p.oldVersion > Math.pow(2, 62) ? 0 : p.oldVersion; u = d < 1, e._novip.idbdb = l.result, Yo(e, d / 10, o, c) } }, c), l.onsuccess = $(function () { o = null; var p = e._novip.idbdb = l.result, v = lr(p.objectStoreNames); if (v.length > 0) try { var d = p.transaction($o(v), "readonly"); t.autoSchema ? es(e, p, d) : (Gr(e, e._dbSchema, d), ts(e, d) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), vn(e, d) } catch { } gt.push(e), p.onversionchange = $(function (h) { t.vcFired = !0, e.on("versionchange").fire(h) }), p.onclose = $(function (h) { e.on("close").fire(h) }), u && os(e._deps, f), s() }, c) }) })]).then(function () { return i(), t.onReadyBeingFired = [], E.resolve(Jr(function () { return e.on.ready.fire(e.vip) })).then(function s() { if (t.onReadyBeingFired.length > 0) { var c = t.onReadyBeingFired.reduce(fn, L); return t.onReadyBeingFired = [], E.resolve(Jr(function () { return c(e.vip) })).then(s) } }) }).finally(function () { t.onReadyBeingFired = null, t.isBeingOpened = !1 }).then(function () { return e }).catch(function (s) { t.dbOpenError = s; try { o && o.abort() } catch { } return n === t.openCanceller && e._close(), H(s) }).finally(function () { t.openComplete = !0, a() }) } function Vr(e) { var t = function (o) { return e.next(o) }, r = function (o) { return e.throw(o) }, n = a(t), i = a(r); function a(o) { return function (u) { var s = o(u), c = s.value; return s.done ? c : !c || typeof c.then != "function" ? ie(c) ? Promise.all(c).then(n, i) : n(c) : c.then(n, i) } } return a(t)() } function fs(e, t, r) { var n = arguments.length; if (n < 2) throw new I.InvalidArgument("Too few arguments"); for (var i = new Array(n - 1); --n;)i[n - 1] = arguments[n]; r = i.pop(); var a = Ci(i); return [e, a, r] } function Gi(e, t, r, n, i) { return E.resolve().then(function () { var a = D.transless || D, o = e._createTransaction(t, r, e._dbSchema, n), u = { trans: o, transless: a }; if (n) o.idbtrans = n.idbtrans; else try { o.create(), e._state.PR1398_maxLoop = 3 } catch (l) { return l.name === un.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return Gi(e, t, r, null, i) })) : H(l) } var s = sn(i); s && ot(); var c, f = E.follow(function () { if (c = i.call(o, o), c) if (s) { var l = Ie.bind(null, null); c.then(l, l) } else typeof c.next == "function" && typeof c.throw == "function" && (c = Vr(c)) }, u); return (c && typeof c.then == "function" ? E.resolve(c).then(function (l) { return o.active ? l : H(new I.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")) }) : f.then(function () { return c })).then(function (l) { return n && o._resolve(), o._completion.then(function () { return l }) }).catch(function (l) { return o._reject(l), H(l) }) }) } function Nt(e, t, r) { for (var n = ie(e) ? e.slice() : [e], i = 0; i < r; ++i)n.push(t); return n } function ls(e) { return M(M({}, e), { table: function (t) { var r = e.table(t), n = r.schema, i = {}, a = []; function o(h, b, m) { var g = bt(h), C = i[g] = i[g] || [], _ = h == null ? 0 : typeof h == "string" ? 1 : h.length, y = b > 0, S = M(M({}, m), { isVirtual: y, keyTail: b, keyLength: _, extractKey: Ur(h), unique: !y && m.unique }); if (C.push(S), S.isPrimaryKey || a.push(S), _ > 1) { var P = _ === 2 ? h[0] : h.slice(0, _ - 1); o(P, b + 1, m) } return C.sort(function (T, w) { return T.keyTail - w.keyTail }), S } var u = o(n.primaryKey.keyPath, 0, n.primaryKey); i[":id"] = [u]; for (var s = 0, c = n.indexes; s < c.length; s++) { var f = c[s]; o(f.keyPath, 0, f) } function l(h) { var b = i[bt(h)]; return b && b[0] } function p(h, b) { return { type: h.type === 1 ? 2 : h.type, lower: Nt(h.lower, h.lowerOpen ? e.MAX_KEY : e.MIN_KEY, b), lowerOpen: !0, upper: Nt(h.upper, h.upperOpen ? e.MIN_KEY : e.MAX_KEY, b), upperOpen: !0 } } function v(h) { var b = h.query.index; return b.isVirtual ? M(M({}, h), { query: { index: b, range: p(h.query.range, b.keyTail) } }) : h } var d = M(M({}, r), { schema: M(M({}, n), { primaryKey: u, indexes: a, getIndexByKeyPath: l }), count: function (h) { return r.count(v(h)) }, query: function (h) { return r.query(v(h)) }, openCursor: function (h) { var b = h.query.index, m = b.keyTail, g = b.isVirtual, C = b.keyLength; if (!g) return r.openCursor(h); function _(y) { function S(T) { T != null ? y.continue(Nt(T, h.reverse ? e.MAX_KEY : e.MIN_KEY, m)) : h.unique ? y.continue(y.key.slice(0, C).concat(h.reverse ? e.MIN_KEY : e.MAX_KEY, m)) : y.continue() } var P = Object.create(y, { continue: { value: S }, continuePrimaryKey: { value: function (T, w) { y.continuePrimaryKey(Nt(T, e.MAX_KEY, m), w) } }, primaryKey: { get: function () { return y.primaryKey } }, key: { get: function () { var T = y.key; return C === 1 ? T[0] : T.slice(0, C) } }, value: { get: function () { return y.value } } }); return P } return r.openCursor(v(h)).then(function (y) { return y && _(y) }) } }); return d } }) } var ps = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: ls }; function _n(e, t, r, n) { return r = r || {}, n = n || "", V(e).forEach(function (i) { if (!ve(t, i)) r[n + i] = void 0; else { var a = e[i], o = t[i]; if (typeof a == "object" && typeof o == "object" && a && o) { var u = Rr(a), s = Rr(o); u !== s ? r[n + i] = t[i] : u === "Object" ? _n(a, o, r, n + i + ".") : a !== o && (r[n + i] = t[i]) } else a !== o && (r[n + i] = t[i]) } }), V(t).forEach(function (i) { ve(e, i) || (r[n + i] = t[i]) }), r } function ds(e, t) { return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey) } var hs = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function (e) { return M(M({}, e), { table: function (t) { var r = e.table(t), n = r.schema.primaryKey, i = M(M({}, r), { mutate: function (a) { var o = D.trans, u = o.table(t).hook, s = u.deleting, c = u.creating, f = u.updating; switch (a.type) { case "add": if (c.fire === L) break; return o._promise("readwrite", function () { return l(a) }, !0); case "put": if (c.fire === L && f.fire === L) break; return o._promise("readwrite", function () { return l(a) }, !0); case "delete": if (s.fire === L) break; return o._promise("readwrite", function () { return l(a) }, !0); case "deleteRange": if (s.fire === L) break; return o._promise("readwrite", function () { return p(a) }, !0) }return r.mutate(a); function l(d) { var h = D.trans, b = d.keys || ds(n, d); if (!b) throw new Error("Keys missing"); return d = d.type === "add" || d.type === "put" ? M(M({}, d), { keys: b }) : M({}, d), d.type !== "delete" && (d.values = Pr([], d.values, !0)), d.keys && (d.keys = Pr([], d.keys, !0)), vs(r, d, b).then(function (m) { var g = b.map(function (C, _) { var y = m[_], S = { onerror: null, onsuccess: null }; if (d.type === "delete") s.fire.call(S, C, y, h); else if (d.type === "add" || y === void 0) { var P = c.fire.call(S, C, d.values[_], h); C == null && P != null && (C = P, d.keys[_] = C, n.outbound || be(d.values[_], n.keyPath, C)) } else { var T = _n(y, d.values[_]), w = f.fire.call(S, T, C, y, h); if (w) { var k = d.values[_]; Object.keys(w).forEach(function (F) { ve(k, F) ? k[F] = w[F] : be(k, F, w[F]) }) } } return S }); return r.mutate(d).then(function (C) { for (var _ = C.failures, y = C.results, S = C.numFailures, P = C.lastResult, T = 0; T < b.length; ++T) { var w = y ? y[T] : b[T], k = g[T]; w == null ? k.onerror && k.onerror(_[T]) : k.onsuccess && k.onsuccess(d.type === "put" && m[T] ? d.values[T] : w) } return { failures: _, results: y, numFailures: S, lastResult: P } }).catch(function (C) { return g.forEach(function (_) { return _.onerror && _.onerror(C) }), Promise.reject(C) }) }) } function p(d) { return v(d.trans, d.range, 1e4) } function v(d, h, b) { return r.query({ trans: d, values: !1, query: { index: n, range: h }, limit: b }).then(function (m) { var g = m.result; return l({ type: "delete", keys: g, trans: d }).then(function (C) { return C.numFailures > 0 ? Promise.reject(C.failures[0]) : g.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(d, M(M({}, h), { lower: g[g.length - 1], lowerOpen: !0 }), b) }) }) } } }); return i } }) } }; function vs(e, t, r) { return t.type === "add" ? Promise.resolve([]) : e.getMany({ trans: t.trans, keys: r, cache: "immutable" }) } function Ji(e, t, r) { try { if (!t || t.keys.length < e.length) return null; for (var n = [], i = 0, a = 0; i < t.keys.length && a < e.length; ++i)se(t.keys[i], e[a]) === 0 && (n.push(r ? Dt(t.values[i]) : t.values[i]), ++a); return n.length === e.length ? n : null } catch { return null } } var ms = { stack: "dbcore", level: -1, create: function (e) { return { table: function (t) { var r = e.table(t); return M(M({}, r), { getMany: function (n) { if (!n.cache) return r.getMany(n); var i = Ji(n.keys, n.trans._cache, n.cache === "clone"); return i ? E.resolve(i) : r.getMany(n).then(function (a) { return n.trans._cache = { keys: n.keys, values: n.cache === "clone" ? Dt(a) : a }, a }) }, mutate: function (n) { return n.type !== "add" && (n.trans._cache = null), r.mutate(n) } }) } } } }, Sr; function Cn(e) { return !("from" in e) } var Pe = function (e, t) { if (this) ce(this, arguments.length ? { d: 1, from: e, to: arguments.length > 1 ? t : e } : { d: 0 }); else { var r = new Pe; return e && "d" in e && ce(r, e), r } }; nt(Pe.prototype, (Sr = { add: function (e) { return sr(this, e), this }, addKey: function (e) { return Rt(this, e, e), this }, addKeys: function (e) { var t = this; return e.forEach(function (r) { return Rt(t, r, r) }), this } }, Sr[xr] = function () { return Hr(this) }, Sr)); function Rt(e, t, r) { var n = se(t, r); if (!isNaN(n)) { if (n > 0) throw RangeError(); if (Cn(e)) return ce(e, { from: t, to: r, d: 1 }); var i = e.l, a = e.r; if (se(r, e.from) < 0) return i ? Rt(i, t, r) : e.l = { from: t, to: r, d: 1, l: null, r: null }, Nn(e); if (se(t, e.to) > 0) return a ? Rt(a, t, r) : e.r = { from: t, to: r, d: 1, l: null, r: null }, Nn(e); se(t, e.from) < 0 && (e.from = t, e.l = null, e.d = a ? a.d + 1 : 1), se(r, e.to) > 0 && (e.to = r, e.r = null, e.d = e.l ? e.l.d + 1 : 1); var o = !e.r; i && !e.l && sr(e, i), a && o && sr(e, a) } } function sr(e, t) { function r(n, i) { var a = i.from, o = i.to, u = i.l, s = i.r; Rt(n, a, o), u && r(n, u), s && r(n, s) } Cn(t) || r(e, t) } function ys(e, t) { var r = Hr(t), n = r.next(); if (n.done) return !1; for (var i = n.value, a = Hr(e), o = a.next(i.from), u = o.value; !n.done && !o.done;) { if (se(u.from, i.to) <= 0 && se(u.to, i.from) >= 0) return !0; se(i.from, u.from) < 0 ? i = (n = r.next(u.from)).value : u = (o = a.next(i.from)).value } return !1 } function Hr(e) { var t = Cn(e) ? null : { s: 0, n: e }; return { next: function (r) { for (var n = arguments.length > 0; t;)switch (t.s) { case 0: if (t.s = 1, n) for (; t.n.l && se(r, t.n.from) < 0;)t = { up: t, n: t.n.l, s: 1 }; else for (; t.n.l;)t = { up: t, n: t.n.l, s: 1 }; case 1: if (t.s = 2, !n || se(r, t.n.to) <= 0) return { value: t.n, done: !1 }; case 2: if (t.n.r) { t.s = 3, t = { up: t, n: t.n.r, s: 0 }; continue } case 3: t = t.up }return { done: !0 } } } } function Nn(e) { var t, r, n = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((r = e.l) === null || r === void 0 ? void 0 : r.d) || 0), i = n > 1 ? "r" : n < -1 ? "l" : ""; if (i) { var a = i === "r" ? "l" : "r", o = M({}, e), u = e[i]; e.from = u.from, e.to = u.to, e[i] = u[i], o[i] = u[a], e[a] = o, o.d = Un(o) } e.d = Un(e) } function Un(e) { var t = e.r, r = e.l; return (t ? r ? Math.max(t.d, r.d) : t.d : r ? r.d : 0) + 1 } var gs = { stack: "dbcore", level: 0, create: function (e) { var t = e.schema.name, r = new Pe(e.MIN_KEY, e.MAX_KEY); return M(M({}, e), { table: function (n) { var i = e.table(n), a = i.schema, o = a.primaryKey, u = o.extractKey, s = o.outbound, c = M(M({}, i), { mutate: function (p) { var v = p.trans, d = v.mutatedParts || (v.mutatedParts = {}), h = function (P) { var T = "idb://" + t + "/" + n + "/" + P; return d[T] || (d[T] = new Pe) }, b = h(""), m = h(":dels"), g = p.type, C = p.type === "deleteRange" ? [p.range] : p.type === "delete" ? [p.keys] : p.values.length < 50 ? [[], p.values] : [], _ = C[0], y = C[1], S = p.trans._cache; return i.mutate(p).then(function (P) { if (ie(_)) { g !== "delete" && (_ = P.results), b.addKeys(_); var T = Ji(_, S); !T && g !== "add" && m.addKeys(_), (T || y) && bs(h, a, T, y) } else if (_) { var w = { from: _.lower, to: _.upper }; m.add(w), b.add(w) } else b.add(r), m.add(r), a.indexes.forEach(function (k) { return h(k.name).add(r) }); return P }) } }), f = function (p) { var v, d, h = p.query, b = h.index, m = h.range; return [b, new Pe((v = m.lower) !== null && v !== void 0 ? v : e.MIN_KEY, (d = m.upper) !== null && d !== void 0 ? d : e.MAX_KEY)] }, l = { get: function (p) { return [o, new Pe(p.key)] }, getMany: function (p) { return [o, new Pe().addKeys(p.keys)] }, count: f, query: f, openCursor: f }; return V(l).forEach(function (p) { c[p] = function (v) { var d = D.subscr; if (d) { var h = function (S) { var P = "idb://" + t + "/" + n + "/" + S; return d[P] || (d[P] = new Pe) }, b = h(""), m = h(":dels"), g = l[p](v), C = g[0], _ = g[1]; if (h(C.name || "").add(_), !C.isPrimaryKey) if (p === "count") m.add(r); else { var y = p === "query" && s && v.values && i.query(M(M({}, v), { values: !1 })); return i[p].apply(this, arguments).then(function (S) { if (p === "query") { if (s && v.values) return y.then(function (k) { var F = k.result; return b.addKeys(F), S }); var P = v.values ? S.result.map(u) : S.result; v.values ? b.addKeys(P) : m.addKeys(P) } else if (p === "openCursor") { var T = S, w = v.values; return T && Object.create(T, { key: { get: function () { return m.addKey(T.primaryKey), T.key } }, primaryKey: { get: function () { var k = T.primaryKey; return m.addKey(k), k } }, value: { get: function () { return w && b.addKey(T.primaryKey), T.value } } }) } return S }) } } return i[p].apply(this, arguments) } }), c } }) } }; function bs(e, t, r, n) { function i(a) { var o = e(a.name || ""); function u(c) { return c != null ? a.extractKey(c) : null } var s = function (c) { return a.multiEntry && ie(c) ? c.forEach(function (f) { return o.addKey(f) }) : o.addKey(c) }; (r || n).forEach(function (c, f) { var l = r && u(r[f]), p = n && u(n[f]); se(l, p) !== 0 && (l != null && s(l), p != null && s(p)) }) } t.indexes.forEach(i) } var Sn = function () { function e(t, r) { var n = this; this._middlewares = {}, this.verno = 0; var i = e.dependencies; this._options = r = M({ addons: e.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange }, r), this._deps = { indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange }; var a = r.addons; this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this; var o = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: L, dbReadyPromise: null, cancelOpen: L, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 }; o.dbReadyPromise = new E(function (u) { o.dbReadyResolve = u }), o.openCanceller = new E(function (u, s) { o.cancelOpen = s }), this._state = o, this.name = t, this.on = At(this, "populate", "blocked", "versionchange", "close", { ready: [fn, L] }), this.on.ready.subscribe = yi(this.on.ready.subscribe, function (u) { return function (s, c) { e.vip(function () { var f = n._state; if (f.openComplete) f.dbOpenError || E.resolve().then(s), c && u(s); else if (f.onReadyBeingFired) f.onReadyBeingFired.push(s), c && u(s); else { u(s); var l = n; c || u(function p() { l.on.ready.unsubscribe(s), l.on.ready.unsubscribe(p) }) } }) } }), this.Collection = Mo(this), this.Table = Do(this), this.Transaction = zo(this), this.Version = is(this), this.WhereClause = No(this), this.on("versionchange", function (u) { u.newVersion > 0 ? console.warn("Another connection wants to upgrade database '" + n.name + "'. Closing db now to resume the upgrade.") : console.warn("Another connection wants to delete database '" + n.name + "'. Closing db now to resume the delete request."), n.close() }), this.on("blocked", function (u) { !u.newVersion || u.newVersion < u.oldVersion ? console.warn("Dexie.delete('" + n.name + "') was blocked") : console.warn("Upgrade '" + n.name + "' blocked by other connection holding version " + u.oldVersion / 10) }), this._maxKey = Et(r.IDBKeyRange), this._createTransaction = function (u, s, c, f) { return new n.Transaction(u, s, c, n._options.chromeTransactionDurability, f) }, this._fireOnBlocked = function (u) { n.on("blocked").fire(u), gt.filter(function (s) { return s.name === n.name && s !== n && !s._state.vcFired }).map(function (s) { return s.on("versionchange").fire(u) }) }, this.use(ps), this.use(hs), this.use(gs), this.use(ms), this.vip = Object.create(this, { _vip: { value: !0 } }), a.forEach(function (u) { return u(n) }) } return e.prototype.version = function (t) { if (isNaN(t) || t < .1) throw new I.Type("Given version is not a positive number"); if (t = Math.round(t * 10) / 10, this.idbdb || this._state.isBeingOpened) throw new I.Schema("Cannot add version when database is open"); this.verno = Math.max(this.verno, t); var r = this._versions, n = r.filter(function (i) { return i._cfg.version === t })[0]; return n || (n = new this.Version(t), r.push(n), r.sort(qo), n.stores({}), this._state.autoSchema = !1, n) }, e.prototype._whenReady = function (t) { var r = this; return this.idbdb && (this._state.openComplete || D.letThrough || this._vip) ? t() : new E(function (n, i) { if (r._state.openComplete) return i(new I.DatabaseClosed(r._state.dbOpenError)); if (!r._state.isBeingOpened) { if (!r._options.autoOpen) { i(new I.DatabaseClosed); return } r.open().catch(L) } r._state.dbReadyPromise.then(n, i) }).then(t) }, e.prototype.use = function (t) { var r = t.stack, n = t.create, i = t.level, a = t.name; a && this.unuse({ stack: r, name: a }); var o = this._middlewares[r] || (this._middlewares[r] = []); return o.push({ stack: r, create: n, level: i == null ? 10 : i, name: a }), o.sort(function (u, s) { return u.level - s.level }), this }, e.prototype.unuse = function (t) { var r = t.stack, n = t.name, i = t.create; return r && this._middlewares[r] && (this._middlewares[r] = this._middlewares[r].filter(function (a) { return i ? a.create !== i : n ? a.name !== n : !1 })), this }, e.prototype.open = function () { return us(this) }, e.prototype._close = function () { var t = this._state, r = gt.indexOf(this); if (r >= 0 && gt.splice(r, 1), this.idbdb) { try { this.idbdb.close() } catch { } this._novip.idbdb = null } t.dbReadyPromise = new E(function (n) { t.dbReadyResolve = n }), t.openCanceller = new E(function (n, i) { t.cancelOpen = i }) }, e.prototype.close = function () { this._close(); var t = this._state; this._options.autoOpen = !1, t.dbOpenError = new I.DatabaseClosed, t.isBeingOpened && t.cancelOpen(t.dbOpenError) }, e.prototype.delete = function () { var t = this, r = arguments.length > 0, n = this._state; return new E(function (i, a) { var o = function () { t.close(); var u = t._deps.indexedDB.deleteDatabase(t.name); u.onsuccess = $(function () { ss(t._deps, t.name), i() }), u.onerror = _e(a), u.onblocked = t._fireOnBlocked }; if (r) throw new I.InvalidArgument("Arguments not allowed in db.delete()"); n.isBeingOpened ? n.dbReadyPromise.then(o) : o() }) }, e.prototype.backendDB = function () { return this.idbdb }, e.prototype.isOpen = function () { return this.idbdb !== null }, e.prototype.hasBeenClosed = function () { var t = this._state.dbOpenError; return t && t.name === "DatabaseClosed" }, e.prototype.hasFailed = function () { return this._state.dbOpenError !== null }, e.prototype.dynamicallyOpened = function () { return this._state.autoSchema }, Object.defineProperty(e.prototype, "tables", { get: function () { var t = this; return V(this._allTables).map(function (r) { return t._allTables[r] }) }, enumerable: !1, configurable: !0 }), e.prototype.transaction = function () { var t = fs.apply(this, arguments); return this._transaction.apply(this, t) }, e.prototype._transaction = function (t, r, n) { var i = this, a = D.trans; (!a || a.db !== this || t.indexOf("!") !== -1) && (a = null); var o = t.indexOf("?") !== -1; t = t.replace("!", "").replace("?", ""); var u, s; try { if (s = r.map(function (f) { var l = f instanceof i.Table ? f.name : f; if (typeof l != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed"); return l }), t == "r" || t === yr) u = yr; else if (t == "rw" || t == gr) u = gr; else throw new I.InvalidArgument("Invalid transaction mode: " + t); if (a) { if (a.mode === yr && u === gr) if (o) a = null; else throw new I.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY"); a && s.forEach(function (f) { if (a && a.storeNames.indexOf(f) === -1) if (o) a = null; else throw new I.SubTransaction("Table " + f + " not included in parent transaction.") }), o && a && !a.active && (a = null) } } catch (f) { return a ? a._promise(null, function (l, p) { p(f) }) : H(f) } var c = Gi.bind(null, this, u, s, a, n); return a ? a._promise(u, c, "lock") : D.trans ? st(D.transless, function () { return i._whenReady(c) }) : this._whenReady(c) }, e.prototype.table = function (t) { if (!ve(this._allTables, t)) throw new I.InvalidTable("Table " + t + " does not exist"); return this._allTables[t] }, e }(), _s = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Cs = function () { function e(t) { this._subscribe = t } return e.prototype.subscribe = function (t, r, n) { return this._subscribe(!t || typeof t == "function" ? { next: t, error: r, complete: n } : t) }, e.prototype[_s] = function () { return this }, e }(); function Vi(e, t) { return V(t).forEach(function (r) { var n = e[r] || (e[r] = new Pe); sr(n, t[r]) }), e } function Ss(e) { return new Cs(function (t) { var r = sn(e); function n(v) { r && ot(); var d = function () { return Le(e, { subscr: v, trans: null }) }, h = D.trans ? st(D.transless, d) : d(); return r && h.then(Ie, Ie), h } var i = !1, a = {}, o = {}, u = { get closed() { return i }, unsubscribe: function () { i = !0, Ue.storagemutated.unsubscribe(l) } }; t.start && t.start(u); var s = !1, c = !1; function f() { return V(o).some(function (v) { return a[v] && ys(a[v], o[v]) }) } var l = function (v) { Vi(a, v), f() && p() }, p = function () { if (!(s || i)) { a = {}; var v = {}, d = n(v); c || (Ue(Pt, l), c = !0), s = !0, Promise.resolve(d).then(function (h) { s = !1, !i && (f() ? p() : (a = {}, o = v, t.next && t.next(h))) }, function (h) { s = !1, t.error && t.error(h), u.unsubscribe() }) } }; return p(), u }) } var Wr; try { Wr = { indexedDB: U.indexedDB || U.mozIndexedDB || U.webkitIndexedDB || U.msIndexedDB, IDBKeyRange: U.IDBKeyRange || U.webkitIDBKeyRange } } catch { Wr = { indexedDB: null, IDBKeyRange: null } } var Ge = Sn; nt(Ge, M(M({}, pr), { delete: function (e) { var t = new Ge(e, { addons: [] }); return t.delete() }, exists: function (e) { return new Ge(e, { addons: [] }).open().then(function (t) { return t.close(), !0 }).catch("NoSuchDatabaseError", function () { return !1 }) }, getDatabaseNames: function (e) { try { return as(Ge.dependencies).then(e) } catch { return H(new I.MissingAPI) } }, defineClass: function () { function e(t) { ce(this, t) } return e }, ignoreTransaction: function (e) { return D.trans ? st(D.transless, e) : e() }, vip: Jr, async: function (e) { return function () { try { var t = Vr(e.apply(this, arguments)); return !t || typeof t.then != "function" ? E.resolve(t) : t } catch (r) { return H(r) } } }, spawn: function (e, t, r) { try { var n = Vr(e.apply(r, t || [])); return !n || typeof n.then != "function" ? E.resolve(n) : n } catch (i) { return H(i) } }, currentTransaction: { get: function () { return D.trans || null } }, waitFor: function (e, t) { var r = E.resolve(typeof e == "function" ? Ge.ignoreTransaction(e) : e).timeout(t || 6e4); return D.trans ? D.trans.waitFor(r) : r }, Promise: E, debug: { get: function () { return Ce }, set: function (e) { Ti(e, e === "dexie" ? function () { return !0 } : Fi) } }, derive: it, extend: ce, props: nt, override: yi, Events: At, on: Ue, liveQuery: Ss, extendObservabilitySet: Vi, getByKeyPath: we, setByKeyPath: be, delByKeyPath: Za, shallowClone: _i, deepClone: Dt, getObjectDiff: _n, cmp: se, asap: gi, minKey: Lr, addons: [], connections: gt, errnames: un, dependencies: Wr, semVer: Mn, version: Mn.split(".").map(function (e) { return parseInt(e) }).reduce(function (e, t, r) { return e + t / Math.pow(10, r * 2) }) })); Ge.maxKey = Et(Ge.dependencies.IDBKeyRange); typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ue(Pt, function (e) { if (!xe) { var t; dr ? (t = document.createEvent("CustomEvent"), t.initCustomEvent(Ke, !0, !0, e)) : t = new CustomEvent(Ke, { detail: e }), xe = !0, dispatchEvent(t), xe = !1 } }), addEventListener(Ke, function (e) { var t = e.detail; xe || cr(t) })); function cr(e) { var t = xe; try { xe = !0, Ue.storagemutated.fire(e) } finally { xe = t } } var xe = !1; if (typeof BroadcastChannel < "u") { var zn = new BroadcastChannel(Ke); Ue(Pt, function (e) { xe || zn.postMessage(e) }), zn.onmessage = function (e) { e.data && cr(e.data) } } else if (typeof self < "u" && typeof navigator < "u") { Ue(Pt, function (e) { try { xe || (typeof localStorage < "u" && localStorage.setItem(Ke, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && Pr([], self.clients.matchAll({ includeUncontrolled: !0 }), !0).forEach(function (t) { return t.postMessage({ type: Ke, changedParts: e }) })) } catch { } }), typeof addEventListener < "u" && addEventListener("storage", function (e) { if (e.key === Ke) { var t = JSON.parse(e.newValue); t && cr(t.changedParts) } }); var $n = self.document && navigator.serviceWorker; $n && $n.addEventListener("message", Ts) } function Ts(e) { var t = e.data; t && t.type === Ke && cr(t.changedParts) } E.rejectionMapper = co; Ti(Ce, Fi); class ks { constructor(t, r, n, i, a, o, u, s, c, f, l, p, v, d) { R(this, "id"); R(this, "brand"); R(this, "material"); R(this, "color"); R(this, "cost"); R(this, "currency"); R(this, "status"); R(this, "weightTotal"); R(this, "weightPrinted"); R(this, "density"); R(this, "diameter"); R(this, "dateBought"); R(this, "nozzleTemperature"); R(this, "bedTemperature"); R(this, "filamentDepletedCutoff"); this.id = t, this.brand = r, this.material = n, this.color = i, this.cost = a, this.currency = o, this.status = "loaded", this.weightTotal = u, this.weightPrinted = s, this.diameter = f, this.density = c, this.dateBought = l, this.nozzleTemperature = p, this.bedTemperature = v, this.filamentDepletedCutoff = d, this.weightTotal - this.weightPrinted < this.filamentDepletedCutoff && (this.status = "depleted") } get name() { return `${this.brand} ${this.material}` } get percentRemaining() { return Math.round((this.weightTotal - this.weightPrinted) / this.weightTotal * 100) } get percentPrinted() { return Math.round(this.weightPrinted / this.weightTotal * 100) } get weightRemaining() { return this.weightTotal - this.weightPrinted } get costPrinted() { return this.cost - this.percentRemaining * this.cost } get costRemaining() { return this.percentRemaining * this.cost } save(t) { z.filaments.update(this.id, t) } add() { z.filaments.add(this) } remove() { z.filaments.delete(this.id) } toString() { return `${this.brand} ${this.material} status: ${this.status}` } } class Hi { constructor(t, r, n, i, a, o) { R(this, "id"); R(this, "fileName"); R(this, "parentDir"); R(this, "isWorkSpaceFile"); R(this, "type"); R(this, "uploaderName"); R(this, "fileContent"); this.id = t, this.fileName = r, this.parentDir = n, this.isWorkSpaceFile = i, this.uploaderName = a, this.type = o } save(t) { z.nanofactoryFiles.update(this.id, t) } add() { z.nanofactoryFiles.add(this) } remove() { z.nanofactoryFiles.delete(this.id) } } class Wi { constructor(t) { R(this, "id"); R(this, "peerID"); R(this, "apiKey"); this.id = t } async save(t) { await z.networking.update(this.id, t) } async add() { await z.networking.add(this) } remove() { z.networking.delete(this.id) } } var tt = (e => (e.operational = "Operational", e.offline = "Offline", e.printing = "Printing", e.error = "Error", e.paused = "Paused", e))(tt || {}); class qi { constructor(t) { R(this, "id"); R(this, "name"); R(this, "color"); R(this, "model"); R(this, "volume"); R(this, "heatedBed"); R(this, "heatedChamber"); R(this, "axes"); R(this, "extruder"); R(this, "state"); R(this, "bedLevellingGraph"); R(this, "position"); R(this, "connectionOptions"); R(this, "temperatureHistory"); R(this, "filamentID"); R(this, "isQueuePaused"); R(this, "queuePausedReason"); R(this, "nanofactoryInstallDate"); this.id = t, this.name = "", this.model = "", this.volume = { formFactor: "rectangular", centerOrigin: "center", width: 0, depth: 0, height: 0 }, this.heatedBed = !0, this.heatedChamber = !1, this.nanofactoryInstallDate = new Date, this.state = { status: "Offline" }, this.connectionOptions = { ports: [], baudrates: [], printerProfiles: [], portPreference: "auto", baudratePreference: "auto", printerProfilePreference: "_default", autoconnect: !1 }, this.temperatureHistory = [], this.axes = { x: { inverted: !1, speed: 0 }, y: { inverted: !1, speed: 0 }, z: { inverted: !1, speed: 0 }, e: { inverted: !1, speed: 0 } }, this.extruder = { count: 1, offsets: [] }, this.position = { x: 0, y: 0, z: 0, e: 0, relative: !1, speed: 0 }, this.filamentID = "", this.isQueuePaused = !0, this.queuePausedReason = "Printer has not been assigned a job" } async save(t) { await z.printer.update(this.id, t) } async add() { await z.printer.add(this) } remove() { z.printer.delete(this.id) } toString() { return `${this.model} ${this.name} status: ${this.state.status}` } } class Yi { constructor(t, r, n, i, a, o, u, s, c, f) { R(this, "id"); R(this, "printerID"); R(this, "jobName"); R(this, "status"); R(this, "assignerName"); R(this, "estimatedPrintTime"); R(this, "lastPrintTime"); R(this, "estimatedFilamentUsage"); R(this, "actualFilamentUsage"); R(this, "progress"); R(this, "createdDate"); R(this, "startTime"); R(this, "endTime"); R(this, "queuePosition"); R(this, "file"); R(this, "filamentID"); this.id = t, this.printerID = r, this.jobName = n, this.status = "To Print", this.assignerName = i, this.estimatedPrintTime = a != null ? a : 0, this.estimatedFilamentUsage = o != null ? o : { length: 0, volume: 0 }, this.actualFilamentUsage = { length: 0, volume: 0 }, this.createdDate = u != null ? u : new Date, this.progress = { completion: 0, filePosition: 0, printTime: 0, printTimeLeft: 0 }, this.queuePosition = s, this.file = c, this.filamentID = f } async calculatePosition() { let t = 0, r = await z.printJobs.reverse().sortBy("queuePosition"); r.length > 0 && (t = r[0].queuePosition), this.queuePosition = t + 1 } async add() { await this.calculatePosition(), z.printJobs.add(this) } remove() { z.printJobs.delete(this.id) } save(t) { z.printJobs.update(this.id, t) } async getEstimatedFilamentWeight() { let t = await z.filaments.get(this.filamentID); return t ? t.density * this.estimatedFilamentUsage.volume : 0 } async getUsedFilamentWeight() { let t = await z.filaments.get(this.filamentID); return t ? t.density * this.actualFilamentUsage.volume : 0 } toString() { return `${this.jobName}` } } class Ps extends Sn { constructor() { super("NanofactoryDatabase"); R(this, "printer"); R(this, "networking"); R(this, "printJobs"); R(this, "filaments"); R(this, "nanofactoryFiles"); this.version(1).stores({ printer: "id", networking: "id, peerID, apiKey", printJobs: "id,filamentID", filaments: "id", nanofactoryFiles: "id, filename" }), this.printer.mapToClass(qi), this.networking.mapToClass(Wi), this.printJobs.mapToClass(Yi), this.filaments.mapToClass(ks), this.nanofactoryFiles.mapToClass(Hi) } } let z; async function Es() { z = new Ps, z.open() } let qr = "", Xi, dt, Re = 1; async function Rs(e, t, r, n, i) { switch (r) { case re.jobCreated: let a = new Hi(n.file.id, n.file.fileName, n.file.parentDir, n.file.isWorkspaceFile, n.file.uploaderName, n.file.type); a.fileContent = new Blob([i], { type: "text/plain;charset=utf-8" }); let o = new Yi(n.id, n.printerID, n.jobName, n.assignerName, n.estimatedPrintTime, n.estimatedFilamentUsage, n.createdDate, n.queuePosition, a, n.filamentID); a.add(), o.add(), await Ha(a.fileContent, n), (await z.printer.toArray())[0].state.status === tt.operational && (Wa(a.fileName + ".gcode"), qr = n.id, an(t, { data: { id: qr, startTime: new Date().toISOString() } }, re.jobPrinting), setTimeout(async () => { let u = await vi(); console.log("Job Information", u), Re = u.estimatedPrintTime / 600, Re < 1 ? Re = 1 : Re > 30 && (Re = 30) }, 2e3)); break; case re.currentJobUpdatesRequest: setTimeout(() => xs(t), 5e3); break } } function xs(e) { const t = { label: re.currentJobUpdatesResponse, metadata: e, serialization: "json", reliable: !0 }; dt = ye.connect(e, t), dt.on("open", function () { console.log("jobProgress connection is open " + e), Re || (Re = 1), console.log("Gap for polling: " + Re), Xi = setInterval(Ds, Re * 1e3) }), dt.on("error", function () { dt = ye.connect(e, t) }) } async function Ds() { let e = await vi(), t = { data: { id: qr, progress: { completion: parseFloat(e.progress.completion).toFixed(1) }, estimatedFilamentUsage: { length: 0, volume: 0 }, actualFilamentUsage: { length: 0, volume: 0 } } }; dt.send(JSON.stringify(t)), parseFloat(e.progress.completion) > 99.5 && (console.log("Stopping polling"), clearInterval(Xi)) } const ws = [re.jobCreated, re.actionCreated, re.actionModified]; function Os(e, t, r, n) { let i = ""; switch (ws.includes(r) ? i = new TextDecoder("utf-8").decode(e) : e = JSON.parse(e), n = JSON.parse(n), r) { case re.syncAllRequest: Is(t); break; case re.connectPrinter: console.log(e), Ja(e.port, e.baudrate, e.autoconnect, e.save); break; case re.disconnectPrinter: Va(); break; case re.jobCreated: case re.currentJobUpdatesRequest: Rs(e, t, r, n, i); break; case re.handshakeRequest: As(t); break; default: console.log("Unhandled label: " + r); break } } async function Is(e) { let t = { printer_profile: {}, current_position: { x: 0, y: 0, z: 0, e: 0, speed: 0, relative: !1 }, bed_levelling_data: [], queue_state: { isQueuePaused: !1, queuePausedReason: "testing" }, current_job: { id: "" }, print_queue: [], jobs_history: [], current_filament: { current_filament: {} }, scripts: {} }; t.printer_profile = (await z.printer.toArray())[0], an(e, t, re.syncAllResponse) } async function As(e) { an(e, { status: (await z.printer.toArray())[0].state.status }, re.handshakeResponse) } var Tn = { exports: {} }; (function (e) { var t = {}; t.useBlobBuilder = function () { try { return new Blob([]), !1 } catch { return !0 } }(), t.useArrayBufferView = !t.useBlobBuilder && function () { try { return new Blob([new Uint8Array([])]).size === 0 } catch { return !0 } }(), e.exports.binaryFeatures = t; var r = e.exports.BlobBuilder; typeof window < "u" && (r = e.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder); function n() { this._pieces = [], this._parts = [] } n.prototype.append = function (i) { typeof i == "number" ? this._pieces.push(i) : (this.flush(), this._parts.push(i)) }, n.prototype.flush = function () { if (this._pieces.length > 0) { var i = new Uint8Array(this._pieces); t.useArrayBufferView || (i = i.buffer), this._parts.push(i), this._pieces = [] } }, n.prototype.getBuffer = function () { if (this.flush(), t.useBlobBuilder) { for (var i = new r, a = 0, o = this._parts.length; a < o; a++)i.append(this._parts[a]); return i.getBlob() } else return new Blob(this._parts) }, e.exports.BufferBuilder = n })(Tn); var Ms = Tn.exports.BufferBuilder, Gn = Tn.exports.binaryFeatures, Bs = { unpack: function (e) { var t = new Q(e); return t.unpack() }, pack: function (e) { var t = new Z; t.pack(e); var r = t.getBuffer(); return r } }, Jn = Bs; function Q(e) { this.index = 0, this.dataBuffer = e, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength } Q.prototype.unpack = function () { var e = this.unpack_uint8(); if (e < 128) return e; if ((e ^ 224) < 32) return (e ^ 224) - 32; var t; if ((t = e ^ 160) <= 15) return this.unpack_raw(t); if ((t = e ^ 176) <= 15) return this.unpack_string(t); if ((t = e ^ 144) <= 15) return this.unpack_array(t); if ((t = e ^ 128) <= 15) return this.unpack_map(t); switch (e) { case 192: return null; case 193: return; case 194: return !1; case 195: return !0; case 202: return this.unpack_float(); case 203: return this.unpack_double(); case 204: return this.unpack_uint8(); case 205: return this.unpack_uint16(); case 206: return this.unpack_uint32(); case 207: return this.unpack_uint64(); case 208: return this.unpack_int8(); case 209: return this.unpack_int16(); case 210: return this.unpack_int32(); case 211: return this.unpack_int64(); case 212: return; case 213: return; case 214: return; case 215: return; case 216: return t = this.unpack_uint16(), this.unpack_string(t); case 217: return t = this.unpack_uint32(), this.unpack_string(t); case 218: return t = this.unpack_uint16(), this.unpack_raw(t); case 219: return t = this.unpack_uint32(), this.unpack_raw(t); case 220: return t = this.unpack_uint16(), this.unpack_array(t); case 221: return t = this.unpack_uint32(), this.unpack_array(t); case 222: return t = this.unpack_uint16(), this.unpack_map(t); case 223: return t = this.unpack_uint32(), this.unpack_map(t) } }; Q.prototype.unpack_uint8 = function () { var e = this.dataView[this.index] & 255; return this.index++, e }; Q.prototype.unpack_uint16 = function () { var e = this.read(2), t = (e[0] & 255) * 256 + (e[1] & 255); return this.index += 2, t }; Q.prototype.unpack_uint32 = function () { var e = this.read(4), t = ((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]; return this.index += 4, t }; Q.prototype.unpack_uint64 = function () { var e = this.read(8), t = ((((((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]) * 256 + e[4]) * 256 + e[5]) * 256 + e[6]) * 256 + e[7]; return this.index += 8, t }; Q.prototype.unpack_int8 = function () { var e = this.unpack_uint8(); return e < 128 ? e : e - (1 << 8) }; Q.prototype.unpack_int16 = function () { var e = this.unpack_uint16(); return e < 32768 ? e : e - (1 << 16) }; Q.prototype.unpack_int32 = function () { var e = this.unpack_uint32(); return e < Math.pow(2, 31) ? e : e - Math.pow(2, 32) }; Q.prototype.unpack_int64 = function () { var e = this.unpack_uint64(); return e < Math.pow(2, 63) ? e : e - Math.pow(2, 64) }; Q.prototype.unpack_raw = function (e) { if (this.length < this.index + e) throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + e + " " + this.length); var t = this.dataBuffer.slice(this.index, this.index + e); return this.index += e, t }; Q.prototype.unpack_string = function (e) { for (var t = this.read(e), r = 0, n = "", i, a; r < e;)i = t[r], i < 128 ? (n += String.fromCharCode(i), r++) : (i ^ 192) < 32 ? (a = (i ^ 192) << 6 | t[r + 1] & 63, n += String.fromCharCode(a), r += 2) : (a = (i & 15) << 12 | (t[r + 1] & 63) << 6 | t[r + 2] & 63, n += String.fromCharCode(a), r += 3); return this.index += e, n }; Q.prototype.unpack_array = function (e) { for (var t = new Array(e), r = 0; r < e; r++)t[r] = this.unpack(); return t }; Q.prototype.unpack_map = function (e) { for (var t = {}, r = 0; r < e; r++) { var n = this.unpack(), i = this.unpack(); t[n] = i } return t }; Q.prototype.unpack_float = function () { var e = this.unpack_uint32(), t = e >> 31, r = (e >> 23 & 255) - 127, n = e & 8388607 | 8388608; return (t === 0 ? 1 : -1) * n * Math.pow(2, r - 23) }; Q.prototype.unpack_double = function () { var e = this.unpack_uint32(), t = this.unpack_uint32(), r = e >> 31, n = (e >> 20 & 2047) - 1023, i = e & 1048575 | 1048576, a = i * Math.pow(2, n - 20) + t * Math.pow(2, n - 52); return (r === 0 ? 1 : -1) * a }; Q.prototype.read = function (e) { var t = this.index; if (t + e <= this.length) return this.dataView.subarray(t, t + e); throw new Error("BinaryPackFailure: read index out of range") }; function Z() { this.bufferBuilder = new Ms } Z.prototype.getBuffer = function () { return this.bufferBuilder.getBuffer() }; Z.prototype.pack = function (e) { var t = typeof e; if (t === "string") this.pack_string(e); else if (t === "number") Math.floor(e) === e ? this.pack_integer(e) : this.pack_double(e); else if (t === "boolean") e === !0 ? this.bufferBuilder.append(195) : e === !1 && this.bufferBuilder.append(194); else if (t === "undefined") this.bufferBuilder.append(192); else if (t === "object") if (e === null) this.bufferBuilder.append(192); else { var r = e.constructor; if (r == Array) this.pack_array(e); else if (r == Blob || r == File || e instanceof Blob || e instanceof File) this.pack_bin(e); else if (r == ArrayBuffer) Gn.useArrayBufferView ? this.pack_bin(new Uint8Array(e)) : this.pack_bin(e); else if ("BYTES_PER_ELEMENT" in e) Gn.useArrayBufferView ? this.pack_bin(new Uint8Array(e.buffer)) : this.pack_bin(e.buffer); else if (r == Object || r.toString().startsWith("class")) this.pack_object(e); else if (r == Date) this.pack_string(e.toString()); else if (typeof e.toBinaryPack == "function") this.bufferBuilder.append(e.toBinaryPack()); else throw new Error('Type "' + r.toString() + '" not yet supported') } else throw new Error('Type "' + t + '" not yet supported'); this.bufferBuilder.flush() }; Z.prototype.pack_bin = function (e) { var t = e.length || e.byteLength || e.size; if (t <= 15) this.pack_uint8(160 + t); else if (t <= 65535) this.bufferBuilder.append(218), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(219), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; Z.prototype.pack_string = function (e) { var t = Fs(e); if (t <= 15) this.pack_uint8(176 + t); else if (t <= 65535) this.bufferBuilder.append(216), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(217), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; Z.prototype.pack_array = function (e) { var t = e.length; if (t <= 15) this.pack_uint8(144 + t); else if (t <= 65535) this.bufferBuilder.append(220), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(221), this.pack_uint32(t); else throw new Error("Invalid length"); for (var r = 0; r < t; r++)this.pack(e[r]) }; Z.prototype.pack_integer = function (e) { if (e >= -32 && e <= 127) this.bufferBuilder.append(e & 255); else if (e >= 0 && e <= 255) this.bufferBuilder.append(204), this.pack_uint8(e); else if (e >= -128 && e <= 127) this.bufferBuilder.append(208), this.pack_int8(e); else if (e >= 0 && e <= 65535) this.bufferBuilder.append(205), this.pack_uint16(e); else if (e >= -32768 && e <= 32767) this.bufferBuilder.append(209), this.pack_int16(e); else if (e >= 0 && e <= 4294967295) this.bufferBuilder.append(206), this.pack_uint32(e); else if (e >= -2147483648 && e <= 2147483647) this.bufferBuilder.append(210), this.pack_int32(e); else if (e >= -9223372036854776e3 && e <= 9223372036854776e3) this.bufferBuilder.append(211), this.pack_int64(e); else if (e >= 0 && e <= 18446744073709552e3) this.bufferBuilder.append(207), this.pack_uint64(e); else throw new Error("Invalid integer") }; Z.prototype.pack_double = function (e) { var t = 0; e < 0 && (t = 1, e = -e); var r = Math.floor(Math.log(e) / Math.LN2), n = e / Math.pow(2, r) - 1, i = Math.floor(n * Math.pow(2, 52)), a = Math.pow(2, 32), o = t << 31 | r + 1023 << 20 | i / a & 1048575, u = i % a; this.bufferBuilder.append(203), this.pack_int32(o), this.pack_int32(u) }; Z.prototype.pack_object = function (e) { var t = Object.keys(e), r = t.length; if (r <= 15) this.pack_uint8(128 + r); else if (r <= 65535) this.bufferBuilder.append(222), this.pack_uint16(r); else if (r <= 4294967295) this.bufferBuilder.append(223), this.pack_uint32(r); else throw new Error("Invalid length"); for (var n in e) e.hasOwnProperty(n) && (this.pack(n), this.pack(e[n])) }; Z.prototype.pack_uint8 = function (e) { this.bufferBuilder.append(e) }; Z.prototype.pack_uint16 = function (e) { this.bufferBuilder.append(e >> 8), this.bufferBuilder.append(e & 255) }; Z.prototype.pack_uint32 = function (e) { var t = e & 4294967295; this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255) }; Z.prototype.pack_uint64 = function (e) { var t = e / Math.pow(2, 32), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; Z.prototype.pack_int8 = function (e) { this.bufferBuilder.append(e & 255) }; Z.prototype.pack_int16 = function (e) { this.bufferBuilder.append((e & 65280) >> 8), this.bufferBuilder.append(e & 255) }; Z.prototype.pack_int32 = function (e) { this.bufferBuilder.append(e >>> 24 & 255), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255) }; Z.prototype.pack_int64 = function (e) { var t = Math.floor(e / Math.pow(2, 32)), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; function js(e) { var t = e.charCodeAt(0); return t <= 2047 ? "00" : t <= 65535 ? "000" : t <= 2097151 ? "0000" : t <= 67108863 ? "00000" : "000000" } function Fs(e) { return e.length > 600 ? new Blob([e]).size : e.replace(/[^\u0000-\u007F]/g, js).length } let Qi = !0, Zi = !0; function ht(e, t, r) { const n = e.match(t); return n && n.length >= r && parseInt(n[r], 10) } function ct(e, t, r) { if (!e.RTCPeerConnection) return; const n = e.RTCPeerConnection.prototype, i = n.addEventListener; n.addEventListener = function (o, u) { if (o !== t) return i.apply(this, arguments); const s = c => { const f = r(c); f && (u.handleEvent ? u.handleEvent(f) : u(f)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(u, s), i.apply(this, [o, s]) }; const a = n.removeEventListener; n.removeEventListener = function (o, u) { if (o !== t || !this._eventMap || !this._eventMap[t]) return a.apply(this, arguments); if (!this._eventMap[t].has(u)) return a.apply(this, arguments); const s = this._eventMap[t].get(u); return this._eventMap[t].delete(u), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, a.apply(this, [o, s]) }, Object.defineProperty(n, "on" + t, { get() { return this["_on" + t] }, set(o) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), o && this.addEventListener(t, this["_on" + t] = o) }, enumerable: !0, configurable: !0 }) } function Ks(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Qi = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function Ls(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Zi = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function kn() { if (typeof window == "object") { if (Qi) return; typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments) } } function vr(e, t) { !Zi || console.warn(e + " is deprecated, please use " + t + " instead.") } function Ns(e) { const t = { browser: null, version: null }; if (typeof e > "u" || !e.navigator) return t.browser = "Not a browser.", t; const { navigator: r } = e; if (r.mozGetUserMedia) t.browser = "firefox", t.version = ht(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || e.isSecureContext === !1 && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = ht(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (r.mediaDevices && r.userAgent.match(/Edge\/(\d+).(\d+)$/)) t.browser = "edge", t.version = ht(r.userAgent, /Edge\/(\d+).(\d+)$/, 2); else if (e.RTCPeerConnection && r.userAgent.match(/AppleWebKit\/(\d+)\./)) t.browser = "safari", t.version = ht(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype; else return t.browser = "Not a supported browser.", t; return t } function Vn(e) { return Object.prototype.toString.call(e) === "[object Object]" } function ea(e) { return Vn(e) ? Object.keys(e).reduce(function (t, r) { const n = Vn(e[r]), i = n ? ea(e[r]) : e[r], a = n && !Object.keys(i).length; return i === void 0 || a ? t : Object.assign(t, { [r]: i }) }, {}) : e } function Yr(e, t, r) { !t || r.has(t.id) || (r.set(t.id, t), Object.keys(t).forEach(n => { n.endsWith("Id") ? Yr(e, e.get(t[n]), r) : n.endsWith("Ids") && t[n].forEach(i => { Yr(e, e.get(i), r) }) })) } function Hn(e, t, r) { const n = r ? "outbound-rtp" : "inbound-rtp", i = new Map; if (t === null) return i; const a = []; return e.forEach(o => { o.type === "track" && o.trackIdentifier === t.id && a.push(o) }), a.forEach(o => { e.forEach(u => { u.type === n && u.trackId === o.id && Yr(e, u, i) }) }), i } const Wn = kn; function ta(e, t) { const r = e && e.navigator; if (!r.mediaDevices) return; const n = function (u) { if (typeof u != "object" || u.mandatory || u.optional) return u; const s = {}; return Object.keys(u).forEach(c => { if (c === "require" || c === "advanced" || c === "mediaSource") return; const f = typeof u[c] == "object" ? u[c] : { ideal: u[c] }; f.exact !== void 0 && typeof f.exact == "number" && (f.min = f.max = f.exact); const l = function (p, v) { return p ? p + v.charAt(0).toUpperCase() + v.slice(1) : v === "deviceId" ? "sourceId" : v }; if (f.ideal !== void 0) { s.optional = s.optional || []; let p = {}; typeof f.ideal == "number" ? (p[l("min", c)] = f.ideal, s.optional.push(p), p = {}, p[l("max", c)] = f.ideal, s.optional.push(p)) : (p[l("", c)] = f.ideal, s.optional.push(p)) } f.exact !== void 0 && typeof f.exact != "number" ? (s.mandatory = s.mandatory || {}, s.mandatory[l("", c)] = f.exact) : ["min", "max"].forEach(p => { f[p] !== void 0 && (s.mandatory = s.mandatory || {}, s.mandatory[l(p, c)] = f[p]) }) }), u.advanced && (s.optional = (s.optional || []).concat(u.advanced)), s }, i = function (u, s) { if (t.version >= 61) return s(u); if (u = JSON.parse(JSON.stringify(u)), u && typeof u.audio == "object") { const c = function (f, l, p) { l in f && !(p in f) && (f[p] = f[l], delete f[l]) }; u = JSON.parse(JSON.stringify(u)), c(u.audio, "autoGainControl", "googAutoGainControl"), c(u.audio, "noiseSuppression", "googNoiseSuppression"), u.audio = n(u.audio) } if (u && typeof u.video == "object") { let c = u.video.facingMode; c = c && (typeof c == "object" ? c : { ideal: c }); const f = t.version < 66; if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && !(r.mediaDevices.getSupportedConstraints && r.mediaDevices.getSupportedConstraints().facingMode && !f)) { delete u.video.facingMode; let l; if (c.exact === "environment" || c.ideal === "environment" ? l = ["back", "rear"] : (c.exact === "user" || c.ideal === "user") && (l = ["front"]), l) return r.mediaDevices.enumerateDevices().then(p => { p = p.filter(d => d.kind === "videoinput"); let v = p.find(d => l.some(h => d.label.toLowerCase().includes(h))); return !v && p.length && l.includes("back") && (v = p[p.length - 1]), v && (u.video.deviceId = c.exact ? { exact: v.deviceId } : { ideal: v.deviceId }), u.video = n(u.video), Wn("chrome: " + JSON.stringify(u)), s(u) }) } u.video = n(u.video) } return Wn("chrome: " + JSON.stringify(u)), s(u) }, a = function (u) { return t.version >= 64 ? u : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[u.name] || u.name, message: u.message, constraint: u.constraint || u.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }, o = function (u, s, c) { i(u, f => { r.webkitGetUserMedia(f, s, l => { c && c(a(l)) }) }) }; if (r.getUserMedia = o.bind(r), r.mediaDevices.getUserMedia) { const u = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = function (s) { return i(s, c => u(c).then(f => { if (c.audio && !f.getAudioTracks().length || c.video && !f.getVideoTracks().length) throw f.getTracks().forEach(l => { l.stop() }), new DOMException("", "NotFoundError"); return f }, f => Promise.reject(a(f)))) } } } function Us(e, t) { if (!(e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices) && !!e.navigator.mediaDevices) { if (typeof t != "function") { console.error("shimGetDisplayMedia: getSourceId argument is not a function"); return } e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then(i => { const a = n.video && n.video.width, o = n.video && n.video.height, u = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: i, maxFrameRate: u || 3 } }, a && (n.video.mandatory.maxWidth = a), o && (n.video.mandatory.maxHeight = o), e.navigator.mediaDevices.getUserMedia(n) }) } } } function ra(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function na(e) { if (typeof e == "object" && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(r) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = r) }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = n => { n.stream.addEventListener("addtrack", i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.track.id) : a = { track: i.track }; const o = new Event("track"); o.track = i.track, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }), n.stream.getTracks().forEach(i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.id) : a = { track: i }; const o = new Event("track"); o.track = i, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else ct(e, "track", t => (t.transceiver || Object.defineProperty(t, "transceiver", { value: { receiver: t.receiver } }), t)) } function ia(e) { if (typeof e == "object" && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { const t = function (i, a) { return { track: a, get dtmf() { return this._dtmf === void 0 && (a.kind === "audio" ? this._dtmf = i.createDTMFSender(a) : this._dtmf = null), this._dtmf }, _pc: i } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const i = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (u, s) { let c = i.apply(this, arguments); return c || (c = t(this, u), this._senders.push(c)), c }; const a = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (u) { a.apply(this, arguments); const s = this._senders.indexOf(u); s !== -1 && this._senders.splice(s, 1) } } const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (a) { this._senders = this._senders || [], r.apply(this, [a]), a.getTracks().forEach(o => { this._senders.push(t(this, o)) }) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (a) { this._senders = this._senders || [], n.apply(this, [a]), a.getTracks().forEach(o => { const u = this._senders.find(s => s.track === o); u && this._senders.splice(this._senders.indexOf(u), 1) }) } } else if (typeof e == "object" && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function aa(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [n, i, a] = arguments; if (arguments.length > 0 && typeof n == "function") return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof n != "function")) return t.apply(this, []); const o = function (s) { const c = {}; return s.result().forEach(l => { const p = { id: l.id, timestamp: l.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[l.type] || l.type }; l.names().forEach(v => { p[v] = l.stat(v) }), c[p.id] = p }), c }, u = function (s) { return new Map(Object.keys(s).map(c => [c, s[c]])) }; if (arguments.length >= 2) { const s = function (c) { i(u(o(c))) }; return t.apply(this, [s, n]) } return new Promise((s, c) => { t.apply(this, [function (f) { s(u(o(f))) }, c]) }).then(i, a) } } function oa(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!("getStats" in e.RTCRtpSender.prototype)) { const r = e.RTCPeerConnection.prototype.getSenders; r && (e.RTCPeerConnection.prototype.getSenders = function () { const a = r.apply(this, []); return a.forEach(o => o._pc = this), a }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const a = n.apply(this, arguments); return a._pc = this, a }), e.RTCRtpSender.prototype.getStats = function () { const a = this; return this._pc.getStats().then(o => Hn(o, a.track, !0)) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { const r = e.RTCPeerConnection.prototype.getReceivers; r && (e.RTCPeerConnection.prototype.getReceivers = function () { const i = r.apply(this, []); return i.forEach(a => a._pc = this), i }), ct(e, "track", n => (n.receiver._pc = n.srcElement, n)), e.RTCRtpReceiver.prototype.getStats = function () { const i = this; return this._pc.getStats().then(a => Hn(a, i.track, !1)) } } if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const n = arguments[0]; let i, a, o; return this.getSenders().forEach(u => { u.track === n && (i ? o = !0 : i = u) }), this.getReceivers().forEach(u => (u.track === n && (a ? o = !0 : a = u), u.track === n)), o || i && a ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : i ? i.getStats() : a ? a.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) } } function sa(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(o => this._shimmedLocalStreams[o][0]) }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (o, u) { if (!u) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const s = t.apply(this, arguments); return this._shimmedLocalStreams[u.id] ? this._shimmedLocalStreams[u.id].indexOf(s) === -1 && this._shimmedLocalStreams[u.id].push(s) : this._shimmedLocalStreams[u.id] = [u, s], s }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (o) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o.getTracks().forEach(c => { if (this.getSenders().find(l => l.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError") }); const u = this.getSenders(); r.apply(this, arguments); const s = this.getSenders().filter(c => u.indexOf(c) === -1); this._shimmedLocalStreams[o.id] = [o].concat(s) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[o.id], n.apply(this, arguments) }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o && Object.keys(this._shimmedLocalStreams).forEach(u => { const s = this._shimmedLocalStreams[u].indexOf(o); s !== -1 && this._shimmedLocalStreams[u].splice(s, 1), this._shimmedLocalStreams[u].length === 1 && delete this._shimmedLocalStreams[u] }), i.apply(this, arguments) } } function ca(e, t) { if (!e.RTCPeerConnection) return; if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return sa(e); const r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const f = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, f.map(l => this._reverseStreams[l.id]) }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (f) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, f.getTracks().forEach(l => { if (this.getSenders().find(v => v.track === l)) throw new DOMException("Track already exists.", "InvalidAccessError") }), !this._reverseStreams[f.id]) { const l = new e.MediaStream(f.getTracks()); this._streams[f.id] = l, this._reverseStreams[l.id] = f, f = l } n.apply(this, [f]) }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (f) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[f.id] || f]), delete this._reverseStreams[this._streams[f.id] ? this._streams[f.id].id : f.id], delete this._streams[f.id] }, e.RTCPeerConnection.prototype.addTrack = function (f, l) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const p = [].slice.call(arguments, 1); if (p.length !== 1 || !p[0].getTracks().find(h => h === f)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find(h => h.track === f)) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const d = this._streams[l.id]; if (d) d.addTrack(f), Promise.resolve().then(() => { this.dispatchEvent(new Event("negotiationneeded")) }); else { const h = new e.MediaStream([f]); this._streams[l.id] = h, this._reverseStreams[h.id] = l, this.addStream(h) } return this.getSenders().find(h => h.track === f) }; function a(c, f) { let l = f.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const v = c._reverseStreams[p], d = c._streams[v.id]; l = l.replace(new RegExp(d.id, "g"), v.id) }), new RTCSessionDescription({ type: f.type, sdp: l }) } function o(c, f) { let l = f.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const v = c._reverseStreams[p], d = c._streams[v.id]; l = l.replace(new RegExp(v.id, "g"), d.id) }), new RTCSessionDescription({ type: f.type, sdp: l }) } ["createOffer", "createAnswer"].forEach(function (c) { const f = e.RTCPeerConnection.prototype[c], l = { [c]() { const p = arguments; return arguments.length && typeof arguments[0] == "function" ? f.apply(this, [d => { const h = a(this, d); p[0].apply(null, [h]) }, d => { p[1] && p[1].apply(null, d) }, arguments[2]]) : f.apply(this, arguments).then(d => a(this, d)) } }; e.RTCPeerConnection.prototype[c] = l[c] }); const u = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return !arguments.length || !arguments[0].type ? u.apply(this, arguments) : (arguments[0] = o(this, arguments[0]), u.apply(this, arguments)) }; const s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { const c = s.get.apply(this); return c.type === "" ? c : a(this, c) } }), e.RTCPeerConnection.prototype.removeTrack = function (f) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!f._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (!(f._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; let p; Object.keys(this._streams).forEach(v => { this._streams[v].getTracks().find(h => f.track === h) && (p = this._streams[v]) }), p && (p.getTracks().length === 1 ? this.removeStream(this._reverseStreams[p.id]) : p.removeTrack(f.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function Xr(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), !!e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (r) { const n = e.RTCPeerConnection.prototype[r], i = { [r]() { return arguments[0] = new (r === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[r] = i[r] }) } function ua(e, t) { ct(e, "negotiationneeded", r => { const n = r.target; if (!((t.version < 72 || n.getConfiguration && n.getConfiguration().sdpSemantics === "plan-b") && n.signalingState !== "stable")) return r }) } const qn = Object.freeze(Object.defineProperty({ __proto__: null, shimMediaStream: ra, shimOnTrack: na, shimGetSendersWithDtmf: ia, shimGetStats: aa, shimSenderReceiverGetStats: oa, shimAddTrackRemoveTrackWithNative: sa, shimAddTrackRemoveTrack: ca, shimPeerConnection: Xr, fixNegotiationNeeded: ua, shimGetUserMedia: ta, shimGetDisplayMedia: Us }, Symbol.toStringTag, { value: "Module" })); function zs(e, t) { let r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(n => { if (n && (n.urls || n.url)) { let i = n.urls || n.url; n.url && !n.urls && vr("RTCIceServer.url", "RTCIceServer.urls"); const a = typeof i == "string"; return a && (i = [i]), i = i.filter(o => { if (o.indexOf("stun:") === 0) return !1; const u = o.startsWith("turn") && !o.startsWith("turn:[") && o.includes("transport=udp"); return u && !r ? (r = !0, !0) : u && !r }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } var Pn = { exports: {} }; (function (e) {
    var t = {}; t.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10) }, t.localCName = t.generateIdentifier(), t.splitLines = function (r) {
        return r.trim().split(`
`).map(function (n) { return n.trim() })
    }, t.splitSections = function (r) {
        var n = r.split(`
m=`); return n.map(function (i, a) {
            return (a > 0 ? "m=" + i : i).trim() + `\r
`})
    }, t.getDescription = function (r) { var n = t.splitSections(r); return n && n[0] }, t.getMediaSections = function (r) { var n = t.splitSections(r); return n.shift(), n }, t.matchPrefix = function (r, n) { return t.splitLines(r).filter(function (i) { return i.indexOf(n) === 0 }) }, t.parseCandidate = function (r) { var n; r.indexOf("a=candidate:") === 0 ? n = r.substring(12).split(" ") : n = r.substring(10).split(" "); for (var i = { foundation: n[0], component: parseInt(n[1], 10), protocol: n[2].toLowerCase(), priority: parseInt(n[3], 10), ip: n[4], address: n[4], port: parseInt(n[5], 10), type: n[7] }, a = 8; a < n.length; a += 2)switch (n[a]) { case "raddr": i.relatedAddress = n[a + 1]; break; case "rport": i.relatedPort = parseInt(n[a + 1], 10); break; case "tcptype": i.tcpType = n[a + 1]; break; case "ufrag": i.ufrag = n[a + 1], i.usernameFragment = n[a + 1]; break; default: i[n[a]] = n[a + 1]; break }return i }, t.writeCandidate = function (r) { var n = []; n.push(r.foundation), n.push(r.component), n.push(r.protocol.toUpperCase()), n.push(r.priority), n.push(r.address || r.ip), n.push(r.port); var i = r.type; return n.push("typ"), n.push(i), i !== "host" && r.relatedAddress && r.relatedPort && (n.push("raddr"), n.push(r.relatedAddress), n.push("rport"), n.push(r.relatedPort)), r.tcpType && r.protocol.toLowerCase() === "tcp" && (n.push("tcptype"), n.push(r.tcpType)), (r.usernameFragment || r.ufrag) && (n.push("ufrag"), n.push(r.usernameFragment || r.ufrag)), "candidate:" + n.join(" ") }, t.parseIceOptions = function (r) { return r.substr(14).split(" ") }, t.parseRtpMap = function (r) { var n = r.substr(9).split(" "), i = { payloadType: parseInt(n.shift(), 10) }; return n = n[0].split("/"), i.name = n[0], i.clockRate = parseInt(n[1], 10), i.channels = n.length === 3 ? parseInt(n[2], 10) : 1, i.numChannels = i.channels, i }, t.writeRtpMap = function (r) {
        var n = r.payloadType; r.preferredPayloadType !== void 0 && (n = r.preferredPayloadType); var i = r.channels || r.numChannels || 1; return "a=rtpmap:" + n + " " + r.name + "/" + r.clockRate + (i !== 1 ? "/" + i : "") + `\r
`}, t.parseExtmap = function (r) { var n = r.substr(9).split(" "); return { id: parseInt(n[0], 10), direction: n[0].indexOf("/") > 0 ? n[0].split("/")[1] : "sendrecv", uri: n[1] } }, t.writeExtmap = function (r) {
            return "a=extmap:" + (r.id || r.preferredId) + (r.direction && r.direction !== "sendrecv" ? "/" + r.direction : "") + " " + r.uri + `\r
`}, t.parseFmtp = function (r) { for (var n = {}, i, a = r.substr(r.indexOf(" ") + 1).split(";"), o = 0; o < a.length; o++)i = a[o].trim().split("="), n[i[0].trim()] = i[1]; return n }, t.writeFmtp = function (r) {
            var n = "", i = r.payloadType; if (r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.parameters && Object.keys(r.parameters).length) {
                var a = []; Object.keys(r.parameters).forEach(function (o) { r.parameters[o] ? a.push(o + "=" + r.parameters[o]) : a.push(o) }), n += "a=fmtp:" + i + " " + a.join(";") + `\r
`} return n
        }, t.parseRtcpFb = function (r) { var n = r.substr(r.indexOf(" ") + 1).split(" "); return { type: n.shift(), parameter: n.join(" ") } }, t.writeRtcpFb = function (r) {
            var n = "", i = r.payloadType; return r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.rtcpFeedback && r.rtcpFeedback.length && r.rtcpFeedback.forEach(function (a) {
                n += "a=rtcp-fb:" + i + " " + a.type + (a.parameter && a.parameter.length ? " " + a.parameter : "") + `\r
`}), n
        }, t.parseSsrcMedia = function (r) { var n = r.indexOf(" "), i = { ssrc: parseInt(r.substr(7, n - 7), 10) }, a = r.indexOf(":", n); return a > -1 ? (i.attribute = r.substr(n + 1, a - n - 1), i.value = r.substr(a + 1)) : i.attribute = r.substr(n + 1), i }, t.parseSsrcGroup = function (r) { var n = r.substr(13).split(" "); return { semantics: n.shift(), ssrcs: n.map(function (i) { return parseInt(i, 10) }) } }, t.getMid = function (r) { var n = t.matchPrefix(r, "a=mid:")[0]; if (n) return n.substr(6) }, t.parseFingerprint = function (r) { var n = r.substr(14).split(" "); return { algorithm: n[0].toLowerCase(), value: n[1] } }, t.getDtlsParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=fingerprint:"); return { role: "auto", fingerprints: i.map(t.parseFingerprint) } }, t.writeDtlsParameters = function (r, n) {
            var i = "a=setup:" + n + `\r
`; return r.fingerprints.forEach(function (a) {
                i += "a=fingerprint:" + a.algorithm + " " + a.value + `\r
`}), i
        }, t.parseCryptoLine = function (r) { var n = r.substr(9).split(" "); return { tag: parseInt(n[0], 10), cryptoSuite: n[1], keyParams: n[2], sessionParams: n.slice(3) } }, t.writeCryptoLine = function (r) {
            return "a=crypto:" + r.tag + " " + r.cryptoSuite + " " + (typeof r.keyParams == "object" ? t.writeCryptoKeyParams(r.keyParams) : r.keyParams) + (r.sessionParams ? " " + r.sessionParams.join(" ") : "") + `\r
`}, t.parseCryptoKeyParams = function (r) { if (r.indexOf("inline:") !== 0) return null; var n = r.substr(7).split("|"); return { keyMethod: "inline", keySalt: n[0], lifeTime: n[1], mkiValue: n[2] ? n[2].split(":")[0] : void 0, mkiLength: n[2] ? n[2].split(":")[1] : void 0 } }, t.writeCryptoKeyParams = function (r) { return r.keyMethod + ":" + r.keySalt + (r.lifeTime ? "|" + r.lifeTime : "") + (r.mkiValue && r.mkiLength ? "|" + r.mkiValue + ":" + r.mkiLength : "") }, t.getCryptoParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=crypto:"); return i.map(t.parseCryptoLine) }, t.getIceParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=ice-ufrag:")[0], a = t.matchPrefix(r + n, "a=ice-pwd:")[0]; return i && a ? { usernameFragment: i.substr(12), password: a.substr(10) } : null }, t.writeIceParameters = function (r) {
            return "a=ice-ufrag:" + r.usernameFragment + `\r
a=ice-pwd:`+ r.password + `\r
`}, t.parseRtpParameters = function (r) { for (var n = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i = t.splitLines(r), a = i[0].split(" "), o = 3; o < a.length; o++) { var u = a[o], s = t.matchPrefix(r, "a=rtpmap:" + u + " ")[0]; if (s) { var c = t.parseRtpMap(s), f = t.matchPrefix(r, "a=fmtp:" + u + " "); switch (c.parameters = f.length ? t.parseFmtp(f[0]) : {}, c.rtcpFeedback = t.matchPrefix(r, "a=rtcp-fb:" + u + " ").map(t.parseRtcpFb), n.codecs.push(c), c.name.toUpperCase()) { case "RED": case "ULPFEC": n.fecMechanisms.push(c.name.toUpperCase()); break } } } return t.matchPrefix(r, "a=extmap:").forEach(function (l) { n.headerExtensions.push(t.parseExtmap(l)) }), n }, t.writeRtpDescription = function (r, n) {
            var i = ""; i += "m=" + r + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map(function (o) { return o.preferredPayloadType !== void 0 ? o.preferredPayloadType : o.payloadType }).join(" ") + `\r
`, i += `c=IN IP4 0.0.0.0\r
`, i += `a=rtcp:9 IN IP4 0.0.0.0\r
`, n.codecs.forEach(function (o) { i += t.writeRtpMap(o), i += t.writeFmtp(o), i += t.writeRtcpFb(o) }); var a = 0; return n.codecs.forEach(function (o) { o.maxptime > a && (a = o.maxptime) }), a > 0 && (i += "a=maxptime:" + a + `\r
`), i += `a=rtcp-mux\r
`, n.headerExtensions && n.headerExtensions.forEach(function (o) { i += t.writeExtmap(o) }), i
        }, t.parseRtpEncodingParameters = function (r) { var n = [], i = t.parseRtpParameters(r), a = i.fecMechanisms.indexOf("RED") !== -1, o = i.fecMechanisms.indexOf("ULPFEC") !== -1, u = t.matchPrefix(r, "a=ssrc:").map(function (p) { return t.parseSsrcMedia(p) }).filter(function (p) { return p.attribute === "cname" }), s = u.length > 0 && u[0].ssrc, c, f = t.matchPrefix(r, "a=ssrc-group:FID").map(function (p) { var v = p.substr(17).split(" "); return v.map(function (d) { return parseInt(d, 10) }) }); f.length > 0 && f[0].length > 1 && f[0][0] === s && (c = f[0][1]), i.codecs.forEach(function (p) { if (p.name.toUpperCase() === "RTX" && p.parameters.apt) { var v = { ssrc: s, codecPayloadType: parseInt(p.parameters.apt, 10) }; s && c && (v.rtx = { ssrc: c }), n.push(v), a && (v = JSON.parse(JSON.stringify(v)), v.fec = { ssrc: s, mechanism: o ? "red+ulpfec" : "red" }, n.push(v)) } }), n.length === 0 && s && n.push({ ssrc: s }); var l = t.matchPrefix(r, "b="); return l.length && (l[0].indexOf("b=TIAS:") === 0 ? l = parseInt(l[0].substr(7), 10) : l[0].indexOf("b=AS:") === 0 ? l = parseInt(l[0].substr(5), 10) * 1e3 * .95 - 50 * 40 * 8 : l = void 0, n.forEach(function (p) { p.maxBitrate = l })), n }, t.parseRtcpParameters = function (r) { var n = {}, i = t.matchPrefix(r, "a=ssrc:").map(function (u) { return t.parseSsrcMedia(u) }).filter(function (u) { return u.attribute === "cname" })[0]; i && (n.cname = i.value, n.ssrc = i.ssrc); var a = t.matchPrefix(r, "a=rtcp-rsize"); n.reducedSize = a.length > 0, n.compound = a.length === 0; var o = t.matchPrefix(r, "a=rtcp-mux"); return n.mux = o.length > 0, n }, t.parseMsid = function (r) { var n, i = t.matchPrefix(r, "a=msid:"); if (i.length === 1) return n = i[0].substr(7).split(" "), { stream: n[0], track: n[1] }; var a = t.matchPrefix(r, "a=ssrc:").map(function (o) { return t.parseSsrcMedia(o) }).filter(function (o) { return o.attribute === "msid" }); if (a.length > 0) return n = a[0].value.split(" "), { stream: n[0], track: n[1] } }, t.parseSctpDescription = function (r) { var n = t.parseMLine(r), i = t.matchPrefix(r, "a=max-message-size:"), a; i.length > 0 && (a = parseInt(i[0].substr(19), 10)), isNaN(a) && (a = 65536); var o = t.matchPrefix(r, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: n.fmt, maxMessageSize: a }; var u = t.matchPrefix(r, "a=sctpmap:"); if (u.length > 0) { var s = t.matchPrefix(r, "a=sctpmap:")[0].substr(10).split(" "); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: a } } }, t.writeSctpDescription = function (r, n) {
            var i = []; return r.protocol !== "DTLS/SCTP" ? i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + n.port + `\r
`] : i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + n.port + " " + n.protocol + ` 65535\r
`], n.maxMessageSize !== void 0 && i.push("a=max-message-size:" + n.maxMessageSize + `\r
`), i.join("")
        }, t.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, t.writeSessionBoilerplate = function (r, n, i) {
            var a, o = n !== void 0 ? n : 2; r ? a = r : a = t.generateSessionId(); var u = i || "thisisadapterortc"; return `v=0\r
o=`+ u + " " + a + " " + o + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`}, t.writeMediaSection = function (r, n, i, a) {
            var o = t.writeRtpDescription(r.kind, n); if (o += t.writeIceParameters(r.iceGatherer.getLocalParameters()), o += t.writeDtlsParameters(r.dtlsTransport.getLocalParameters(), i === "offer" ? "actpass" : "active"), o += "a=mid:" + r.mid + `\r
`, r.direction ? o += "a=" + r.direction + `\r
`: r.rtpSender && r.rtpReceiver ? o += `a=sendrecv\r
`: r.rtpSender ? o += `a=sendonly\r
`: r.rtpReceiver ? o += `a=recvonly\r
`: o += `a=inactive\r
`, r.rtpSender) {
                var u = "msid:" + a.id + " " + r.rtpSender.track.id + `\r
`; o += "a=" + u, o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " " + u, r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " " + u, o += "a=ssrc-group:FID " + r.sendEncodingParameters[0].ssrc + " " + r.sendEncodingParameters[0].rtx.ssrc + `\r
`)
            } return o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " cname:" + t.localCName + `\r
`, r.rtpSender && r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " cname:" + t.localCName + `\r
`), o
        }, t.getDirection = function (r, n) { for (var i = t.splitLines(r), a = 0; a < i.length; a++)switch (i[a]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return i[a].substr(2) }return n ? t.getDirection(n) : "sendrecv" }, t.getKind = function (r) { var n = t.splitLines(r), i = n[0].split(" "); return i[0].substr(2) }, t.isRejected = function (r) { return r.split(" ", 2)[1] === "0" }, t.parseMLine = function (r) { var n = t.splitLines(r), i = n[0].substr(2).split(" "); return { kind: i[0], port: parseInt(i[1], 10), protocol: i[2], fmt: i.slice(3).join(" ") } }, t.parseOLine = function (r) { var n = t.matchPrefix(r, "o=")[0], i = n.substr(2).split(" "); return { username: i[0], sessionId: i[1], sessionVersion: parseInt(i[2], 10), netType: i[3], addressType: i[4], address: i[5] } }, t.isValidSDP = function (r) { if (typeof r != "string" || r.length === 0) return !1; for (var n = t.splitLines(r), i = 0; i < n.length; i++)if (n[i].length < 2 || n[i].charAt(1) !== "=") return !1; return !0 }, e.exports = t
})(Pn); const Yt = Pn.exports; var O = Pn.exports; function $s(e) { return { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type } function Yn(e, t, r, n, i) {
    var a = O.writeRtpDescription(e.kind, t); if (a += O.writeIceParameters(e.iceGatherer.getLocalParameters()), a += O.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === "offer" ? "actpass" : i || "active"), a += "a=mid:" + e.mid + `\r
`, e.rtpSender && e.rtpReceiver ? a += `a=sendrecv\r
`: e.rtpSender ? a += `a=sendonly\r
`: e.rtpReceiver ? a += `a=recvonly\r
`: a += `a=inactive\r
`, e.rtpSender) {
        var o = e.rtpSender._initialTrackId || e.rtpSender.track.id; e.rtpSender._initialTrackId = o; var u = "msid:" + (n ? n.id : "-") + " " + o + `\r
`; a += "a=" + u, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + u, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + u, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + `\r
`)
    } return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + O.localCName + `\r
`, e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + O.localCName + `\r
`), a
} function Gs(e, t) { var r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(function (n) { if (n && (n.urls || n.url)) { var i = n.urls || n.url; n.url && !n.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead."); var a = typeof i == "string"; return a && (i = [i]), i = i.filter(function (o) { var u = o.indexOf("turn:") === 0 && o.indexOf("transport=udp") !== -1 && o.indexOf("turn:[") === -1 && !r; return u ? (r = !0, !0) : o.indexOf("stun:") === 0 && t >= 14393 && o.indexOf("?transport=udp") === -1 }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } function Ut(e, t) { var r = { codecs: [], headerExtensions: [], fecMechanisms: [] }, n = function (a, o) { a = parseInt(a, 10); for (var u = 0; u < o.length; u++)if (o[u].payloadType === a || o[u].preferredPayloadType === a) return o[u] }, i = function (a, o, u, s) { var c = n(a.parameters.apt, u), f = n(o.parameters.apt, s); return c && f && c.name.toLowerCase() === f.name.toLowerCase() }; return e.codecs.forEach(function (a) { for (var o = 0; o < t.codecs.length; o++) { var u = t.codecs[o]; if (a.name.toLowerCase() === u.name.toLowerCase() && a.clockRate === u.clockRate) { if (a.name.toLowerCase() === "rtx" && a.parameters && u.parameters.apt && !i(a, u, e.codecs, t.codecs)) continue; u = JSON.parse(JSON.stringify(u)), u.numChannels = Math.min(a.numChannels, u.numChannels), r.codecs.push(u), u.rtcpFeedback = u.rtcpFeedback.filter(function (s) { for (var c = 0; c < a.rtcpFeedback.length; c++)if (a.rtcpFeedback[c].type === s.type && a.rtcpFeedback[c].parameter === s.parameter) return !0; return !1 }); break } } }), e.headerExtensions.forEach(function (a) { for (var o = 0; o < t.headerExtensions.length; o++) { var u = t.headerExtensions[o]; if (a.uri === u.uri) { r.headerExtensions.push(u); break } } }), r } function Xn(e, t, r) { return { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t][e].indexOf(r) !== -1 } function Tr(e, t) { var r = e.getRemoteCandidates().find(function (n) { return t.foundation === n.foundation && t.ip === n.ip && t.port === n.port && t.priority === n.priority && t.protocol === n.protocol && t.type === n.type }); return r || e.addRemoteCandidate(t), !r } function te(e, t) { var r = new Error(t); return r.name = e, r.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e], r } var Js = function (e, t) {
    function r(s, c) { c.addTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", { track: s })) } function n(s, c) { c.removeTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", { track: s })) } function i(s, c, f, l) { var p = new Event("track"); p.track = c, p.receiver = f, p.transceiver = { receiver: f }, p.streams = l, e.setTimeout(function () { s._dispatchEvent("track", p) }) } var a = function (s) { var c = this, f = document.createDocumentFragment(); if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (p) { c[p] = f[p].bind(f) }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", s = JSON.parse(JSON.stringify(s || {})), this.usingBundle = s.bundlePolicy === "max-bundle", s.rtcpMuxPolicy === "negotiate") throw te("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported"); switch (s.rtcpMuxPolicy || (s.rtcpMuxPolicy = "require"), s.iceTransportPolicy) { case "all": case "relay": break; default: s.iceTransportPolicy = "all"; break }switch (s.bundlePolicy) { case "balanced": case "max-compat": case "max-bundle": break; default: s.bundlePolicy = "balanced"; break }if (s.iceServers = Gs(s.iceServers || [], t), this._iceGatherers = [], s.iceCandidatePoolSize) for (var l = s.iceCandidatePoolSize; l > 0; l--)this._iceGatherers.push(new e.RTCIceGatherer({ iceServers: s.iceServers, gatherPolicy: s.iceTransportPolicy })); else s.iceCandidatePoolSize = 0; this._config = s, this.transceivers = [], this._sdpSessionId = O.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1 }; Object.defineProperty(a.prototype, "localDescription", { configurable: !0, get: function () { return this._localDescription } }), Object.defineProperty(a.prototype, "remoteDescription", { configurable: !0, get: function () { return this._remoteDescription } }), a.prototype.onicecandidate = null, a.prototype.onaddstream = null, a.prototype.ontrack = null, a.prototype.onremovestream = null, a.prototype.onsignalingstatechange = null, a.prototype.oniceconnectionstatechange = null, a.prototype.onconnectionstatechange = null, a.prototype.onicegatheringstatechange = null, a.prototype.onnegotiationneeded = null, a.prototype.ondatachannel = null, a.prototype._dispatchEvent = function (s, c) { this._isClosed || (this.dispatchEvent(c), typeof this["on" + s] == "function" && this["on" + s](c)) }, a.prototype._emitGatheringStateChange = function () { var s = new Event("icegatheringstatechange"); this._dispatchEvent("icegatheringstatechange", s) }, a.prototype.getConfiguration = function () { return this._config }, a.prototype.getLocalStreams = function () { return this.localStreams }, a.prototype.getRemoteStreams = function () { return this.remoteStreams }, a.prototype._createTransceiver = function (s, c) { var f = this.transceivers.length > 0, l = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: s, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: !0 }; if (this.usingBundle && f) l.iceTransport = this.transceivers[0].iceTransport, l.dtlsTransport = this.transceivers[0].dtlsTransport; else { var p = this._createIceAndDtlsTransports(); l.iceTransport = p.iceTransport, l.dtlsTransport = p.dtlsTransport } return c || this.transceivers.push(l), l }, a.prototype.addTrack = function (s, c) { if (this._isClosed) throw te("InvalidStateError", "Attempted to call addTrack on a closed peerconnection."); var f = this.transceivers.find(function (v) { return v.track === s }); if (f) throw te("InvalidAccessError", "Track already exists."); for (var l, p = 0; p < this.transceivers.length; p++)!this.transceivers[p].track && this.transceivers[p].kind === s.kind && (l = this.transceivers[p]); return l || (l = this._createTransceiver(s.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(c) === -1 && this.localStreams.push(c), l.track = s, l.stream = c, l.rtpSender = new e.RTCRtpSender(s, l.dtlsTransport), l.rtpSender }, a.prototype.addStream = function (s) { var c = this; if (t >= 15025) s.getTracks().forEach(function (l) { c.addTrack(l, s) }); else { var f = s.clone(); s.getTracks().forEach(function (l, p) { var v = f.getTracks()[p]; l.addEventListener("enabled", function (d) { v.enabled = d.enabled }) }), f.getTracks().forEach(function (l) { c.addTrack(l, f) }) } }, a.prototype.removeTrack = function (s) { if (this._isClosed) throw te("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection."); if (!(s instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender."); var c = this.transceivers.find(function (p) { return p.rtpSender === s }); if (!c) throw te("InvalidAccessError", "Sender was not created by this connection."); var f = c.stream; c.rtpSender.stop(), c.rtpSender = null, c.track = null, c.stream = null; var l = this.transceivers.map(function (p) { return p.stream }); l.indexOf(f) === -1 && this.localStreams.indexOf(f) > -1 && this.localStreams.splice(this.localStreams.indexOf(f), 1), this._maybeFireNegotiationNeeded() }, a.prototype.removeStream = function (s) { var c = this; s.getTracks().forEach(function (f) { var l = c.getSenders().find(function (p) { return p.track === f }); l && c.removeTrack(l) }) }, a.prototype.getSenders = function () { return this.transceivers.filter(function (s) { return !!s.rtpSender }).map(function (s) { return s.rtpSender }) }, a.prototype.getReceivers = function () { return this.transceivers.filter(function (s) { return !!s.rtpReceiver }).map(function (s) { return s.rtpReceiver }) }, a.prototype._createIceGatherer = function (s, c) { var f = this; if (c && s > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var l = new e.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(l, "state", { value: "new", writable: !0 }), this.transceivers[s].bufferedCandidateEvents = [], this.transceivers[s].bufferCandidates = function (p) { var v = !p.candidate || Object.keys(p.candidate).length === 0; l.state = v ? "completed" : "gathering", f.transceivers[s].bufferedCandidateEvents !== null && f.transceivers[s].bufferedCandidateEvents.push(p) }, l.addEventListener("localcandidate", this.transceivers[s].bufferCandidates), l }, a.prototype._gather = function (s, c) {
        var f = this, l = this.transceivers[c].iceGatherer; if (!l.onlocalcandidate) {
            var p = this.transceivers[c].bufferedCandidateEvents; this.transceivers[c].bufferedCandidateEvents = null, l.removeEventListener("localcandidate", this.transceivers[c].bufferCandidates), l.onlocalcandidate = function (v) {
                if (!(f.usingBundle && c > 0)) {
                    var d = new Event("icecandidate"); d.candidate = { sdpMid: s, sdpMLineIndex: c }; var h = v.candidate, b = !h || Object.keys(h).length === 0; if (b) (l.state === "new" || l.state === "gathering") && (l.state = "completed"); else { l.state === "new" && (l.state = "gathering"), h.component = 1, h.ufrag = l.getLocalParameters().usernameFragment; var m = O.writeCandidate(h); d.candidate = Object.assign(d.candidate, O.parseCandidate(m)), d.candidate.candidate = m, d.candidate.toJSON = function () { return { candidate: d.candidate.candidate, sdpMid: d.candidate.sdpMid, sdpMLineIndex: d.candidate.sdpMLineIndex, usernameFragment: d.candidate.usernameFragment } } } var g = O.getMediaSections(f._localDescription.sdp); b ? g[d.candidate.sdpMLineIndex] += `a=end-of-candidates\r
`: g[d.candidate.sdpMLineIndex] += "a=" + d.candidate.candidate + `\r
`, f._localDescription.sdp = O.getDescription(f._localDescription.sdp) + g.join(""); var C = f.transceivers.every(function (_) { return _.iceGatherer && _.iceGatherer.state === "completed" }); f.iceGatheringState !== "gathering" && (f.iceGatheringState = "gathering", f._emitGatheringStateChange()), b || f._dispatchEvent("icecandidate", d), C && (f._dispatchEvent("icecandidate", new Event("icecandidate")), f.iceGatheringState = "complete", f._emitGatheringStateChange())
                }
            }, e.setTimeout(function () { p.forEach(function (v) { l.onlocalcandidate(v) }) }, 0)
        }
    }, a.prototype._createIceAndDtlsTransports = function () { var s = this, c = new e.RTCIceTransport(null); c.onicestatechange = function () { s._updateIceConnectionState(), s._updateConnectionState() }; var f = new e.RTCDtlsTransport(c); return f.ondtlsstatechange = function () { s._updateConnectionState() }, f.onerror = function () { Object.defineProperty(f, "state", { value: "failed", writable: !0 }), s._updateConnectionState() }, { iceTransport: c, dtlsTransport: f } }, a.prototype._disposeIceAndDtlsTransports = function (s) { var c = this.transceivers[s].iceGatherer; c && (delete c.onlocalcandidate, delete this.transceivers[s].iceGatherer); var f = this.transceivers[s].iceTransport; f && (delete f.onicestatechange, delete this.transceivers[s].iceTransport); var l = this.transceivers[s].dtlsTransport; l && (delete l.ondtlsstatechange, delete l.onerror, delete this.transceivers[s].dtlsTransport) }, a.prototype._transceive = function (s, c, f) { var l = Ut(s.localCapabilities, s.remoteCapabilities); c && s.rtpSender && (l.encodings = s.sendEncodingParameters, l.rtcp = { cname: O.localCName, compound: s.rtcpParameters.compound }, s.recvEncodingParameters.length && (l.rtcp.ssrc = s.recvEncodingParameters[0].ssrc), s.rtpSender.send(l)), f && s.rtpReceiver && l.codecs.length > 0 && (s.kind === "video" && s.recvEncodingParameters && t < 15019 && s.recvEncodingParameters.forEach(function (p) { delete p.rtx }), s.recvEncodingParameters.length ? l.encodings = s.recvEncodingParameters : l.encodings = [{}], l.rtcp = { compound: s.rtcpParameters.compound }, s.rtcpParameters.cname && (l.rtcp.cname = s.rtcpParameters.cname), s.sendEncodingParameters.length && (l.rtcp.ssrc = s.sendEncodingParameters[0].ssrc), s.rtpReceiver.receive(l)) }, a.prototype.setLocalDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(te("TypeError", 'Unsupported type "' + s.type + '"')); if (!Xn("setLocalDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(te("InvalidStateError", "Can not set local " + s.type + " in state " + c.signalingState)); var f, l; if (s.type === "offer") f = O.splitSections(s.sdp), l = f.shift(), f.forEach(function (v, d) { var h = O.parseRtpParameters(v); c.transceivers[d].localCapabilities = h }), c.transceivers.forEach(function (v, d) { c._gather(v.mid, d) }); else if (s.type === "answer") { f = O.splitSections(c._remoteDescription.sdp), l = f.shift(); var p = O.matchPrefix(l, "a=ice-lite").length > 0; f.forEach(function (v, d) { var h = c.transceivers[d], b = h.iceGatherer, m = h.iceTransport, g = h.dtlsTransport, C = h.localCapabilities, _ = h.remoteCapabilities, y = O.isRejected(v) && O.matchPrefix(v, "a=bundle-only").length === 0; if (!y && !h.rejected) { var S = O.getIceParameters(v, l), P = O.getDtlsParameters(v, l); p && (P.role = "server"), (!c.usingBundle || d === 0) && (c._gather(h.mid, d), m.state === "new" && m.start(b, S, p ? "controlling" : "controlled"), g.state === "new" && g.start(P)); var T = Ut(C, _); c._transceive(h, T.codecs.length > 0, !1) } }) } return c._localDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-local-offer") : c._updateSignalingState("stable"), Promise.resolve() }, a.prototype.setRemoteDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(te("TypeError", 'Unsupported type "' + s.type + '"')); if (!Xn("setRemoteDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(te("InvalidStateError", "Can not set remote " + s.type + " in state " + c.signalingState)); var f = {}; c.remoteStreams.forEach(function (m) { f[m.id] = m }); var l = [], p = O.splitSections(s.sdp), v = p.shift(), d = O.matchPrefix(v, "a=ice-lite").length > 0, h = O.matchPrefix(v, "a=group:BUNDLE ").length > 0; c.usingBundle = h; var b = O.matchPrefix(v, "a=ice-options:")[0]; return b ? c.canTrickleIceCandidates = b.substr(14).split(" ").indexOf("trickle") >= 0 : c.canTrickleIceCandidates = !1, p.forEach(function (m, g) { var C = O.splitLines(m), _ = O.getKind(m), y = O.isRejected(m) && O.matchPrefix(m, "a=bundle-only").length === 0, S = C[0].substr(2).split(" ")[2], P = O.getDirection(m, v), T = O.parseMsid(m), w = O.getMid(m) || O.generateIdentifier(); if (y || _ === "application" && (S === "DTLS/SCTP" || S === "UDP/DTLS/SCTP")) { c.transceivers[g] = { mid: w, kind: _, protocol: S, rejected: !0 }; return } !y && c.transceivers[g] && c.transceivers[g].rejected && (c.transceivers[g] = c._createTransceiver(_, !0)); var k, F, j, B, N, A, ee, Y, W, pe = O.parseRtpParameters(m), oe, me; y || (oe = O.getIceParameters(m, v), me = O.getDtlsParameters(m, v), me.role = "client"), ee = O.parseRtpEncodingParameters(m); var de = O.parseRtcpParameters(m), Ae = O.matchPrefix(m, "a=end-of-candidates", v).length > 0, q = O.matchPrefix(m, "a=candidate:").map(function (fe) { return O.parseCandidate(fe) }).filter(function (fe) { return fe.component === 1 }); if ((s.type === "offer" || s.type === "answer") && !y && h && g > 0 && c.transceivers[g] && (c._disposeIceAndDtlsTransports(g), c.transceivers[g].iceGatherer = c.transceivers[0].iceGatherer, c.transceivers[g].iceTransport = c.transceivers[0].iceTransport, c.transceivers[g].dtlsTransport = c.transceivers[0].dtlsTransport, c.transceivers[g].rtpSender && c.transceivers[g].rtpSender.setTransport(c.transceivers[0].dtlsTransport), c.transceivers[g].rtpReceiver && c.transceivers[g].rtpReceiver.setTransport(c.transceivers[0].dtlsTransport)), s.type === "offer" && !y) { k = c.transceivers[g] || c._createTransceiver(_), k.mid = w, k.iceGatherer || (k.iceGatherer = c._createIceGatherer(g, h)), q.length && k.iceTransport.state === "new" && (Ae && (!h || g === 0) ? k.iceTransport.setRemoteCandidates(q) : q.forEach(function (fe) { Tr(k.iceTransport, fe) })), Y = e.RTCRtpReceiver.getCapabilities(_), t < 15019 && (Y.codecs = Y.codecs.filter(function (fe) { return fe.name !== "rtx" })), A = k.sendEncodingParameters || [{ ssrc: (2 * g + 2) * 1001 }]; var Me = !1; if (P === "sendrecv" || P === "sendonly") { if (Me = !k.rtpReceiver, N = k.rtpReceiver || new e.RTCRtpReceiver(k.dtlsTransport, _), Me) { var Be; W = N.track, T && T.stream === "-" || (T ? (f[T.stream] || (f[T.stream] = new e.MediaStream, Object.defineProperty(f[T.stream], "id", { get: function () { return T.stream } })), Object.defineProperty(W, "id", { get: function () { return T.track } }), Be = f[T.stream]) : (f.default || (f.default = new e.MediaStream), Be = f.default)), Be && (r(W, Be), k.associatedRemoteMediaStreams.push(Be)), l.push([W, N, Be]) } } else k.rtpReceiver && k.rtpReceiver.track && (k.associatedRemoteMediaStreams.forEach(function (fe) { var Dn = fe.getTracks().find(function (La) { return La.id === k.rtpReceiver.track.id }); Dn && n(Dn, fe) }), k.associatedRemoteMediaStreams = []); k.localCapabilities = Y, k.remoteCapabilities = pe, k.rtpReceiver = N, k.rtcpParameters = de, k.sendEncodingParameters = A, k.recvEncodingParameters = ee, c._transceive(c.transceivers[g], !1, Me) } else if (s.type === "answer" && !y) { k = c.transceivers[g], F = k.iceGatherer, j = k.iceTransport, B = k.dtlsTransport, N = k.rtpReceiver, A = k.sendEncodingParameters, Y = k.localCapabilities, c.transceivers[g].recvEncodingParameters = ee, c.transceivers[g].remoteCapabilities = pe, c.transceivers[g].rtcpParameters = de, q.length && j.state === "new" && ((d || Ae) && (!h || g === 0) ? j.setRemoteCandidates(q) : q.forEach(function (fe) { Tr(k.iceTransport, fe) })), (!h || g === 0) && (j.state === "new" && j.start(F, oe, "controlling"), B.state === "new" && B.start(me)); var Fa = Ut(k.localCapabilities, k.remoteCapabilities), Ka = Fa.codecs.filter(function (fe) { return fe.name.toLowerCase() === "rtx" }).length; !Ka && k.sendEncodingParameters[0].rtx && delete k.sendEncodingParameters[0].rtx, c._transceive(k, P === "sendrecv" || P === "recvonly", P === "sendrecv" || P === "sendonly"), N && (P === "sendrecv" || P === "sendonly") ? (W = N.track, T ? (f[T.stream] || (f[T.stream] = new e.MediaStream), r(W, f[T.stream]), l.push([W, N, f[T.stream]])) : (f.default || (f.default = new e.MediaStream), r(W, f.default), l.push([W, N, f.default]))) : delete k.rtpReceiver } }), c._dtlsRole === void 0 && (c._dtlsRole = s.type === "offer" ? "active" : "passive"), c._remoteDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-remote-offer") : c._updateSignalingState("stable"), Object.keys(f).forEach(function (m) { var g = f[m]; if (g.getTracks().length) { if (c.remoteStreams.indexOf(g) === -1) { c.remoteStreams.push(g); var C = new Event("addstream"); C.stream = g, e.setTimeout(function () { c._dispatchEvent("addstream", C) }) } l.forEach(function (_) { var y = _[0], S = _[1]; g.id === _[2].id && i(c, y, S, [g]) }) } }), l.forEach(function (m) { m[2] || i(c, m[0], m[1], []) }), e.setTimeout(function () { !(c && c.transceivers) || c.transceivers.forEach(function (m) { m.iceTransport && m.iceTransport.state === "new" && m.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), m.iceTransport.addRemoteCandidate({})) }) }, 4e3), Promise.resolve() }, a.prototype.close = function () { this.transceivers.forEach(function (s) { s.iceTransport && s.iceTransport.stop(), s.dtlsTransport && s.dtlsTransport.stop(), s.rtpSender && s.rtpSender.stop(), s.rtpReceiver && s.rtpReceiver.stop() }), this._isClosed = !0, this._updateSignalingState("closed") }, a.prototype._updateSignalingState = function (s) { this.signalingState = s; var c = new Event("signalingstatechange"); this._dispatchEvent("signalingstatechange", c) }, a.prototype._maybeFireNegotiationNeeded = function () { var s = this; this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, e.setTimeout(function () { if (s.needNegotiation) { s.needNegotiation = !1; var c = new Event("negotiationneeded"); s._dispatchEvent("negotiationneeded", c) } }, 0)) }, a.prototype._updateIceConnectionState = function () { var s, c = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (l) { l.iceTransport && !l.rejected && c[l.iceTransport.state]++ }), s = "new", c.failed > 0 ? s = "failed" : c.checking > 0 ? s = "checking" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 ? s = "connected" : c.completed > 0 && (s = "completed"), s !== this.iceConnectionState) { this.iceConnectionState = s; var f = new Event("iceconnectionstatechange"); this._dispatchEvent("iceconnectionstatechange", f) } }, a.prototype._updateConnectionState = function () { var s, c = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (l) { l.iceTransport && l.dtlsTransport && !l.rejected && (c[l.iceTransport.state]++, c[l.dtlsTransport.state]++) }), c.connected += c.completed, s = "new", c.failed > 0 ? s = "failed" : c.connecting > 0 ? s = "connecting" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 && (s = "connected"), s !== this.connectionState) { this.connectionState = s; var f = new Event("connectionstatechange"); this._dispatchEvent("connectionstatechange", f) } }, a.prototype.createOffer = function () {
        var s = this; if (s._isClosed) return Promise.reject(te("InvalidStateError", "Can not call createOffer after close")); var c = s.transceivers.filter(function (d) { return d.kind === "audio" }).length, f = s.transceivers.filter(function (d) { return d.kind === "video" }).length, l = arguments[0]; if (l) { if (l.mandatory || l.optional) throw new TypeError("Legacy mandatory/optional constraints not supported."); l.offerToReceiveAudio !== void 0 && (l.offerToReceiveAudio === !0 ? c = 1 : l.offerToReceiveAudio === !1 ? c = 0 : c = l.offerToReceiveAudio), l.offerToReceiveVideo !== void 0 && (l.offerToReceiveVideo === !0 ? f = 1 : l.offerToReceiveVideo === !1 ? f = 0 : f = l.offerToReceiveVideo) } for (s.transceivers.forEach(function (d) { d.kind === "audio" ? (c--, c < 0 && (d.wantReceive = !1)) : d.kind === "video" && (f--, f < 0 && (d.wantReceive = !1)) }); c > 0 || f > 0;)c > 0 && (s._createTransceiver("audio"), c--), f > 0 && (s._createTransceiver("video"), f--); var p = O.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.transceivers.forEach(function (d, h) { var b = d.track, m = d.kind, g = d.mid || O.generateIdentifier(); d.mid = g, d.iceGatherer || (d.iceGatherer = s._createIceGatherer(h, s.usingBundle)); var C = e.RTCRtpSender.getCapabilities(m); t < 15019 && (C.codecs = C.codecs.filter(function (y) { return y.name !== "rtx" })), C.codecs.forEach(function (y) { y.name === "H264" && y.parameters["level-asymmetry-allowed"] === void 0 && (y.parameters["level-asymmetry-allowed"] = "1"), d.remoteCapabilities && d.remoteCapabilities.codecs && d.remoteCapabilities.codecs.forEach(function (S) { y.name.toLowerCase() === S.name.toLowerCase() && y.clockRate === S.clockRate && (y.preferredPayloadType = S.payloadType) }) }), C.headerExtensions.forEach(function (y) { var S = d.remoteCapabilities && d.remoteCapabilities.headerExtensions || []; S.forEach(function (P) { y.uri === P.uri && (y.id = P.id) }) }); var _ = d.sendEncodingParameters || [{ ssrc: (2 * h + 1) * 1001 }]; b && t >= 15019 && m === "video" && !_[0].rtx && (_[0].rtx = { ssrc: _[0].ssrc + 1 }), d.wantReceive && (d.rtpReceiver = new e.RTCRtpReceiver(d.dtlsTransport, m)), d.localCapabilities = C, d.sendEncodingParameters = _ }), s._config.bundlePolicy !== "max-compat" && (p += "a=group:BUNDLE " + s.transceivers.map(function (d) { return d.mid }).join(" ") + `\r
`), p += `a=ice-options:trickle\r
`, s.transceivers.forEach(function (d, h) {
            p += Yn(d, d.localCapabilities, "offer", d.stream, s._dtlsRole), p += `a=rtcp-rsize\r
`, d.iceGatherer && s.iceGatheringState !== "new" && (h === 0 || !s.usingBundle) && (d.iceGatherer.getLocalCandidates().forEach(function (b) {
                b.component = 1, p += "a=" + O.writeCandidate(b) + `\r
`}), d.iceGatherer.state === "completed" && (p += `a=end-of-candidates\r
`))
        }); var v = new e.RTCSessionDescription({ type: "offer", sdp: p }); return Promise.resolve(v)
    }, a.prototype.createAnswer = function () {
        var s = this; if (s._isClosed) return Promise.reject(te("InvalidStateError", "Can not call createAnswer after close")); if (!(s.signalingState === "have-remote-offer" || s.signalingState === "have-local-pranswer")) return Promise.reject(te("InvalidStateError", "Can not call createAnswer in signalingState " + s.signalingState)); var c = O.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.usingBundle && (c += "a=group:BUNDLE " + s.transceivers.map(function (p) { return p.mid }).join(" ") + `\r
`), c += `a=ice-options:trickle\r
`; var f = O.getMediaSections(s._remoteDescription.sdp).length; s.transceivers.forEach(function (p, v) {
            if (!(v + 1 > f)) {
                if (p.rejected) {
                    p.kind === "application" ? p.protocol === "DTLS/SCTP" ? c += `m=application 0 DTLS/SCTP 5000\r
`: c += "m=application 0 " + p.protocol + ` webrtc-datachannel\r
`: p.kind === "audio" ? c += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
`: p.kind === "video" && (c += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), c += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:`+ p.mid + `\r
`; return
                } if (p.stream) { var d; p.kind === "audio" ? d = p.stream.getAudioTracks()[0] : p.kind === "video" && (d = p.stream.getVideoTracks()[0]), d && t >= 15019 && p.kind === "video" && !p.sendEncodingParameters[0].rtx && (p.sendEncodingParameters[0].rtx = { ssrc: p.sendEncodingParameters[0].ssrc + 1 }) } var h = Ut(p.localCapabilities, p.remoteCapabilities), b = h.codecs.filter(function (m) { return m.name.toLowerCase() === "rtx" }).length; !b && p.sendEncodingParameters[0].rtx && delete p.sendEncodingParameters[0].rtx, c += Yn(p, h, "answer", p.stream, s._dtlsRole), p.rtcpParameters && p.rtcpParameters.reducedSize && (c += `a=rtcp-rsize\r
`)
            }
        }); var l = new e.RTCSessionDescription({ type: "answer", sdp: c }); return Promise.resolve(l)
    }, a.prototype.addIceCandidate = function (s) {
        var c = this, f; return s && !(s.sdpMLineIndex !== void 0 || s.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function (l, p) {
            if (c._remoteDescription) if (!s || s.candidate === "") for (var v = 0; v < c.transceivers.length && !(!c.transceivers[v].rejected && (c.transceivers[v].iceTransport.addRemoteCandidate({}), f = O.getMediaSections(c._remoteDescription.sdp), f[v] += `a=end-of-candidates\r
`, c._remoteDescription.sdp = O.getDescription(c._remoteDescription.sdp) + f.join(""), c.usingBundle)); v++); else {
                var d = s.sdpMLineIndex; if (s.sdpMid) { for (var h = 0; h < c.transceivers.length; h++)if (c.transceivers[h].mid === s.sdpMid) { d = h; break } } var b = c.transceivers[d]; if (b) {
                    if (b.rejected) return l(); var m = Object.keys(s.candidate).length > 0 ? O.parseCandidate(s.candidate) : {}; if (m.protocol === "tcp" && (m.port === 0 || m.port === 9) || m.component && m.component !== 1) return l(); if ((d === 0 || d > 0 && b.iceTransport !== c.transceivers[0].iceTransport) && !Tr(b.iceTransport, m)) return p(te("OperationError", "Can not add ICE candidate")); var g = s.candidate.trim(); g.indexOf("a=") === 0 && (g = g.substr(2)), f = O.getMediaSections(c._remoteDescription.sdp), f[d] += "a=" + (m.type ? g : "end-of-candidates") + `\r
`, c._remoteDescription.sdp = O.getDescription(c._remoteDescription.sdp) + f.join("")
                } else return p(te("OperationError", "Can not add ICE candidate"))
            } else return p(te("InvalidStateError", "Can not add ICE candidate without a remote description")); l()
        })
    }, a.prototype.getStats = function (s) { if (s && s instanceof e.MediaStreamTrack) { var c = null; if (this.transceivers.forEach(function (l) { l.rtpSender && l.rtpSender.track === s ? c = l.rtpSender : l.rtpReceiver && l.rtpReceiver.track === s && (c = l.rtpReceiver) }), !c) throw te("InvalidAccessError", "Invalid selector."); return c.getStats() } var f = []; return this.transceivers.forEach(function (l) { ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function (p) { l[p] && f.push(l[p].getStats()) }) }), Promise.all(f).then(function (l) { var p = new Map; return l.forEach(function (v) { v.forEach(function (d) { p.set(d.id, d) }) }), p }) }; var o = ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"]; o.forEach(function (s) { var c = e[s]; if (c && c.prototype && c.prototype.getStats) { var f = c.prototype.getStats; c.prototype.getStats = function () { return f.apply(this).then(function (l) { var p = new Map; return Object.keys(l).forEach(function (v) { l[v].type = $s(l[v]), p.set(v, l[v]) }), p }) } } }); var u = ["createOffer", "createAnswer"]; return u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var f = arguments; return typeof f[0] == "function" || typeof f[1] == "function" ? c.apply(this, [arguments[2]]).then(function (l) { typeof f[0] == "function" && f[0].apply(null, [l]) }, function (l) { typeof f[1] == "function" && f[1].apply(null, [l]) }) : c.apply(this, arguments) } }), u = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var f = arguments; return typeof f[1] == "function" || typeof f[2] == "function" ? c.apply(this, arguments).then(function () { typeof f[1] == "function" && f[1].apply(null) }, function (l) { typeof f[2] == "function" && f[2].apply(null, [l]) }) : c.apply(this, arguments) } }), ["getStats"].forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var f = arguments; return typeof f[1] == "function" ? c.apply(this, arguments).then(function () { typeof f[1] == "function" && f[1].apply(null) }) : c.apply(this, arguments) } }), a
}; function fa(e) { const t = e && e.navigator, r = function (i) { return { name: { PermissionDeniedError: "NotAllowedError" }[i.name] || i.name, message: i.message, constraint: i.constraint, toString() { return this.name } } }, n = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (i) { return n(i).catch(a => Promise.reject(r(a))) } } function la(e) { "getDisplayMedia" in e.navigator && (!e.navigator.mediaDevices || e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator))) } function Qr(e, t) { if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function (i) { return i }), e.RTCSessionDescription || (e.RTCSessionDescription = function (i) { return i }), t.version < 15025)) { const n = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled"); Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", { set(i) { n.set.call(this, i); const a = new Event("enabled"); a.enabled = i, this.dispatchEvent(a) } }) } e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype) && Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf } }), e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender); const r = Js(e, t.version); e.RTCPeerConnection = function (i) { return i && i.iceServers && (i.iceServers = zs(i.iceServers, t.version), kn("ICE servers after filtering:", i.iceServers)), new r(i) }, e.RTCPeerConnection.prototype = r.prototype } function pa(e) { e.RTCRtpSender && !("replaceTrack" in e.RTCRtpSender.prototype) && (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack) } const Qn = Object.freeze(Object.defineProperty({ __proto__: null, shimPeerConnection: Qr, shimReplaceTrack: pa, shimGetUserMedia: fa, shimGetDisplayMedia: la }, Symbol.toStringTag, { value: "Module" })); function da(e, t) { const r = e && e.navigator, n = e && e.MediaStreamTrack; if (r.getUserMedia = function (i, a, o) { vr("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r.mediaDevices.getUserMedia(i).then(a, o) }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) { const i = function (o, u, s) { u in o && !(s in o) && (o[s] = o[u], delete o[u]) }, a = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (o) { return typeof o == "object" && typeof o.audio == "object" && (o = JSON.parse(JSON.stringify(o)), i(o.audio, "autoGainControl", "mozAutoGainControl"), i(o.audio, "noiseSuppression", "mozNoiseSuppression")), a(o) }, n && n.prototype.getSettings) { const o = n.prototype.getSettings; n.prototype.getSettings = function () { const u = o.apply(this, arguments); return i(u, "mozAutoGainControl", "autoGainControl"), i(u, "mozNoiseSuppression", "noiseSuppression"), u } } if (n && n.prototype.applyConstraints) { const o = n.prototype.applyConstraints; n.prototype.applyConstraints = function (u) { return this.kind === "audio" && typeof u == "object" && (u = JSON.parse(JSON.stringify(u)), i(u, "autoGainControl", "mozAutoGainControl"), i(u, "noiseSuppression", "mozNoiseSuppression")), o.apply(this, [u]) } } } } function Vs(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || !e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = function (n) { if (!(n && n.video)) { const i = new DOMException("getDisplayMedia without video constraints is undefined"); return i.name = "NotFoundError", i.code = 8, Promise.reject(i) } return n.video === !0 ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n) }) } function ha(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function Zr(e, t) { if (typeof e != "object" || !(e.RTCPeerConnection || e.mozRTCPeerConnection)) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (i) { const a = e.RTCPeerConnection.prototype[i], o = { [i]() { return arguments[0] = new (i === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), a.apply(this, arguments) } }; e.RTCPeerConnection.prototype[i] = o[i] }); const r = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [a, o, u] = arguments; return n.apply(this, [a || null]).then(s => { if (t.version < 53 && !o) try { s.forEach(c => { c.type = r[c.type] || c.type }) } catch (c) { if (c.name !== "TypeError") throw c; s.forEach((f, l) => { s.set(l, Object.assign({}, f, { type: r[f.type] || f.type })) }) } return s }).then(o, u) } } function va(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const i = t.apply(this, []); return i.forEach(a => a._pc = this), i }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const i = r.apply(this, arguments); return i._pc = this, i }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function ma(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }), ct(e, "track", r => (r.receiver._pc = r.srcElement, r)), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function ya(e) { !e.RTCPeerConnection || "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { vr("removeStream", "removeTrack"), this.getSenders().forEach(n => { n.track && r.getTracks().includes(n.track) && this.removeTrack(n) }) }) } function ga(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function ba(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const n = arguments[1], i = n && "sendEncodings" in n; i && n.sendEncodings.forEach(o => { if ("rid" in o && !/^[a-z0-9]{0,16}$/i.test(o.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in o && !(parseFloat(o.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in o && !(parseFloat(o.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") }); const a = t.apply(this, arguments); if (i) { const { sender: o } = a, u = o.getParameters(); (!("encodings" in u) || u.encodings.length === 1 && Object.keys(u.encodings[0]).length === 0) && (u.encodings = n.sendEncodings, o.sendEncodings = n.sendEncodings, this.setParametersPromises.push(o.setParameters(u).then(() => { delete o.sendEncodings }).catch(() => { delete o.sendEncodings }))) } return a }) } function _a(e) { if (!(typeof e == "object" && e.RTCRtpSender)) return; const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const n = t.apply(this, arguments); return "encodings" in n || (n.encodings = [].concat(this.sendEncodings || [{}])), n }) } function Ca(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } function Sa(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } const Zn = Object.freeze(Object.defineProperty({ __proto__: null, shimOnTrack: ha, shimPeerConnection: Zr, shimSenderGetStats: va, shimReceiverGetStats: ma, shimRemoveStream: ya, shimRTCDataChannel: ga, shimAddTransceiver: ba, shimGetParameters: _a, shimCreateOffer: Ca, shimCreateAnswer: Sa, shimGetUserMedia: da, shimGetDisplayMedia: Vs }, Symbol.toStringTag, { value: "Module" })); function Ta(e) { if (!(typeof e != "object" || !e.RTCPeerConnection)) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (n) { this._localStreams || (this._localStreams = []), this._localStreams.includes(n) || this._localStreams.push(n), n.getAudioTracks().forEach(i => t.call(this, i, n)), n.getVideoTracks().forEach(i => t.call(this, i, n)) }, e.RTCPeerConnection.prototype.addTrack = function (n, ...i) { return i && i.forEach(a => { this._localStreams ? this._localStreams.includes(a) || this._localStreams.push(a) : this._localStreams = [a] }), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { this._localStreams || (this._localStreams = []); const n = this._localStreams.indexOf(r); if (n === -1) return; this._localStreams.splice(n, 1); const i = r.getTracks(); this.getSenders().forEach(a => { i.includes(a.track) && this.removeTrack(a) }) }) } } function ka(e) { if (!(typeof e != "object" || !e.RTCPeerConnection) && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(r) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = r), this.addEventListener("track", this._onaddstreampoly = n => { n.streams.forEach(i => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(i)) return; this._remoteStreams.push(i); const a = new Event("addstream"); a.stream = i, this.dispatchEvent(a) }) }) } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const n = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (i) { i.streams.forEach(a => { if (n._remoteStreams || (n._remoteStreams = []), n._remoteStreams.indexOf(a) >= 0) return; n._remoteStreams.push(a); const o = new Event("addstream"); o.stream = a, n.dispatchEvent(o) }) }), t.apply(n, arguments) } } } function Pa(e) { if (typeof e != "object" || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer, i = t.setLocalDescription, a = t.setRemoteDescription, o = t.addIceCandidate; t.createOffer = function (c, f) { const l = arguments.length >= 2 ? arguments[2] : arguments[0], p = r.apply(this, [l]); return f ? (p.then(c, f), Promise.resolve()) : p }, t.createAnswer = function (c, f) { const l = arguments.length >= 2 ? arguments[2] : arguments[0], p = n.apply(this, [l]); return f ? (p.then(c, f), Promise.resolve()) : p }; let u = function (s, c, f) { const l = i.apply(this, [s]); return f ? (l.then(c, f), Promise.resolve()) : l }; t.setLocalDescription = u, u = function (s, c, f) { const l = a.apply(this, [s]); return f ? (l.then(c, f), Promise.resolve()) : l }, t.setRemoteDescription = u, u = function (s, c, f) { const l = o.apply(this, [s]); return f ? (l.then(c, f), Promise.resolve()) : l }, t.addIceCandidate = u } function Ea(e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const r = t.mediaDevices, n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = i => n(Ra(i)) } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (n, i, a) { t.mediaDevices.getUserMedia(n).then(i, a) }.bind(t)) } function Ra(e) { return e && e.video !== void 0 ? Object.assign({}, e, { video: ea(e.video) }) : e } function xa(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection; e.RTCPeerConnection = function (n, i) { if (n && n.iceServers) { const a = []; for (let o = 0; o < n.iceServers.length; o++) { let u = n.iceServers[o]; !u.hasOwnProperty("urls") && u.hasOwnProperty("url") ? (vr("RTCIceServer.url", "RTCIceServer.urls"), u = JSON.parse(JSON.stringify(u)), u.urls = u.url, delete u.url, a.push(u)) : a.push(n.iceServers[o]) } n.iceServers = a } return new t(n, i) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get() { return t.generateCertificate } }) } function Da(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function wa(e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (n) { if (n) { typeof n.offerToReceiveAudio < "u" && (n.offerToReceiveAudio = !!n.offerToReceiveAudio); const i = this.getTransceivers().find(o => o.receiver.track.kind === "audio"); n.offerToReceiveAudio === !1 && i ? i.direction === "sendrecv" ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : i.direction === "recvonly" && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : n.offerToReceiveAudio === !0 && !i && this.addTransceiver("audio"), typeof n.offerToReceiveVideo < "u" && (n.offerToReceiveVideo = !!n.offerToReceiveVideo); const a = this.getTransceivers().find(o => o.receiver.track.kind === "video"); n.offerToReceiveVideo === !1 && a ? a.direction === "sendrecv" ? a.setDirection ? a.setDirection("sendonly") : a.direction = "sendonly" : a.direction === "recvonly" && (a.setDirection ? a.setDirection("inactive") : a.direction = "inactive") : n.offerToReceiveVideo === !0 && !a && this.addTransceiver("video") } return t.apply(this, arguments) } } function Oa(e) { typeof e != "object" || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } const ei = Object.freeze(Object.defineProperty({ __proto__: null, shimLocalStreamsAPI: Ta, shimRemoteStreamsAPI: ka, shimCallbacksAPI: Pa, shimGetUserMedia: Ea, shimConstraints: Ra, shimRTCIceServerUrls: xa, shimTrackEventTransceiver: Da, shimCreateOfferLegacy: wa, shimAudioContext: Oa }, Symbol.toStringTag, { value: "Module" })); function Xt(e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (n) { if (typeof n == "object" && n.candidate && n.candidate.indexOf("a=") === 0 && (n = JSON.parse(JSON.stringify(n)), n.candidate = n.candidate.substr(2)), n.candidate && n.candidate.length) { const i = new t(n), a = Yt.parseCandidate(n.candidate), o = Object.assign(i, a); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(n) }, e.RTCIceCandidate.prototype = t.prototype, ct(e, "icecandidate", r => (r.candidate && Object.defineProperty(r, "candidate", { value: new e.RTCIceCandidate(r.candidate), writable: "false" }), r)) } function vt(e, t) { if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp } }); const r = function (u) { if (!u || !u.sdp) return !1; const s = Yt.splitSections(u.sdp); return s.shift(), s.some(c => { const f = Yt.parseMLine(c); return f && f.kind === "application" && f.protocol.indexOf("SCTP") !== -1 }) }, n = function (u) { const s = u.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (s === null || s.length < 2) return -1; const c = parseInt(s[1], 10); return c !== c ? -1 : c }, i = function (u) { let s = 65536; return t.browser === "firefox" && (t.version < 57 ? u === -1 ? s = 16384 : s = 2147483637 : t.version < 60 ? s = t.version === 57 ? 65535 : 65536 : s = 2147483637), s }, a = function (u, s) { let c = 65536; t.browser === "firefox" && t.version === 57 && (c = 65535); const f = Yt.matchPrefix(u.sdp, "a=max-message-size:"); return f.length > 0 ? c = parseInt(f[0].substr(19), 10) : t.browser === "firefox" && s !== -1 && (c = 2147483637), c }, o = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, t.browser === "chrome" && t.version >= 76) { const { sdpSemantics: s } = this.getConfiguration(); s === "plan-b" && Object.defineProperty(this, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (r(arguments[0])) { const s = n(arguments[0]), c = i(s), f = a(arguments[0], s); let l; c === 0 && f === 0 ? l = Number.POSITIVE_INFINITY : c === 0 || f === 0 ? l = Math.max(c, f) : l = Math.min(c, f); const p = {}; Object.defineProperty(p, "maxMessageSize", { get() { return l } }), this._sctp = p } return o.apply(this, arguments) } } function mt(e) { if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return; function t(n, i) { const a = n.send; n.send = function () { const u = arguments[0], s = u.length || u.size || u.byteLength; if (n.readyState === "open" && i.sctp && s > i.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + i.sctp.maxMessageSize + " bytes)"); return a.apply(n, arguments) } } const r = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const i = r.apply(this, arguments); return t(i, this), i }, ct(e, "datachannel", n => (t(n.channel, n.target), n)) } function en(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(r) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), r && this.addEventListener("connectionstatechange", this._onconnectionstatechange = r) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach(r => { const n = t[r]; t[r] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = i => { const a = i.target; if (a._lastConnectionState !== a.connectionState) { a._lastConnectionState = a.connectionState; const o = new Event("connectionstatechange", i); a.dispatchEvent(o) } return i }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } }) } function tn(e, t) {
    if (!e.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605) return; const r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (i) {
        if (i && i.sdp && i.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
            const a = i.sdp.split(`
`).filter(o => o.trim() !== "a=extmap-allow-mixed").join(`
`); e.RTCSessionDescription && i instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: i.type, sdp: a }) : i.sdp = a
        } return r.apply(this, arguments)
    }
} function Qt(e, t) { if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype)) return; const r = e.RTCPeerConnection.prototype.addIceCandidate; !r || r.length === 0 || (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } const Hs = Object.freeze(Object.defineProperty({ __proto__: null, shimRTCIceCandidate: Xt, shimMaxMessageSize: vt, shimSendThrowTypeError: mt, shimConnectionState: en, removeExtmapAllowMixed: tn, shimAddIceCandidateNullOrEmpty: Qt }, Symbol.toStringTag, { value: "Module" })); function Ws({ window: e } = {}, t = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }) { const r = kn, n = Ns(e), i = { browserDetails: n, commonShim: Hs, extractVersion: ht, disableLog: Ks, disableWarnings: Ls }; switch (n.browser) { case "chrome": if (!qn || !Xr || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), i; if (n.version === null) return r("Chrome shim can not determine version, not shimming."), i; r("adapter.js shimming chrome."), i.browserShim = qn, Qt(e, n), ta(e, n), ra(e), Xr(e, n), na(e), ca(e, n), ia(e), aa(e), oa(e), ua(e, n), Xt(e), en(e), vt(e, n), mt(e), tn(e, n); break; case "firefox": if (!Zn || !Zr || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), i; r("adapter.js shimming firefox."), i.browserShim = Zn, Qt(e, n), da(e, n), Zr(e, n), ha(e), ya(e), va(e), ma(e), ga(e), ba(e), _a(e), Ca(e), Sa(e), Xt(e), en(e), vt(e, n), mt(e); break; case "edge": if (!Qn || !Qr || !t.shimEdge) return r("MS edge shim is not included in this adapter release."), i; r("adapter.js shimming edge."), i.browserShim = Qn, fa(e), la(e), Qr(e, n), pa(e), vt(e, n), mt(e); break; case "safari": if (!ei || !t.shimSafari) return r("Safari shim is not included in this adapter release."), i; r("adapter.js shimming safari."), i.browserShim = ei, Qt(e, n), xa(e), wa(e), Pa(e), Ta(e), ka(e), Da(e), Ea(e), Oa(e), Xt(e), vt(e, n), mt(e), tn(e, n); break; default: r("Unsupported browser!"); break }return i } const ti = Ws({ window: typeof window > "u" ? void 0 : window }); function Se(e, t, r, n) { Object.defineProperty(e, t, { get: r, set: n, enumerable: !0, configurable: !0 }) } var kr = ti.default || ti, ut = new (function () {
    function e() { this.isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform), this.supportedBrowsers = ["firefox", "chrome", "safari"], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605 } return e.prototype.isWebRTCSupported = function () { return typeof RTCPeerConnection < "u" }, e.prototype.isBrowserSupported = function () { var t = this.getBrowser(), r = this.getVersion(), n = this.supportedBrowsers.includes(t); return n ? t === "chrome" ? r >= this.minChromeVersion : t === "firefox" ? r >= this.minFirefoxVersion : t === "safari" ? !this.isIOS && r >= this.minSafariVersion : !1 : !1 }, e.prototype.getBrowser = function () { return kr.browserDetails.browser }, e.prototype.getVersion = function () { return kr.browserDetails.version || 0 }, e.prototype.isUnifiedPlanSupported = function () { var t = this.getBrowser(), r = kr.browserDetails.version || 0; if (t === "chrome" && r < this.minChromeVersion) return !1; if (t === "firefox" && r >= this.minFirefoxVersion) return !0; if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1; var n, i = !1; try { n = new RTCPeerConnection, n.addTransceiver("audio"), i = !0 } catch { } finally { n && n.close() } return i }, e.prototype.toString = function () {
        return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported())
    }, e
}()), ri = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: ["turn:eu-0.turn.peerjs.com:3478", "turn:us-0.turn.peerjs.com:3478"], username: "peerjs", credential: "peerjsp" }], sdpSemantics: "unified-plan" }, qs = function () { function e() { this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = { Chrome: 1, chrome: 1 }, this.chunkedMTU = 16300, this.defaultConfig = ri, this.browser = ut.getBrowser(), this.browserVersion = ut.getVersion(), this.supports = function () { var t = { browser: ut.isBrowserSupported(), webRTC: ut.isWebRTCSupported(), audioVideo: !1, data: !1, binaryBlob: !1, reliable: !1 }; if (!t.webRTC) return t; var r; try { r = new RTCPeerConnection(ri), t.audioVideo = !0; var n = void 0; try { n = r.createDataChannel("_PEERJSTEST", { ordered: !0 }), t.data = !0, t.reliable = !!n.ordered; try { n.binaryType = "blob", t.binaryBlob = !ut.isIOS } catch { } } catch { } finally { n && n.close() } } catch { } finally { r && r.close() } return t }(), this.pack = Jn.pack, this.unpack = Jn.unpack, this._dataCount = 1 } return e.prototype.noop = function () { }, e.prototype.validateId = function (t) { return !t || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(t) }, e.prototype.chunk = function (t) { for (var r = [], n = t.size, i = Math.ceil(n / K.chunkedMTU), a = 0, o = 0; o < n;) { var u = Math.min(n, o + K.chunkedMTU), s = t.slice(o, u), c = { __peerData: this._dataCount, n: a, data: s, total: i }; r.push(c), o = u, a++ } return this._dataCount++, r }, e.prototype.blobToArrayBuffer = function (t, r) { var n = new FileReader; return n.onload = function (i) { i.target && r(i.target.result) }, n.readAsArrayBuffer(t), n }, e.prototype.binaryStringToArrayBuffer = function (t) { for (var r = new Uint8Array(t.length), n = 0; n < t.length; n++)r[n] = t.charCodeAt(n) & 255; return r.buffer }, e.prototype.randomToken = function () { return Math.random().toString(36).slice(2) }, e.prototype.isSecure = function () { return location.protocol === "https:" }, e }(), K = new qs, Ia = {}; Se(Ia, "Peer", () => di, e => di = e); var Bt = {}, Ys = Object.prototype.hasOwnProperty, ue = "~"; function xt() { } Object.create && (xt.prototype = Object.create(null), new xt().__proto__ || (ue = !1)); function Xs(e, t, r) { this.fn = e, this.context = t, this.once = r || !1 } function Aa(e, t, r, n, i) { if (typeof r != "function") throw new TypeError("The listener must be a function"); var a = new Xs(r, n || e, i), o = ue ? ue + t : t; return e._events[o] ? e._events[o].fn ? e._events[o] = [e._events[o], a] : e._events[o].push(a) : (e._events[o] = a, e._eventsCount++), e } function Zt(e, t) { --e._eventsCount === 0 ? e._events = new xt : delete e._events[t] } function ae() { this._events = new xt, this._eventsCount = 0 } ae.prototype.eventNames = function () { var t = [], r, n; if (this._eventsCount === 0) return t; for (n in r = this._events) Ys.call(r, n) && t.push(ue ? n.slice(1) : n); return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(r)) : t }; ae.prototype.listeners = function (t) { var r = ue ? ue + t : t, n = this._events[r]; if (!n) return []; if (n.fn) return [n.fn]; for (var i = 0, a = n.length, o = new Array(a); i < a; i++)o[i] = n[i].fn; return o }; ae.prototype.listenerCount = function (t) { var r = ue ? ue + t : t, n = this._events[r]; return n ? n.fn ? 1 : n.length : 0 }; ae.prototype.emit = function (t, r, n, i, a, o) { var u = ue ? ue + t : t; if (!this._events[u]) return !1; var s = this._events[u], c = arguments.length, f, l; if (s.fn) { switch (s.once && this.removeListener(t, s.fn, void 0, !0), c) { case 1: return s.fn.call(s.context), !0; case 2: return s.fn.call(s.context, r), !0; case 3: return s.fn.call(s.context, r, n), !0; case 4: return s.fn.call(s.context, r, n, i), !0; case 5: return s.fn.call(s.context, r, n, i, a), !0; case 6: return s.fn.call(s.context, r, n, i, a, o), !0 }for (l = 1, f = new Array(c - 1); l < c; l++)f[l - 1] = arguments[l]; s.fn.apply(s.context, f) } else { var p = s.length, v; for (l = 0; l < p; l++)switch (s[l].once && this.removeListener(t, s[l].fn, void 0, !0), c) { case 1: s[l].fn.call(s[l].context); break; case 2: s[l].fn.call(s[l].context, r); break; case 3: s[l].fn.call(s[l].context, r, n); break; case 4: s[l].fn.call(s[l].context, r, n, i); break; default: if (!f) for (v = 1, f = new Array(c - 1); v < c; v++)f[v - 1] = arguments[v]; s[l].fn.apply(s[l].context, f) } } return !0 }; ae.prototype.on = function (t, r, n) { return Aa(this, t, r, n, !1) }; ae.prototype.once = function (t, r, n) { return Aa(this, t, r, n, !0) }; ae.prototype.removeListener = function (t, r, n, i) { var a = ue ? ue + t : t; if (!this._events[a]) return this; if (!r) return Zt(this, a), this; var o = this._events[a]; if (o.fn) o.fn === r && (!i || o.once) && (!n || o.context === n) && Zt(this, a); else { for (var u = 0, s = [], c = o.length; u < c; u++)(o[u].fn !== r || i && !o[u].once || n && o[u].context !== n) && s.push(o[u]); s.length ? this._events[a] = s.length === 1 ? s[0] : s : Zt(this, a) } return this }; ae.prototype.removeAllListeners = function (t) { var r; return t ? (r = ue ? ue + t : t, this._events[r] && Zt(this, r)) : (this._events = new xt, this._eventsCount = 0), this }; ae.prototype.off = ae.prototype.removeListener; ae.prototype.addListener = ae.prototype.on; ae.prefixed = ue; ae.EventEmitter = ae; Bt = ae; var x = {}; Se(x, "LogLevel", () => le, e => le = e); Se(x, "default", () => ni, e => ni = e); var ze = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, $e = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, Qs = "PeerJS: ", le; (function (e) { e[e.Disabled = 0] = "Disabled", e[e.Errors = 1] = "Errors", e[e.Warnings = 2] = "Warnings", e[e.All = 3] = "All" })(le || (le = {})); var Zs = function () { function e() { this._logLevel = le.Disabled } return Object.defineProperty(e.prototype, "logLevel", { get: function () { return this._logLevel }, set: function (t) { this._logLevel = t }, enumerable: !1, configurable: !0 }), e.prototype.log = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= le.All && this._print.apply(this, $e([le.All], ze(t), !1)) }, e.prototype.warn = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= le.Warnings && this._print.apply(this, $e([le.Warnings], ze(t), !1)) }, e.prototype.error = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= le.Errors && this._print.apply(this, $e([le.Errors], ze(t), !1)) }, e.prototype.setLogFunction = function (t) { this._print = t }, e.prototype._print = function (t) { for (var r = [], n = 1; n < arguments.length; n++)r[n - 1] = arguments[n]; var i = $e([Qs], ze(r), !1); for (var a in i) i[a] instanceof Error && (i[a] = "(" + i[a].name + ") " + i[a].message); t >= le.All ? console.log.apply(console, $e([], ze(i), !1)) : t >= le.Warnings ? console.warn.apply(console, $e(["WARNING"], ze(i), !1)) : t >= le.Errors && console.error.apply(console, $e(["ERROR"], ze(i), !1)) }, e }(), ni = new Zs, Ma = {}; Se(Ma, "Socket", () => ii, e => ii = e); var ge; (function (e) { e.Data = "data", e.Media = "media" })(ge || (ge = {})); var J; (function (e) { e.BrowserIncompatible = "browser-incompatible", e.Disconnected = "disconnected", e.InvalidID = "invalid-id", e.InvalidKey = "invalid-key", e.Network = "network", e.PeerUnavailable = "peer-unavailable", e.SslUnavailable = "ssl-unavailable", e.ServerError = "server-error", e.SocketError = "socket-error", e.SocketClosed = "socket-closed", e.UnavailableID = "unavailable-id", e.WebRTC = "webrtc" })(J || (J = {})); var ke; (function (e) { e.Binary = "binary", e.BinaryUTF8 = "binary-utf8", e.JSON = "json" })(ke || (ke = {})); var De; (function (e) { e.Message = "message", e.Disconnected = "disconnected", e.Error = "error", e.Close = "close" })(De || (De = {})); var X; (function (e) { e.Heartbeat = "HEARTBEAT", e.Candidate = "CANDIDATE", e.Offer = "OFFER", e.Answer = "ANSWER", e.Open = "OPEN", e.Error = "ERROR", e.IdTaken = "ID-TAKEN", e.InvalidKey = "INVALID-KEY", e.Leave = "LEAVE", e.Expire = "EXPIRE" })(X || (X = {})); var En = {}; En = JSON.parse('{"name":"peerjs","version":"1.4.7","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xFCckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}'); var ec = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), tc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, rc = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, nc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, ii = function (e) { ec(t, e); function t(r, n, i, a, o, u) { u === void 0 && (u = 5e3); var s = e.call(this) || this; s.pingInterval = u, s._disconnected = !0, s._messagesQueue = []; var c = r ? "wss://" : "ws://"; return s._baseUrl = c + n + ":" + i + a + "peerjs?key=" + o, s } return t.prototype.start = function (r, n) { var i = this; this._id = r; var a = "".concat(this._baseUrl, "&id=").concat(r, "&token=").concat(n); !!this._socket || !this._disconnected || (this._socket = new WebSocket(a + "&version=" + En.version), this._disconnected = !1, this._socket.onmessage = function (o) { var u; try { u = JSON.parse(o.data), x.default.log("Server message received:", u) } catch { x.default.log("Invalid server message", o.data); return } i.emit(De.Message, u) }, this._socket.onclose = function (o) { i._disconnected || (x.default.log("Socket closed.", o), i._cleanup(), i._disconnected = !0, i.emit(De.Disconnected)) }, this._socket.onopen = function () { i._disconnected || (i._sendQueuedMessages(), x.default.log("Socket open"), i._scheduleHeartbeat()) }) }, t.prototype._scheduleHeartbeat = function () { var r = this; this._wsPingTimer = setTimeout(function () { r._sendHeartbeat() }, this.pingInterval) }, t.prototype._sendHeartbeat = function () { if (!this._wsOpen()) { x.default.log("Cannot send heartbeat, because socket closed"); return } var r = JSON.stringify({ type: X.Heartbeat }); this._socket.send(r), this._scheduleHeartbeat() }, t.prototype._wsOpen = function () { return !!this._socket && this._socket.readyState === 1 }, t.prototype._sendQueuedMessages = function () { var r, n, i = rc([], tc(this._messagesQueue), !1); this._messagesQueue = []; try { for (var a = nc(i), o = a.next(); !o.done; o = a.next()) { var u = o.value; this.send(u) } } catch (s) { r = { error: s } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } }, t.prototype.send = function (r) { if (!this._disconnected) { if (!this._id) { this._messagesQueue.push(r); return } if (!r.type) { this.emit(De.Error, "Invalid message"); return } if (!!this._wsOpen()) { var n = JSON.stringify(r); this._socket.send(n) } } }, t.prototype.close = function () { this._disconnected || (this._cleanup(), this._disconnected = !0) }, t.prototype._cleanup = function () { this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer) }, t }(Bt.EventEmitter), rn = {}; Se(rn, "MediaConnection", () => si, e => si = e); var Rn = {}; Se(Rn, "Negotiator", () => ai, e => ai = e); var ur = function () { return ur = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, ur.apply(this, arguments) }, zt = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(f) { try { c(n.next(f)) } catch (l) { o(l) } } function s(f) { try { c(n.throw(f)) } catch (l) { o(l) } } function c(f) { f.done ? a(f.value) : i(f.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, $t = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (f) { return s([c, f]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (f) { c = [6, f], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, ai = function () { function e(t) { this.connection = t } return e.prototype.startConnection = function (t) { var r = this._startPeerConnection(); if (this.connection.peerConnection = r, this.connection.type === ge.Media && t._stream && this._addTracksToConnection(t._stream, r), t.originator) { if (this.connection.type === ge.Data) { var n = this.connection, i = { ordered: !!t.reliable }, a = r.createDataChannel(n.label, i); n.initialize(a) } this._makeOffer() } else this.handleSDP("OFFER", t.sdp) }, e.prototype._startPeerConnection = function () { x.default.log("Creating RTCPeerConnection."); var t = new RTCPeerConnection(this.connection.provider.options.config); return this._setupListeners(t), t }, e.prototype._setupListeners = function (t) { var r = this, n = this.connection.peer, i = this.connection.connectionId, a = this.connection.type, o = this.connection.provider; x.default.log("Listening for ICE candidates."), t.onicecandidate = function (u) { !u.candidate || !u.candidate.candidate || (x.default.log("Received ICE candidates for ".concat(n, ":"), u.candidate), o.socket.send({ type: X.Candidate, payload: { candidate: u.candidate, type: a, connectionId: i }, dst: n })) }, t.oniceconnectionstatechange = function () { switch (t.iceConnectionState) { case "failed": x.default.log("iceConnectionState is failed, closing connections to " + n), r.connection.emit("error", new Error("Negotiation of connection to " + n + " failed.")), r.connection.close(); break; case "closed": x.default.log("iceConnectionState is closed, closing connections to " + n), r.connection.emit("error", new Error("Connection to " + n + " closed.")), r.connection.close(); break; case "disconnected": x.default.log("iceConnectionState changed to disconnected on the connection with " + n); break; case "completed": t.onicecandidate = K.noop; break }r.connection.emit("iceStateChanged", t.iceConnectionState) }, x.default.log("Listening for data channel"), t.ondatachannel = function (u) { x.default.log("Received data channel"); var s = u.channel, c = o.getConnection(n, i); c.initialize(s) }, x.default.log("Listening for remote stream"), t.ontrack = function (u) { x.default.log("Received remote stream"); var s = u.streams[0], c = o.getConnection(n, i); if (c.type === ge.Media) { var f = c; r._addStreamToMediaConnection(s, f) } } }, e.prototype.cleanup = function () { x.default.log("Cleaning up PeerConnection to " + this.connection.peer); var t = this.connection.peerConnection; if (!!t) { this.connection.peerConnection = null, t.onicecandidate = t.oniceconnectionstatechange = t.ondatachannel = t.ontrack = function () { }; var r = t.signalingState !== "closed", n = !1; if (this.connection.type === ge.Data) { var i = this.connection, a = i.dataChannel; a && (n = !!a.readyState && a.readyState !== "closed") } (r || n) && t.close() } }, e.prototype._makeOffer = function () { return zt(this, void 0, Promise, function () { var t, r, n, i, a, o, u; return $t(this, function (s) { switch (s.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 7, , 8]), [4, t.createOffer(this.connection.options.constraints)]; case 2: n = s.sent(), x.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), s.label = 3; case 3: return s.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return s.sent(), x.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), i = { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, metadata: this.connection.metadata, browser: K.browser }, this.connection.type === ge.Data && (a = this.connection, i = ur(ur({}, i), { label: a.label, reliable: a.reliable, serialization: a.serialization })), r.socket.send({ type: X.Offer, payload: i, dst: this.connection.peer }), [3, 6]; case 5: return o = s.sent(), o != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (r.emitError(J.WebRTC, o), x.default.log("Failed to setLocalDescription, ", o)), [3, 6]; case 6: return [3, 8]; case 7: return u = s.sent(), r.emitError(J.WebRTC, u), x.default.log("Failed to createOffer, ", u), [3, 8]; case 8: return [2] } }) }) }, e.prototype._makeAnswer = function () { return zt(this, void 0, Promise, function () { var t, r, n, i, a; return $t(this, function (o) { switch (o.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, o.label = 1; case 1: return o.trys.push([1, 7, , 8]), [4, t.createAnswer()]; case 2: n = o.sent(), x.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), o.label = 3; case 3: return o.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return o.sent(), x.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), r.socket.send({ type: X.Answer, payload: { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, browser: K.browser }, dst: this.connection.peer }), [3, 6]; case 5: return i = o.sent(), r.emitError(J.WebRTC, i), x.default.log("Failed to setLocalDescription, ", i), [3, 6]; case 6: return [3, 8]; case 7: return a = o.sent(), r.emitError(J.WebRTC, a), x.default.log("Failed to create answer, ", a), [3, 8]; case 8: return [2] } }) }) }, e.prototype.handleSDP = function (t, r) { return zt(this, void 0, Promise, function () { var n, i, a, o; return $t(this, function (u) { switch (u.label) { case 0: r = new RTCSessionDescription(r), n = this.connection.peerConnection, i = this.connection.provider, x.default.log("Setting remote description", r), a = this, u.label = 1; case 1: return u.trys.push([1, 5, , 6]), [4, n.setRemoteDescription(r)]; case 2: return u.sent(), x.default.log("Set remoteDescription:".concat(t, " for:").concat(this.connection.peer)), t !== "OFFER" ? [3, 4] : [4, a._makeAnswer()]; case 3: u.sent(), u.label = 4; case 4: return [3, 6]; case 5: return o = u.sent(), i.emitError(J.WebRTC, o), x.default.log("Failed to setRemoteDescription, ", o), [3, 6]; case 6: return [2] } }) }) }, e.prototype.handleCandidate = function (t) { return zt(this, void 0, Promise, function () { var r, n, i, a, o, u; return $t(this, function (s) { switch (s.label) { case 0: x.default.log("handleCandidate:", t), r = t.candidate, n = t.sdpMLineIndex, i = t.sdpMid, a = this.connection.peerConnection, o = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 3, , 4]), [4, a.addIceCandidate(new RTCIceCandidate({ sdpMid: i, sdpMLineIndex: n, candidate: r }))]; case 2: return s.sent(), x.default.log("Added ICE candidate for:".concat(this.connection.peer)), [3, 4]; case 3: return u = s.sent(), o.emitError(J.WebRTC, u), x.default.log("Failed to handleCandidate, ", u), [3, 4]; case 4: return [2] } }) }) }, e.prototype._addTracksToConnection = function (t, r) { if (x.default.log("add tracks from stream ".concat(t.id, " to peer connection")), !r.addTrack) return x.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored."); t.getTracks().forEach(function (n) { r.addTrack(n, t) }) }, e.prototype._addStreamToMediaConnection = function (t, r) { x.default.log("add stream ".concat(t.id, " to media connection ").concat(r.connectionId)), r.addStream(t) }, e }(), xn = {}; Se(xn, "BaseConnection", () => oi, e => oi = e); var ic = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), oi = function (e) { ic(t, e); function t(r, n, i) { var a = e.call(this) || this; return a.peer = r, a.provider = n, a.options = i, a._open = !1, a.metadata = i.metadata, a } return Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), t }(Bt.EventEmitter), ac = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), fr = function () { return fr = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, fr.apply(this, arguments) }, oc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, si = function (e) { ac(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a._localStream = a.options._stream, a.connectionId = a.options.connectionId || t.ID_PREFIX + K.randomToken(), a._negotiator = new Rn.Negotiator(a), a._localStream && a._negotiator.startConnection({ _stream: a._localStream, originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return ge.Media }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "localStream", { get: function () { return this._localStream }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "remoteStream", { get: function () { return this._remoteStream }, enumerable: !1, configurable: !0 }), t.prototype.addStream = function (r) { x.default.log("Receiving stream", r), this._remoteStream = r, e.prototype.emit.call(this, "stream", r) }, t.prototype.handleMessage = function (r) { var n = r.type, i = r.payload; switch (r.type) { case X.Answer: this._negotiator.handleSDP(n, i.sdp), this._open = !0; break; case X.Candidate: this._negotiator.handleCandidate(i.candidate); break; default: x.default.warn("Unrecognized message type:".concat(n, " from peer:").concat(this.peer)); break } }, t.prototype.answer = function (r, n) { var i, a; if (n === void 0 && (n = {}), this._localStream) { x.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?"); return } this._localStream = r, n && n.sdpTransform && (this.options.sdpTransform = n.sdpTransform), this._negotiator.startConnection(fr(fr({}, this.options._payload), { _stream: r })); var o = this.provider._getMessages(this.connectionId); try { for (var u = oc(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; this.handleMessage(c) } } catch (f) { i = { error: f } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } this._open = !0 }, t.prototype.close = function () { this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.ID_PREFIX = "mc_", t }(xn.BaseConnection), nn = {}; Se(nn, "DataConnection", () => ui, e => ui = e); var Ba = {}; Se(Ba, "EncodingQueue", () => ci, e => ci = e); var sc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), ci = function (e) { sc(t, e); function t() { var r = e.call(this) || this; return r.fileReader = new FileReader, r._queue = [], r._processing = !1, r.fileReader.onload = function (n) { r._processing = !1, n.target && r.emit("done", n.target.result), r.doNextTask() }, r.fileReader.onerror = function (n) { x.default.error("EncodingQueue error:", n), r._processing = !1, r.destroy(), r.emit("error", n) }, r } return Object.defineProperty(t.prototype, "queue", { get: function () { return this._queue }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "size", { get: function () { return this.queue.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "processing", { get: function () { return this._processing }, enumerable: !1, configurable: !0 }), t.prototype.enque = function (r) { this.queue.push(r), !this.processing && this.doNextTask() }, t.prototype.destroy = function () { this.fileReader.abort(), this._queue = [] }, t.prototype.doNextTask = function () { this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift()))) }, t }(Bt.EventEmitter), cc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), uc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, ui = function (e) { cc(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a.stringify = JSON.stringify, a.parse = JSON.parse, a._buffer = [], a._bufferSize = 0, a._buffering = !1, a._chunkedData = {}, a._encodingQueue = new Ba.EncodingQueue, a.connectionId = a.options.connectionId || t.ID_PREFIX + K.randomToken(), a.label = a.options.label || a.connectionId, a.serialization = a.options.serialization || ke.Binary, a.reliable = !!a.options.reliable, a._encodingQueue.on("done", function (o) { a._bufferedSend(o) }), a._encodingQueue.on("error", function () { x.default.error("DC#".concat(a.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), a.close() }), a._negotiator = new Rn.Negotiator(a), a._negotiator.startConnection(a.options._payload || { originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return ge.Data }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dataChannel", { get: function () { return this._dc }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "bufferSize", { get: function () { return this._bufferSize }, enumerable: !1, configurable: !0 }), t.prototype.initialize = function (r) { this._dc = r, this._configureDataChannel() }, t.prototype._configureDataChannel = function () { var r = this; (!K.supports.binaryBlob || K.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function () { x.default.log("DC#".concat(r.connectionId, " dc connection success")), r._open = !0, r.emit("open") }, this.dataChannel.onmessage = function (n) { x.default.log("DC#".concat(r.connectionId, " dc onmessage:"), n.data), r._handleDataMessage(n) }, this.dataChannel.onclose = function () { x.default.log("DC#".concat(r.connectionId, " dc closed for:"), r.peer), r.close() } }, t.prototype._handleDataMessage = function (r) { var n = this, i = r.data, a = i.constructor, o = this.serialization === ke.Binary || this.serialization === ke.BinaryUTF8, u = i; if (o) { if (a === Blob) { K.blobToArrayBuffer(i, function (c) { var f = K.unpack(c); n.emit("data", f) }); return } else if (a === ArrayBuffer) u = K.unpack(i); else if (a === String) { var s = K.binaryStringToArrayBuffer(i); u = K.unpack(s) } } else this.serialization === ke.JSON && (u = this.parse(i)); if (u.__peerData) { this._handleChunk(u); return } e.prototype.emit.call(this, "data", u) }, t.prototype._handleChunk = function (r) { var n = r.__peerData, i = this._chunkedData[n] || { data: [], count: 0, total: r.total }; if (i.data[r.n] = r.data, i.count++, this._chunkedData[n] = i, i.total === i.count) { delete this._chunkedData[n]; var a = new Blob(i.data); this._handleDataMessage({ data: a }) } }, t.prototype.close = function () { this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.prototype.send = function (r, n) { if (!this.open) { e.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages.")); return } if (this.serialization === ke.JSON) this._bufferedSend(this.stringify(r)); else if (this.serialization === ke.Binary || this.serialization === ke.BinaryUTF8) { var i = K.pack(r); if (!n && i.size > K.chunkedMTU) { this._sendChunks(i); return } K.supports.binaryBlob ? this._bufferedSend(i) : this._encodingQueue.enque(i) } else this._bufferedSend(r) }, t.prototype._bufferedSend = function (r) { (this._buffering || !this._trySend(r)) && (this._buffer.push(r), this._bufferSize = this._buffer.length) }, t.prototype._trySend = function (r) { var n = this; if (!this.open) return !1; if (this.dataChannel.bufferedAmount > t.MAX_BUFFERED_AMOUNT) return this._buffering = !0, setTimeout(function () { n._buffering = !1, n._tryBuffer() }, 50), !1; try { this.dataChannel.send(r) } catch (i) { return x.default.error("DC#:".concat(this.connectionId, " Error when sending:"), i), this._buffering = !0, this.close(), !1 } return !0 }, t.prototype._tryBuffer = function () { if (!!this.open && this._buffer.length !== 0) { var r = this._buffer[0]; this._trySend(r) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer()) } }, t.prototype._sendChunks = function (r) { var n, i, a = K.chunk(r); x.default.log("DC#".concat(this.connectionId, " Try to send ").concat(a.length, " chunks...")); try { for (var o = uc(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; this.send(s, !0) } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.handleMessage = function (r) { var n = r.payload; switch (r.type) { case X.Answer: this._negotiator.handleSDP(r.type, n.sdp); break; case X.Candidate: this._negotiator.handleCandidate(n.candidate); break; default: x.default.warn("Unrecognized message type:", r.type, "from peer:", this.peer); break } }, t.ID_PREFIX = "dc_", t.MAX_BUFFERED_AMOUNT = 8388608, t }(xn.BaseConnection), ja = {}; Se(ja, "API", () => pi, e => pi = e); var fi = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(f) { try { c(n.next(f)) } catch (l) { o(l) } } function s(f) { try { c(n.throw(f)) } catch (l) { o(l) } } function c(f) { f.done ? a(f.value) : i(f.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, li = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (f) { return s([c, f]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (f) { c = [6, f], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, pi = function () { function e(t) { this._options = t } return e.prototype._buildRequest = function (t) { var r = this._options.secure ? "https" : "http", n = this._options, i = n.host, a = n.port, o = n.path, u = n.key, s = new URL("".concat(r, "://").concat(i, ":").concat(a).concat(o).concat(u, "/").concat(t)); return s.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), s.searchParams.set("version", En.version), fetch(s.href, { referrerPolicy: this._options.referrerPolicy }) }, e.prototype.retrieveId = function () { return fi(this, void 0, Promise, function () { var t, r, n; return li(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("id")]; case 1: if (t = i.sent(), t.status !== 200) throw new Error("Error. Status:".concat(t.status)); return [2, t.text()]; case 2: throw r = i.sent(), x.default.error("Error retrieving ID", r), n = "", this._options.path === "/" && this._options.host !== K.CLOUD_HOST && (n = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + n); case 3: return [2] } }) }) }, e.prototype.listAllPeers = function () { return fi(this, void 0, Promise, function () { var t, r, n; return li(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("peers")]; case 1: if (t = i.sent(), t.status !== 200) throw t.status === 401 ? (r = "", this._options.host === K.CLOUD_HOST ? r = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : r = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + r)) : new Error("Error. Status:".concat(t.status)); return [2, t.json()]; case 2: throw n = i.sent(), x.default.error("Error retrieving list peers", n), new Error("Could not get list peers from the server." + n); case 3: return [2] } }) }) }, e }(), fc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), _t = function () { return _t = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, _t.apply(this, arguments) }, ft = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, lc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, di = function (e) { fc(t, e); function t(r, n) { var i = e.call(this) || this; i._id = null, i._lastServerId = null, i._destroyed = !1, i._disconnected = !1, i._open = !1, i._connections = new Map, i._lostMessages = new Map; var a; return r && r.constructor == Object ? n = r : r && (a = r.toString()), n = _t({ debug: 0, host: K.CLOUD_HOST, port: K.CLOUD_PORT, path: "/", key: t.DEFAULT_KEY, token: K.randomToken(), config: K.defaultConfig, referrerPolicy: "strict-origin-when-cross-origin" }, n), i._options = n, i._options.host === "/" && (i._options.host = window.location.hostname), i._options.path && (i._options.path[0] !== "/" && (i._options.path = "/" + i._options.path), i._options.path[i._options.path.length - 1] !== "/" && (i._options.path += "/")), i._options.secure === void 0 && i._options.host !== K.CLOUD_HOST ? i._options.secure = K.isSecure() : i._options.host == K.CLOUD_HOST && (i._options.secure = !0), i._options.logFunction && x.default.setLogFunction(i._options.logFunction), x.default.logLevel = i._options.debug || 0, i._api = new ja.API(n), i._socket = i._createServerConnection(), !K.supports.audioVideo && !K.supports.data ? (i._delayedAbort(J.BrowserIncompatible, "The current browser does not support WebRTC"), i) : !!a && !K.validateId(a) ? (i._delayedAbort(J.InvalidID, 'ID "'.concat(a, '" is invalid')), i) : (a ? i._initialize(a) : i._api.retrieveId().then(function (o) { return i._initialize(o) }).catch(function (o) { return i._abort(J.ServerError, o) }), i) } return Object.defineProperty(t.prototype, "id", { get: function () { return this._id }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "options", { get: function () { return this._options }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "socket", { get: function () { return this._socket }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "connections", { get: function () { var r, n, i = Object.create(null); try { for (var a = ft(this._connections), o = a.next(); !o.done; o = a.next()) { var u = lc(o.value, 2), s = u[0], c = u[1]; i[s] = c } } catch (f) { r = { error: f } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } return i }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "destroyed", { get: function () { return this._destroyed }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "disconnected", { get: function () { return this._disconnected }, enumerable: !1, configurable: !0 }), t.prototype._createServerConnection = function () { var r = this, n = new Ma.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval); return n.on(De.Message, function (i) { r._handleMessage(i) }), n.on(De.Error, function (i) { r._abort(J.SocketError, i) }), n.on(De.Disconnected, function () { r.disconnected || (r.emitError(J.Network, "Lost connection to server."), r.disconnect()) }), n.on(De.Close, function () { r.disconnected || r._abort(J.SocketClosed, "Underlying socket is already closed.") }), n }, t.prototype._initialize = function (r) { this._id = r, this.socket.start(r, this._options.token) }, t.prototype._handleMessage = function (r) { var n, i, a = r.type, o = r.payload, u = r.src; switch (a) { case X.Open: this._lastServerId = this.id, this._open = !0, this.emit("open", this.id); break; case X.Error: this._abort(J.ServerError, o.msg); break; case X.IdTaken: this._abort(J.UnavailableID, 'ID "'.concat(this.id, '" is taken')); break; case X.InvalidKey: this._abort(J.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid')); break; case X.Leave: x.default.log("Received leave message from ".concat(u)), this._cleanupPeer(u), this._connections.delete(u); break; case X.Expire: this.emitError(J.PeerUnavailable, "Could not connect to peer ".concat(u)); break; case X.Offer: var d = o.connectionId, h = this.getConnection(u, d); if (h && (h.close(), x.default.warn("Offer received for existing Connection ID:".concat(d))), o.type === ge.Media) { var s = new rn.MediaConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata }); h = s, this._addConnection(u, h), this.emit("call", s) } else if (o.type === ge.Data) { var c = new nn.DataConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata, label: o.label, serialization: o.serialization, reliable: o.reliable }); h = c, this._addConnection(u, h), this.emit("connection", c) } else { x.default.warn("Received malformed connection type:".concat(o.type)); return } var f = this._getMessages(d); try { for (var l = ft(f), p = l.next(); !p.done; p = l.next()) { var v = p.value; h.handleMessage(v) } } catch (b) { n = { error: b } } finally { try { p && !p.done && (i = l.return) && i.call(l) } finally { if (n) throw n.error } } break; default: if (!o) { x.default.warn("You received a malformed message from ".concat(u, " of type ").concat(a)); return } var d = o.connectionId, h = this.getConnection(u, d); h && h.peerConnection ? h.handleMessage(r) : d ? this._storeMessage(d, r) : x.default.warn("You received an unrecognized message:", r); break } }, t.prototype._storeMessage = function (r, n) { this._lostMessages.has(r) || this._lostMessages.set(r, []), this._lostMessages.get(r).push(n) }, t.prototype._getMessages = function (r) { var n = this._lostMessages.get(r); return n ? (this._lostMessages.delete(r), n) : [] }, t.prototype.connect = function (r, n) { if (n === void 0 && (n = {}), this.disconnected) { x.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } var i = new nn.DataConnection(r, this, n); return this._addConnection(r, i), i }, t.prototype.call = function (r, n, i) { if (i === void 0 && (i = {}), this.disconnected) { x.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } if (!n) { x.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`."); return } var a = new rn.MediaConnection(r, this, _t(_t({}, i), { _stream: n })); return this._addConnection(r, a), a }, t.prototype._addConnection = function (r, n) { x.default.log("add connection ".concat(n.type, ":").concat(n.connectionId, " to peerId:").concat(r)), this._connections.has(r) || this._connections.set(r, []), this._connections.get(r).push(n) }, t.prototype._removeConnection = function (r) { var n = this._connections.get(r.peer); if (n) { var i = n.indexOf(r); i !== -1 && n.splice(i, 1) } this._lostMessages.delete(r.connectionId) }, t.prototype.getConnection = function (r, n) { var i, a, o = this._connections.get(r); if (!o) return null; try { for (var u = ft(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; if (c.connectionId === n) return c } } catch (f) { i = { error: f } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } return null }, t.prototype._delayedAbort = function (r, n) { var i = this; setTimeout(function () { i._abort(r, n) }, 0) }, t.prototype._abort = function (r, n) { x.default.error("Aborting!"), this.emitError(r, n), this._lastServerId ? this.disconnect() : this.destroy() }, t.prototype.emitError = function (r, n) { x.default.error("Error:", n); var i; typeof n == "string" ? i = new Error(n) : i = n, i.type = r, this.emit("error", i) }, t.prototype.destroy = function () { this.destroyed || (x.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close")) }, t.prototype._cleanup = function () { var r, n; try { for (var i = ft(this._connections.keys()), a = i.next(); !a.done; a = i.next()) { var o = a.value; this._cleanupPeer(o), this._connections.delete(o) } } catch (u) { r = { error: u } } finally { try { a && !a.done && (n = i.return) && n.call(i) } finally { if (r) throw r.error } } this.socket.removeAllListeners() }, t.prototype._cleanupPeer = function (r) { var n, i, a = this._connections.get(r); if (!!a) try { for (var o = ft(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; s.close() } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.disconnect = function () { if (!this.disconnected) { var r = this.id; x.default.log("Disconnect peer with ID:".concat(r)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = r, this._id = null, this.emit("disconnected", r) } }, t.prototype.reconnect = function () { if (this.disconnected && !this.destroyed) x.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId); else { if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed."); if (!this.disconnected && !this.open) x.default.error("In a hurry? We're still trying to make the initial connection!"); else throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!")) } }, t.prototype.listAllPeers = function (r) { var n = this; r === void 0 && (r = function (i) { }), this._api.listAllPeers().then(function (i) { return r(i) }).catch(function (i) { return n._abort(J.ServerError, i) }) }, t.DEFAULT_KEY = "peerjs", t }(Bt.EventEmitter), pc = Ia.Peer; async function dc() { let e = await za(); e.id = ye.id, delete e.default, delete e.current, delete e.resource, await Ve.save(e) } async function hc() { await Ve.save({ connectionOptions: (await $a()).options }) } async function vc() { let e = await Ga(), t = { state: { status: mc(e.state.text) } }; "temperature" in e && (t.temperatureHistory = e.temperature.history), await Ve.save(t) } function mc(e) { return e.includes("Operational") ? tt.operational : e.includes("Printing") ? tt.printing : e.includes("Paused") ? tt.paused : tt.offline } let ye, G, Ve; Es().then(async () => { let e = await z.printer.toArray(); if (e.length > 0 && (Ve = e[0]), G = await z.networking.get("1"), G || (G = new Wi("1"), await G.add()), !G.peerID || !G.apiKey) { let t = setInterval(async () => { window.peerID && !G.peerID && (G.save({ peerID: window.peerID }), G.peerID = window.peerID, Ve || (Ve = new qi(window.peerID), Ve.add())), window.apiKey && !G.apiKey && (G.save({ apiKey: window.apiKey }), G.apiKey = window.apiKey), G.peerID && G.apiKey && (clearInterval(t), hi()) }, 1e3) } else hi() }); async function hi() { ye = new pc(G.peerID), yc(), await dc(), await hc(), setInterval(() => vc(), 3e3) } function yc() { ye.on("open", function (e) { console.log("Connected to peer server with id:" + e) }), ye.on("connection", function (e) { console.log("Connected with peer:" + e.peer), e.on("data", function (t) { console.log("Received Label: " + e.label), Os(t, e.peer, e.label, e.metadata), e.close() }) }), ye.on("disconnected", function () { console.log("Disconnected from signaling server, reconnecting..."), ye.reconnect() }), ye.on("close", function () { console.log("Peer destroyed, cannot reconnect") }), ye.on("error", function (e) { console.error(e) }) }
