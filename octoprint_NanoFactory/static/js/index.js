var io = Object.defineProperty; var ao = (e, t, r) => t in e ? io(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; var P = (e, t, r) => (ao(e, typeof t != "symbol" ? t + "" : t, r), r); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function r(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerpolicy && (a.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? a.credentials = "include" : i.crossorigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function n(i) { if (i.ep) return; i.ep = !0; const a = r(i); fetch(i.href, a) } })(); var D = (e => (e.syncAllRequest = "1", e.syncAllResponse = "2", e.profileChanged = "3", e.positionChanged = "57", e.positionChangedResponse = "4", e.positionChangedRequest = "53", e.positionChangedStop = "54", e.cameraStreamRequest = "5", e.cameraStreamResponse = "34", e.cameraStreamStop = "44", e.temperatureStreamRequest = "6", e.temperatureStreamResponse = "35", e.temperatureStreamStop = "43", e.bedLevelingRequest = "7", e.bedLevelingResponse = "8", e.terminalRequest = "9", e.terminalResponse = "10", e.terminalStop = "42", e.filamentModified = "58", e.filamentAssigned = "11", e.filamentRemoved = "12", e.filamentModifiedResponse = "40", e.filamentModifiedRequest = "52", e.filamentModifiedStop = "55", e.jobCreated = "13", e.jobFile = "41", e.jobDone = "14", e.jobCancelled = "15", e.jobFailed = "16", e.jobDeleted = "17", e.jobPause = "25", e.jobResume = "26", e.jobPrinting = "37", e.jobFilamentModified = "30", e.currentJobUpdatesResponse = "49", e.currentJobUpdatesRequest = "51", e.currentJobUpdatesStop = "56", e.jobRankChange = "18", e.actionCreated = "19", e.actionModified = "20", e.actionExecuted = "21", e.actionDeleted = "22", e.executeCustomGcode = "23", e.emergencyStop = "24", e.connectPrinter = "27", e.disconnectPrinter = "28", e.connectionOptionsChanged = "38", e.printerStateChanged = "39", e.refreshConnectionOptions = "45", e.filamentExtrude = "46", e.targetTool = "47", e.targetBed = "48", e.handshakeRequest = "50", e.handshakeResponse = "31", e.queuePaused = "29", e.home = "32", e))(D || {}); let Ut; function _n(e, t, r) {
    const n = { label: r, metadata: e, serialization: "json", reliable: !0 }; Ut = de.connect(e, n), Ut.on("open", function () { Ut.send(JSON.stringify(t)), console.log("Sent:", t) }), Ut.on("error", function (i) {
        console.error("Could not send data: ", t, `
 Error: `, i)
    })
} function Yt(e, t) { Cr.available.forEach(r => { _n(r, e, t) }) }/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var B = function () { return B = Object.assign || function (t) { for (var r, n = 1, i = arguments.length; n < i; n++) { r = arguments[n]; for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]) } return t }, B.apply(this, arguments) }; function Ur(e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) } var $ = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, H = Object.keys, ae = Array.isArray; typeof Promise < "u" && !$.Promise && ($.Promise = Promise); function ue(e, t) { return typeof t != "object" || H(t).forEach(function (r) { e[r] = t[r] }), e } var Rt = Object.getPrototypeOf, oo = {}.hasOwnProperty; function ye(e, t) { return oo.call(e, t) } function ct(e, t) { typeof t == "function" && (t = t(Rt(e))), (typeof Reflect > "u" ? H : Reflect.ownKeys)(t).forEach(function (r) { Ie(e, r, t[r]) }) } var Ai = Object.defineProperty; function Ie(e, t, r, n) { Ai(e, t, ue(r && ye(r, "get") && typeof r.get == "function" ? { get: r.get, set: r.set, configurable: !0 } : { value: r, configurable: !0, writable: !0 }, n)) } function ut(e) { return { from: function (t) { return e.prototype = Object.create(t.prototype), Ie(e.prototype, "constructor", e), { extend: ct.bind(null, e.prototype) } } } } var so = Object.getOwnPropertyDescriptor; function Cn(e, t) { var r = so(e, t), n; return r || (n = Rt(e)) && Cn(n, t) } var co = [].slice; function Sr(e, t, r) { return co.call(e, t, r) } function Ii(e, t) { return t(e) } function yt(e) { if (!e) throw new Error("Assertion Failed") } function Mi(e) { $.setImmediate ? setImmediate(e) : setTimeout(e, 0) } function ji(e, t) { return e.reduce(function (r, n, i) { var a = t(n, i); return a && (r[a[0]] = a[1]), r }, {}) } function uo(e, t, r) { try { e.apply(null, r) } catch (n) { t && t(n) } } function Oe(e, t) { if (ye(e, t)) return e[t]; if (!t) return e; if (typeof t != "string") { for (var r = [], n = 0, i = t.length; n < i; ++n) { var a = Oe(e, t[n]); r.push(a) } return r } var o = t.indexOf("."); if (o !== -1) { var u = e[t.substr(0, o)]; return u === void 0 ? void 0 : Oe(u, t.substr(o + 1)) } } function Ce(e, t, r) { if (!(!e || t === void 0) && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) { yt(typeof r != "string" && "length" in r); for (var n = 0, i = t.length; n < i; ++n)Ce(e, t[n], r[n]) } else { var a = t.indexOf("."); if (a !== -1) { var o = t.substr(0, a), u = t.substr(a + 1); if (u === "") r === void 0 ? ae(e) && !isNaN(parseInt(o)) ? e.splice(o, 1) : delete e[o] : e[o] = r; else { var s = e[o]; (!s || !ye(e, o)) && (s = e[o] = {}), Ce(s, u, r) } } else r === void 0 ? ae(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r } } function lo(e, t) { typeof t == "string" ? Ce(e, t, void 0) : "length" in t && [].map.call(t, function (r) { Ce(e, r, void 0) }) } function Bi(e) { var t = {}; for (var r in e) ye(e, r) && (t[r] = e[r]); return t } var fo = [].concat; function Fi(e) { return fo.apply([], e) } var Ki = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Fi([8, 16, 32, 64].map(function (e) { return ["Int", "Uint", "Float"].map(function (t) { return t + e + "Array" }) }))).filter(function (e) { return $[e] }), po = Ki.map(function (e) { return $[e] }); ji(Ki, function (e) { return [e, !0] }); var Ne = null; function Mt(e) { Ne = typeof WeakMap < "u" && new WeakMap; var t = zr(e); return Ne = null, t } function zr(e) { if (!e || typeof e != "object") return e; var t = Ne && Ne.get(e); if (t) return t; if (ae(e)) { t = [], Ne && Ne.set(e, t); for (var r = 0, n = e.length; r < n; ++r)t.push(zr(e[r])) } else if (po.indexOf(e.constructor) >= 0) t = e; else { var i = Rt(e); t = i === Object.prototype ? {} : Object.create(i), Ne && Ne.set(e, t); for (var a in e) ye(e, a) && (t[a] = zr(e[a])) } return t } var ho = {}.toString; function $r(e) { return ho.call(e).slice(8, -1) } var Gr = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", mo = typeof Gr == "symbol" ? function (e) { var t; return e != null && (t = e[Gr]) && t.apply(e) } : function () { return null }, tt = {}; function xe(e) { var t, r, n, i; if (arguments.length === 1) { if (ae(e)) return e.slice(); if (this === tt && typeof e == "string") return [e]; if (i = mo(e)) { for (r = []; n = i.next(), !n.done;)r.push(n.value); return r } if (e == null) return [e]; if (t = e.length, typeof t == "number") { for (r = new Array(t); t--;)r[t] = e[t]; return r } return [e] } for (t = arguments.length, r = new Array(t); t--;)r[t] = arguments[t]; return r } var Sn = typeof Symbol < "u" ? function (e) { return e[Symbol.toStringTag] === "AsyncFunction" } : function () { return !1 }, Te = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href); function Ni(e, t) { Te = e, Li = t } var Li = function () { return !0 }, vo = !new Error("").stack; function Qe() { if (vo) try { throw Qe.arguments, new Error } catch (e) { return e } return new Error } function Jr(e, t) {
    var r = e.stack; return r ? (t = t || 0, r.indexOf(e.name) === 0 && (t += (e.name + e.message).split(`
`).length), r.split(`
`).slice(t).filter(Li).map(function (n) {
        return `
`+ n
    }).join("")) : ""
} var yo = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"], Ui = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], Tn = yo.concat(Ui), go = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" }; function lt(e, t) { this._e = Qe(), this.name = e, this.message = t } ut(lt).from(Error).extend({ stack: { get: function () { return this._stack || (this._stack = this.name + ": " + this.message + Jr(this._e, 2)) } }, toString: function () { return this.name + ": " + this.message } }); function zi(e, t) {
    return e + ". Errors: " + Object.keys(t).map(function (r) { return t[r].toString() }).filter(function (r, n, i) { return i.indexOf(r) === n }).join(`
`)
} function ur(e, t, r, n) { this._e = Qe(), this.failures = t, this.failedKeys = n, this.successCount = r, this.message = zi(e, t) } ut(ur).from(lt); function St(e, t) { this._e = Qe(), this.name = "BulkError", this.failures = Object.keys(t).map(function (r) { return t[r] }), this.failuresByPos = t, this.message = zi(e, t) } ut(St).from(lt); var kn = Tn.reduce(function (e, t) { return e[t] = t + "Error", e }, {}), bo = lt, I = Tn.reduce(function (e, t) {
    var r = t + "Error"; function n(i, a) {
        this._e = Qe(), this.name = r, i ? typeof i == "string" ? (this.message = "" + i + (a ? `
 `+ a : ""), this.inner = a || null) : typeof i == "object" && (this.message = i.name + " " + i.message, this.inner = i) : (this.message = go[t] || r, this.inner = null)
    } return ut(n).from(bo), e[t] = n, e
}, {}); I.Syntax = SyntaxError; I.Type = TypeError; I.Range = RangeError; var Jn = Ui.reduce(function (e, t) { return e[t + "Error"] = I[t], e }, {}); function _o(e, t) { if (!e || e instanceof lt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Jn[e.name]) return e; var r = new Jn[e.name](t || e.message, e); return "stack" in e && Ie(r, "stack", { get: function () { return this.inner.stack } }), r } var Tr = Tn.reduce(function (e, t) { return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = I[t]), e }, {}); Tr.ModifyError = ur; Tr.DexieError = lt; Tr.BulkError = St; function U() { } function jt(e) { return e } function Co(e, t) { return e == null || e === jt ? t : function (r) { return t(e(r)) } } function Ye(e, t) { return function () { e.apply(this, arguments), t.apply(this, arguments) } } function So(e, t) { return e === U ? t : function () { var r = e.apply(this, arguments); r !== void 0 && (arguments[0] = r); var n = this.onsuccess, i = this.onerror; this.onsuccess = null, this.onerror = null; var a = t.apply(this, arguments); return n && (this.onsuccess = this.onsuccess ? Ye(n, this.onsuccess) : n), i && (this.onerror = this.onerror ? Ye(i, this.onerror) : i), a !== void 0 ? a : r } } function To(e, t) { return e === U ? t : function () { e.apply(this, arguments); var r = this.onsuccess, n = this.onerror; this.onsuccess = this.onerror = null, t.apply(this, arguments), r && (this.onsuccess = this.onsuccess ? Ye(r, this.onsuccess) : r), n && (this.onerror = this.onerror ? Ye(n, this.onerror) : n) } } function ko(e, t) { return e === U ? t : function (r) { var n = e.apply(this, arguments); ue(r, n); var i = this.onsuccess, a = this.onerror; this.onsuccess = null, this.onerror = null; var o = t.apply(this, arguments); return i && (this.onsuccess = this.onsuccess ? Ye(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? Ye(a, this.onerror) : a), n === void 0 ? o === void 0 ? void 0 : o : ue(n, o) } } function Po(e, t) { return e === U ? t : function () { return t.apply(this, arguments) === !1 ? !1 : e.apply(this, arguments) } } function Pn(e, t) { return e === U ? t : function () { var r = e.apply(this, arguments); if (r && typeof r.then == "function") { for (var n = this, i = arguments.length, a = new Array(i); i--;)a[i] = arguments[i]; return r.then(function () { return t.apply(n, a) }) } return t.apply(this, arguments) } } var Et = {}, Ro = 100, Eo = 20, $i = 100, Rn = typeof Promise > "u" ? [] : function () { var e = Promise.resolve(); if (typeof crypto > "u" || !crypto.subtle) return [e, Rt(e), e]; var t = crypto.subtle.digest("SHA-512", new Uint8Array([0])); return [t, Rt(t), e] }(), Vr = Rn[0], lr = Rn[1], Hr = Rn[2], Gi = lr && lr.then, Xt = Vr && Vr.constructor, En = !!Hr, qr = !1, xo = Hr ? function () { Hr.then(zt) } : $.setImmediate ? setImmediate.bind(null, zt) : $.MutationObserver ? function () { var e = document.createElement("div"); new MutationObserver(function () { zt(), e = null }).observe(e, { attributes: !0 }), e.setAttribute("i", "1") } : function () { setTimeout(zt, 0) }, xt = function (e, t) { gt.push([e, t]), fr && (xo(), fr = !1) }, Wr = !0, fr = !0, qe = [], Qt = [], Yr = null, Xr = jt, it = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: qn, pgp: !1, env: {}, finalize: function () { this.unhandleds.forEach(function (e) { try { qn(e[0], e[1]) } catch { } }) } }, w = it, gt = [], We = 0, Zt = []; function E(e) { if (typeof this != "object") throw new TypeError("Promises must be constructed via new"); this._listeners = [], this.onuncatched = U, this._lib = !1; var t = this._PSD = w; if (Te && (this._stackHolder = Qe(), this._prev = null, this._numPrev = 0), typeof e != "function") { if (e !== Et) throw new TypeError("Not a function"); this._state = arguments[1], this._value = arguments[2], this._state === !1 && Zr(this, this._value); return } this._state = null, this._value = null, ++t.ref, Vi(this, e) } var Qr = { get: function () { var e = w, t = pr; function r(n, i) { var a = this, o = !e.global && (e !== w || t !== pr), u = o && !Me(), s = new E(function (c, l) { xn(a, new Ji(hr(n, e, o, u), hr(i, e, o, u), c, l, e)) }); return Te && Wi(s, this), s } return r.prototype = Et, r }, set: function (e) { Ie(this, "then", e && e.prototype === Et ? Qr : { get: function () { return e }, set: Qr.set }) } }; ct(E.prototype, {
    then: Qr, _then: function (e, t) { xn(this, new Ji(null, null, e, t, w)) }, catch: function (e) { if (arguments.length === 1) return this.then(null, e); var t = arguments[0], r = arguments[1]; return typeof t == "function" ? this.then(null, function (n) { return n instanceof t ? r(n) : er(n) }) : this.then(null, function (n) { return n && n.name === t ? r(n) : er(n) }) }, finally: function (e) { return this.then(function (t) { return e(), t }, function (t) { return e(), er(t) }) }, stack: {
        get: function () {
            if (this._stack) return this._stack; try {
                qr = !0; var e = qi(this, [], Eo), t = e.join(`
From previous: `); return this._state !== null && (this._stack = t), t
            } finally { qr = !1 }
        }
    }, timeout: function (e, t) { var r = this; return e < 1 / 0 ? new E(function (n, i) { var a = setTimeout(function () { return i(new I.Timeout(t)) }, e); r.then(n, i).finally(clearTimeout.bind(null, a)) }) : this }
}); typeof Symbol < "u" && Symbol.toStringTag && Ie(E.prototype, Symbol.toStringTag, "Dexie.Promise"); it.env = Yi(); function Ji(e, t, r, n, i) { this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = r, this.reject = n, this.psd = i } ct(E, { all: function () { var e = xe.apply(null, arguments).map(dr); return new E(function (t, r) { e.length === 0 && t([]); var n = e.length; e.forEach(function (i, a) { return E.resolve(i).then(function (o) { e[a] = o, --n || t(e) }, r) }) }) }, resolve: function (e) { if (e instanceof E) return e; if (e && typeof e.then == "function") return new E(function (r, n) { e.then(r, n) }); var t = new E(Et, !0, e); return Wi(t, Yr), t }, reject: er, race: function () { var e = xe.apply(null, arguments).map(dr); return new E(function (t, r) { e.map(function (n) { return E.resolve(n).then(t, r) }) }) }, PSD: { get: function () { return w }, set: function (e) { return w = e } }, totalEchoes: { get: function () { return pr } }, newPSD: Ue, usePSD: pt, scheduler: { get: function () { return xt }, set: function (e) { xt = e } }, rejectionMapper: { get: function () { return Xr }, set: function (e) { Xr = e } }, follow: function (e, t) { return new E(function (r, n) { return Ue(function (i, a) { var o = w; o.unhandleds = [], o.onunhandled = a, o.finalize = Ye(function () { var u = this; wo(function () { u.unhandleds.length === 0 ? i() : a(u.unhandleds[0]) }) }, o.finalize), e() }, t, r, n) }) } }); Xt && (Xt.allSettled && Ie(E, "allSettled", function () { var e = xe.apply(null, arguments).map(dr); return new E(function (t) { e.length === 0 && t([]); var r = e.length, n = new Array(r); e.forEach(function (i, a) { return E.resolve(i).then(function (o) { return n[a] = { status: "fulfilled", value: o } }, function (o) { return n[a] = { status: "rejected", reason: o } }).then(function () { return --r || t(n) }) }) }) }), Xt.any && typeof AggregateError < "u" && Ie(E, "any", function () { var e = xe.apply(null, arguments).map(dr); return new E(function (t, r) { e.length === 0 && r(new AggregateError([])); var n = e.length, i = new Array(n); e.forEach(function (a, o) { return E.resolve(a).then(function (u) { return t(u) }, function (u) { i[o] = u, --n || r(new AggregateError(i)) }) }) }) })); function Vi(e, t) { try { t(function (r) { if (e._state === null) { if (r === e) throw new TypeError("A promise cannot be resolved with itself."); var n = e._lib && Bt(); r && typeof r.then == "function" ? Vi(e, function (i, a) { r instanceof E ? r._then(i, a) : r.then(i, a) }) : (e._state = !0, e._value = r, Hi(e)), n && Ft() } }, Zr.bind(null, e)) } catch (r) { Zr(e, r) } } function Zr(e, t) { if (Qt.push(t), e._state === null) { var r = e._lib && Bt(); t = Xr(t), e._state = !1, e._value = t, Te && t !== null && typeof t == "object" && !t._promise && uo(function () { var n = Cn(t, "stack"); t._promise = e, Ie(t, "stack", { get: function () { return qr ? n && (n.get ? n.get.apply(t) : n.value) : e.stack } }) }), Oo(e), Hi(e), r && Ft() } } function Hi(e) { var t = e._listeners; e._listeners = []; for (var r = 0, n = t.length; r < n; ++r)xn(e, t[r]); var i = e._PSD; --i.ref || i.finalize(), We === 0 && (++We, xt(function () { --We === 0 && Dn() }, [])) } function xn(e, t) { if (e._state === null) { e._listeners.push(t); return } var r = e._state ? t.onFulfilled : t.onRejected; if (r === null) return (e._state ? t.resolve : t.reject)(e._value); ++t.psd.ref, ++We, xt(Do, [r, e, t]) } function Do(e, t, r) { try { Yr = t; var n, i = t._value; t._state ? n = e(i) : (Qt.length && (Qt = []), n = e(i), Qt.indexOf(i) === -1 && Ao(t)), r.resolve(n) } catch (a) { r.reject(a) } finally { Yr = null, --We === 0 && Dn(), --r.psd.ref || r.psd.finalize() } } function qi(e, t, r) { if (t.length === r) return t; var n = ""; if (e._state === !1) { var i = e._value, a, o; i != null ? (a = i.name || "Error", o = i.message || i, n = Jr(i, 0)) : (a = i, o = ""), t.push(a + (o ? ": " + o : "") + n) } return Te && (n = Jr(e._stackHolder, 2), n && t.indexOf(n) === -1 && t.push(n), e._prev && qi(e._prev, t, r)), t } function Wi(e, t) { var r = t ? t._numPrev + 1 : 0; r < Ro && (e._prev = t, e._numPrev = r) } function zt() { Bt() && Ft() } function Bt() { var e = Wr; return Wr = !1, fr = !1, e } function Ft() { var e, t, r; do for (; gt.length > 0;)for (e = gt, gt = [], r = e.length, t = 0; t < r; ++t) { var n = e[t]; n[0].apply(null, n[1]) } while (gt.length > 0); Wr = !0, fr = !0 } function Dn() { var e = qe; qe = [], e.forEach(function (n) { n._PSD.onunhandled.call(null, n._value, n) }); for (var t = Zt.slice(0), r = t.length; r;)t[--r]() } function wo(e) { function t() { e(), Zt.splice(Zt.indexOf(t), 1) } Zt.push(t), ++We, xt(function () { --We === 0 && Dn() }, []) } function Oo(e) { qe.some(function (t) { return t._value === e._value }) || qe.push(e) } function Ao(e) { for (var t = qe.length; t;)if (qe[--t]._value === e._value) { qe.splice(t, 1); return } } function er(e) { return new E(Et, !1, e) } function G(e, t) { var r = w; return function () { var n = Bt(), i = w; try { return ze(r, !0), e.apply(this, arguments) } catch (a) { t && t(a) } finally { ze(i, !1), n && Ft() } } } var ie = { awaits: 0, echoes: 0, id: 0 }, Io = 0, tr = [], Er = 0, pr = 0, Mo = 0; function Ue(e, t, r, n) { var i = w, a = Object.create(i); a.parent = i, a.ref = 0, a.global = !1, a.id = ++Mo; var o = it.env; a.env = En ? { Promise: E, PromiseProp: { value: E, configurable: !0, writable: !0 }, all: E.all, race: E.race, allSettled: E.allSettled, any: E.any, resolve: E.resolve, reject: E.reject, nthen: Vn(o.nthen, a), gthen: Vn(o.gthen, a) } : {}, t && ue(a, t), ++i.ref, a.finalize = function () { --this.parent.ref || this.parent.finalize() }; var u = pt(a, e, r, n); return a.ref === 0 && a.finalize(), u } function ft() { return ie.id || (ie.id = ++Io), ++ie.awaits, ie.echoes += $i, ie.id } function Me() { return ie.awaits ? (--ie.awaits === 0 && (ie.id = 0), ie.echoes = ie.awaits * $i, !0) : !1 } ("" + Gi).indexOf("[native code]") === -1 && (ft = Me = U); function dr(e) { return ie.echoes && e && e.constructor === Xt ? (ft(), e.then(function (t) { return Me(), t }, function (t) { return Me(), q(t) })) : e } function jo(e) { ++pr, (!ie.echoes || --ie.echoes === 0) && (ie.echoes = ie.id = 0), tr.push(w), ze(e, !0) } function Bo() { var e = tr[tr.length - 1]; tr.pop(), ze(e, !1) } function ze(e, t) { var r = w; if ((t ? ie.echoes && (!Er++ || e !== w) : Er && (!--Er || e !== w)) && Xi(t ? jo.bind(null, e) : Bo), e !== w && (w = e, r === it && (it.env = Yi()), En)) { var n = it.env.Promise, i = e.env; lr.then = i.nthen, n.prototype.then = i.gthen, (r.global || e.global) && (Object.defineProperty($, "Promise", i.PromiseProp), n.all = i.all, n.race = i.race, n.resolve = i.resolve, n.reject = i.reject, i.allSettled && (n.allSettled = i.allSettled), i.any && (n.any = i.any)) } } function Yi() { var e = $.Promise; return En ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor($, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject, nthen: lr.then, gthen: e.prototype.then } : {} } function pt(e, t, r, n, i) { var a = w; try { return ze(e, !0), t(r, n, i) } finally { ze(a, !1) } } function Xi(e) { Gi.call(Vr, e) } function hr(e, t, r, n) { return typeof e != "function" ? e : function () { var i = w; r && ft(), ze(t, !0); try { return e.apply(this, arguments) } finally { ze(i, !1), n && Xi(Me) } } } function Vn(e, t) { return function (r, n) { return e.call(this, hr(r, t), hr(n, t)) } } var Hn = "unhandledrejection"; function qn(e, t) { var r; try { r = t.onuncatched(e) } catch { } if (r !== !1) try { var n, i = { promise: t, reason: e }; if ($.document && document.createEvent ? (n = document.createEvent("Event"), n.initEvent(Hn, !0, !0), ue(n, i)) : $.CustomEvent && (n = new CustomEvent(Hn, { detail: i }), ue(n, i)), n && $.dispatchEvent && (dispatchEvent(n), !$.PromiseRejectionEvent && $.onunhandledrejection)) try { $.onunhandledrejection(n) } catch { } Te && n && !n.defaultPrevented && console.warn("Unhandled rejection: " + (e.stack || e)) } catch { } } var q = E.reject; function en(e, t, r, n) { if (!e.idbdb || !e._state.openComplete && !w.letThrough && !e._vip) { if (e._state.openComplete) return q(new I.DatabaseClosed(e._state.dbOpenError)); if (!e._state.isBeingOpened) { if (!e._options.autoOpen) return q(new I.DatabaseClosed); e.open().catch(U) } return e._state.dbReadyPromise.then(function () { return en(e, t, r, n) }) } else { var i = e._createTransaction(t, r, e._dbSchema); try { i.create(), e._state.PR1398_maxLoop = 3 } catch (a) { return a.name === kn.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return en(e, t, r, n) })) : q(a) } return i._promise(t, function (a, o) { return Ue(function () { return w.trans = i, n(a, o, i) }) }).then(function (a) { return i._completion.then(function () { return a }) }) } } var Wn = "3.2.2", He = String.fromCharCode(65535), tn = -1 / 0, Pe = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Qi = "String expected.", Tt = [], kr = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), Fo = kr, Ko = kr, Zi = function (e) { return !/(dexie\.js|dexie\.min\.js)/.test(e) }, Pr = "__dbnames", xr = "readonly", Dr = "readwrite"; function Xe(e, t) { return e ? t ? function () { return e.apply(this, arguments) && t.apply(this, arguments) } : e : t } var ea = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 }; function $t(e) { return typeof e == "string" && !/\./.test(e) ? function (t) { return t[e] === void 0 && e in t && (t = Mt(t), delete t[e]), t } : function (t) { return t } } var No = function () { function e() { } return e.prototype._trans = function (t, r, n) { var i = this._tx || w.trans, a = this.name; function o(s, c, l) { if (!l.schema[a]) throw new I.NotFound("Table " + a + " not part of transaction"); return r(l.idbtrans, l) } var u = Bt(); try { return i && i.db === this.db ? i === w.trans ? i._promise(t, o, n) : Ue(function () { return i._promise(t, o, n) }, { trans: i, transless: w.transless || w }) : en(this.db, t, [this.name], o) } finally { u && Ft() } }, e.prototype.get = function (t, r) { var n = this; return t && t.constructor === Object ? this.where(t).first(r) : this._trans("readonly", function (i) { return n.core.get({ trans: i, key: t }).then(function (a) { return n.hook.reading.fire(a) }) }).then(r) }, e.prototype.where = function (t) { if (typeof t == "string") return new this.db.WhereClause(this, t); if (ae(t)) return new this.db.WhereClause(this, "[" + t.join("+") + "]"); var r = H(t); if (r.length === 1) return this.where(r[0]).equals(t[r[0]]); var n = this.schema.indexes.concat(this.schema.primKey).filter(function (l) { return l.compound && r.every(function (f) { return l.keyPath.indexOf(f) >= 0 }) && l.keyPath.every(function (f) { return r.indexOf(f) >= 0 }) })[0]; if (n && this.db._maxKey !== He) return this.where(n.name).equals(n.keyPath.map(function (l) { return t[l] })); !n && Te && console.warn("The query " + JSON.stringify(t) + " on " + this.name + " would benefit of a " + ("compound index [" + r.join("+") + "]")); var i = this.schema.idxByName, a = this.db._deps.indexedDB; function o(l, f) { try { return a.cmp(l, f) === 0 } catch { return !1 } } var u = r.reduce(function (l, f) { var p = l[0], m = l[1], d = i[f], h = t[f]; return [p || d, p || !d ? Xe(m, d && d.multi ? function (b) { var v = Oe(b, f); return ae(v) && v.some(function (g) { return o(h, g) }) } : function (b) { return o(h, Oe(b, f)) }) : m] }, [null, null]), s = u[0], c = u[1]; return s ? this.where(s.name).equals(t[s.keyPath]).filter(c) : n ? this.filter(c) : this.where(r).equals("") }, e.prototype.filter = function (t) { return this.toCollection().and(t) }, e.prototype.count = function (t) { return this.toCollection().count(t) }, e.prototype.offset = function (t) { return this.toCollection().offset(t) }, e.prototype.limit = function (t) { return this.toCollection().limit(t) }, e.prototype.each = function (t) { return this.toCollection().each(t) }, e.prototype.toArray = function (t) { return this.toCollection().toArray(t) }, e.prototype.toCollection = function () { return new this.db.Collection(new this.db.WhereClause(this)) }, e.prototype.orderBy = function (t) { return new this.db.Collection(new this.db.WhereClause(this, ae(t) ? "[" + t.join("+") + "]" : t)) }, e.prototype.reverse = function () { return this.toCollection().reverse() }, e.prototype.mapToClass = function (t) { this.schema.mappedClass = t; var r = function (n) { if (!n) return n; var i = Object.create(t.prototype); for (var a in n) if (ye(n, a)) try { i[a] = n[a] } catch { } return i }; return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook("reading", r), t }, e.prototype.defineClass = function () { function t(r) { ue(this, r) } return this.mapToClass(t) }, e.prototype.add = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = $t(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "add", keys: r != null ? [r] : null, values: [u] }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { Ce(t, o, s) } catch { } return s }) }, e.prototype.update = function (t, r) { if (typeof t == "object" && !ae(t)) { var n = Oe(t, this.schema.primKey.keyPath); if (n === void 0) return q(new I.InvalidArgument("Given object does not contain its primary key")); try { typeof r != "function" ? H(r).forEach(function (i) { Ce(t, i, r[i]) }) : r(t, { value: t, primKey: n }) } catch { } return this.where(":id").equals(n).modify(r) } else return this.where(":id").equals(t).modify(r) }, e.prototype.put = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = $t(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "put", values: [u], keys: r != null ? [r] : null }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { Ce(t, o, s) } catch { } return s }) }, e.prototype.delete = function (t) { var r = this; return this._trans("readwrite", function (n) { return r.core.mutate({ trans: n, type: "delete", keys: [t] }) }).then(function (n) { return n.numFailures ? E.reject(n.failures[0]) : void 0 }) }, e.prototype.clear = function () { var t = this; return this._trans("readwrite", function (r) { return t.core.mutate({ trans: r, type: "deleteRange", range: ea }) }).then(function (r) { return r.numFailures ? E.reject(r.failures[0]) : void 0 }) }, e.prototype.bulkGet = function (t) { var r = this; return this._trans("readonly", function (n) { return r.core.getMany({ keys: t, trans: n }).then(function (i) { return i.map(function (a) { return r.hook.reading.fire(a) }) }) }) }, e.prototype.bulkAdd = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, l = s.keyPath; if (l && a) throw new I.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new I.InvalidArgument("Arguments objects and keys must have the same length"); var f = t.length, p = l && c ? t.map($t(l)) : t; return i.core.mutate({ trans: u, type: "add", keys: a, values: p, wantResults: o }).then(function (m) { var d = m.numFailures, h = m.results, b = m.lastResult, v = m.failures, g = o ? h : b; if (d === 0) return g; throw new St(i.name + ".bulkAdd(): " + d + " of " + f + " operations failed", v) }) }) }, e.prototype.bulkPut = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, l = s.keyPath; if (l && a) throw new I.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new I.InvalidArgument("Arguments objects and keys must have the same length"); var f = t.length, p = l && c ? t.map($t(l)) : t; return i.core.mutate({ trans: u, type: "put", keys: a, values: p, wantResults: o }).then(function (m) { var d = m.numFailures, h = m.results, b = m.lastResult, v = m.failures, g = o ? h : b; if (d === 0) return g; throw new St(i.name + ".bulkPut(): " + d + " of " + f + " operations failed", v) }) }) }, e.prototype.bulkDelete = function (t) { var r = this, n = t.length; return this._trans("readwrite", function (i) { return r.core.mutate({ trans: i, type: "delete", keys: t }) }).then(function (i) { var a = i.numFailures, o = i.lastResult, u = i.failures; if (a === 0) return o; throw new St(r.name + ".bulkDelete(): " + a + " of " + n + " operations failed", u) }) }, e }(); function Kt(e) { var t = {}, r = function (u, s) { if (s) { for (var c = arguments.length, l = new Array(c - 1); --c;)l[c - 1] = arguments[c]; return t[u].subscribe.apply(null, l), e } else if (typeof u == "string") return t[u] }; r.addEventType = a; for (var n = 1, i = arguments.length; n < i; ++n)a(arguments[n]); return r; function a(u, s, c) { if (typeof u == "object") return o(u); s || (s = Po), c || (c = U); var l = { subscribers: [], fire: c, subscribe: function (f) { l.subscribers.indexOf(f) === -1 && (l.subscribers.push(f), l.fire = s(l.fire, f)) }, unsubscribe: function (f) { l.subscribers = l.subscribers.filter(function (p) { return p !== f }), l.fire = l.subscribers.reduce(s, c) } }; return t[u] = r[u] = l, l } function o(u) { H(u).forEach(function (s) { var c = u[s]; if (ae(c)) a(s, u[s][0], u[s][1]); else if (c === "asap") var l = a(s, jt, function () { for (var p = arguments.length, m = new Array(p); p--;)m[p] = arguments[p]; l.subscribers.forEach(function (d) { Mi(function () { d.apply(null, m) }) }) }); else throw new I.InvalidArgument("Invalid event config") }) } } function Nt(e, t) { return ut(t).from({ prototype: e }), t } function Lo(e) { return Nt(No.prototype, function (r, n, i) { this.db = e, this._tx = i, this.name = r, this.schema = n, this.hook = e._allTables[r] ? e._allTables[r].hook : Kt(null, { creating: [So, U], reading: [Co, jt], updating: [ko, U], deleting: [To, U] }) }) } function Ze(e, t) { return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter) } function wr(e, t) { e.filter = Xe(e.filter, t) } function Or(e, t, r) { var n = e.replayFilter; e.replayFilter = n ? function () { return Xe(n(), t()) } : t, e.justLimit = r && !n } function Uo(e, t) { e.isMatch = Xe(e.isMatch, t) } function rr(e, t) { if (e.isPrimKey) return t.primaryKey; var r = t.getIndexByKeyPath(e.index); if (!r) throw new I.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed"); return r } function Yn(e, t, r) { var n = rr(e, t.schema); return t.openCursor({ trans: r, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: n, range: e.range } }) } function Gt(e, t, r, n) { var i = e.replayFilter ? Xe(e.filter, e.replayFilter()) : e.filter; if (e.or) { var a = {}, o = function (u, s, c) { if (!i || i(s, c, function (p) { return s.stop(p) }, function (p) { return s.fail(p) })) { var l = s.primaryKey, f = "" + l; f === "[object ArrayBuffer]" && (f = "" + new Uint8Array(l)), ye(a, f) || (a[f] = !0, t(u, s, c)) } }; return Promise.all([e.or._iterate(o, r), Xn(Yn(e, n, r), e.algorithm, o, !e.keysOnly && e.valueMapper)]) } else return Xn(Yn(e, n, r), Xe(e.algorithm, i), t, !e.keysOnly && e.valueMapper) } function Xn(e, t, r, n) { var i = n ? function (o, u, s) { return r(n(o), u, s) } : r, a = G(i); return e.then(function (o) { if (o) return o.start(function () { var u = function () { return o.continue() }; (!t || t(o, function (s) { return u = s }, function (s) { o.stop(s), u = U }, function (s) { o.fail(s), u = U })) && a(o.value, o, function (s) { return u = s }), u() }) }) } function ce(e, t) { try { var r = Qn(e), n = Qn(t); if (r !== n) return r === "Array" ? 1 : n === "Array" ? -1 : r === "binary" ? 1 : n === "binary" ? -1 : r === "string" ? 1 : n === "string" ? -1 : r === "Date" ? 1 : n !== "Date" ? NaN : -1; switch (r) { case "number": case "Date": case "string": return e > t ? 1 : e < t ? -1 : 0; case "binary": return $o(Zn(e), Zn(t)); case "Array": return zo(e, t) } } catch { } return NaN } function zo(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a) { var o = ce(e[a], t[a]); if (o !== 0) return o } return r === n ? 0 : r < n ? -1 : 1 } function $o(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a)if (e[a] !== t[a]) return e[a] < t[a] ? -1 : 1; return r === n ? 0 : r < n ? -1 : 1 } function Qn(e) { var t = typeof e; if (t !== "object") return t; if (ArrayBuffer.isView(e)) return "binary"; var r = $r(e); return r === "ArrayBuffer" ? "binary" : r } function Zn(e) { return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e) } var Go = function () { function e() { } return e.prototype._read = function (t, r) { var n = this._ctx; return n.error ? n.table._trans(null, q.bind(null, n.error)) : n.table._trans("readonly", t).then(r) }, e.prototype._write = function (t) { var r = this._ctx; return r.error ? r.table._trans(null, q.bind(null, r.error)) : r.table._trans("readwrite", t, "locked") }, e.prototype._addAlgorithm = function (t) { var r = this._ctx; r.algorithm = Xe(r.algorithm, t) }, e.prototype._iterate = function (t, r) { return Gt(this._ctx, t, r, this._ctx.table.core) }, e.prototype.clone = function (t) { var r = Object.create(this.constructor.prototype), n = Object.create(this._ctx); return t && ue(n, t), r._ctx = n, r }, e.prototype.raw = function () { return this._ctx.valueMapper = null, this }, e.prototype.each = function (t) { var r = this._ctx; return this._read(function (n) { return Gt(r, t, n, r.table.core) }) }, e.prototype.count = function (t) { var r = this; return this._read(function (n) { var i = r._ctx, a = i.table.core; if (Ze(i, !0)) return a.count({ trans: n, query: { index: rr(i, a.schema), range: i.range } }).then(function (u) { return Math.min(u, i.limit) }); var o = 0; return Gt(i, function () { return ++o, !1 }, n, a).then(function () { return o }) }).then(t) }, e.prototype.sortBy = function (t, r) { var n = t.split(".").reverse(), i = n[0], a = n.length - 1; function o(c, l) { return l ? o(c[n[l]], l - 1) : c[i] } var u = this._ctx.dir === "next" ? 1 : -1; function s(c, l) { var f = o(c, a), p = o(l, a); return f < p ? -u : f > p ? u : 0 } return this.toArray(function (c) { return c.sort(s) }).then(r) }, e.prototype.toArray = function (t) { var r = this; return this._read(function (n) { var i = r._ctx; if (i.dir === "next" && Ze(i, !0) && i.limit > 0) { var a = i.valueMapper, o = rr(i, i.table.core.schema); return i.table.core.query({ trans: n, limit: i.limit, values: !0, query: { index: o, range: i.range } }).then(function (s) { var c = s.result; return a ? c.map(a) : c }) } else { var u = []; return Gt(i, function (s) { return u.push(s) }, n, i.table.core).then(function () { return u }) } }, t) }, e.prototype.offset = function (t) { var r = this._ctx; return t <= 0 ? this : (r.offset += t, Ze(r) ? Or(r, function () { var n = t; return function (i, a) { return n === 0 ? !0 : n === 1 ? (--n, !1) : (a(function () { i.advance(n), n = 0 }), !1) } }) : Or(r, function () { var n = t; return function () { return --n < 0 } }), this) }, e.prototype.limit = function (t) { return this._ctx.limit = Math.min(this._ctx.limit, t), Or(this._ctx, function () { var r = t; return function (n, i, a) { return --r <= 0 && i(a), r >= 0 } }, !0), this }, e.prototype.until = function (t, r) { return wr(this._ctx, function (n, i, a) { return t(n.value) ? (i(a), r) : !0 }), this }, e.prototype.first = function (t) { return this.limit(1).toArray(function (r) { return r[0] }).then(t) }, e.prototype.last = function (t) { return this.reverse().first(t) }, e.prototype.filter = function (t) { return wr(this._ctx, function (r) { return t(r.value) }), Uo(this._ctx, t), this }, e.prototype.and = function (t) { return this.filter(t) }, e.prototype.or = function (t) { return new this.db.WhereClause(this._ctx.table, t, this) }, e.prototype.reverse = function () { return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this }, e.prototype.desc = function () { return this.reverse() }, e.prototype.eachKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.key, i) }) }, e.prototype.eachUniqueKey = function (t) { return this._ctx.unique = "unique", this.eachKey(t) }, e.prototype.eachPrimaryKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.primaryKey, i) }) }, e.prototype.keys = function (t) { var r = this._ctx; r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.key) }).then(function () { return n }).then(t) }, e.prototype.primaryKeys = function (t) { var r = this._ctx; if (r.dir === "next" && Ze(r, !0) && r.limit > 0) return this._read(function (i) { var a = rr(r, r.table.core.schema); return r.table.core.query({ trans: i, values: !1, limit: r.limit, query: { index: a, range: r.range } }) }).then(function (i) { var a = i.result; return a }).then(t); r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.primaryKey) }).then(function () { return n }).then(t) }, e.prototype.uniqueKeys = function (t) { return this._ctx.unique = "unique", this.keys(t) }, e.prototype.firstKey = function (t) { return this.limit(1).keys(function (r) { return r[0] }).then(t) }, e.prototype.lastKey = function (t) { return this.reverse().firstKey(t) }, e.prototype.distinct = function () { var t = this._ctx, r = t.index && t.table.schema.idxByName[t.index]; if (!r || !r.multi) return this; var n = {}; return wr(this._ctx, function (i) { var a = i.primaryKey.toString(), o = ye(n, a); return n[a] = !0, !o }), this }, e.prototype.modify = function (t) { var r = this, n = this._ctx; return this._write(function (i) { var a; if (typeof t == "function") a = t; else { var o = H(t), u = o.length; a = function (v) { for (var g = !1, C = 0; C < u; ++C) { var _ = o[C], y = t[_]; Oe(v, _) !== y && (Ce(v, _, y), g = !0) } return g } } var s = n.table.core, c = s.schema.primaryKey, l = c.outbound, f = c.extractKey, p = r.db._options.modifyChunkSize || 200, m = [], d = 0, h = [], b = function (v, g) { var C = g.failures, _ = g.numFailures; d += v - _; for (var y = 0, S = H(C); y < S.length; y++) { var R = S[y]; m.push(C[R]) } }; return r.clone().primaryKeys().then(function (v) { var g = function (C) { var _ = Math.min(p, v.length - C); return s.getMany({ trans: i, keys: v.slice(C, C + _), cache: "immutable" }).then(function (y) { for (var S = [], R = [], T = l ? [] : null, O = [], k = 0; k < _; ++k) { var N = y[k], K = { value: Mt(N), primKey: v[C + k] }; a.call(K, K.value, K) !== !1 && (K.value == null ? O.push(v[C + k]) : !l && ce(f(N), f(K.value)) !== 0 ? (O.push(v[C + k]), S.push(K.value)) : (R.push(K.value), l && T.push(v[C + k]))) } var F = Ze(n) && n.limit === 1 / 0 && (typeof t != "function" || t === Ar) && { index: n.index, range: n.range }; return Promise.resolve(S.length > 0 && s.mutate({ trans: i, type: "add", values: S }).then(function (z) { for (var M in z.failures) O.splice(parseInt(M), 1); b(S.length, z) })).then(function () { return (R.length > 0 || F && typeof t == "object") && s.mutate({ trans: i, type: "put", keys: T, values: R, criteria: F, changeSpec: typeof t != "function" && t }).then(function (z) { return b(R.length, z) }) }).then(function () { return (O.length > 0 || F && t === Ar) && s.mutate({ trans: i, type: "delete", keys: O, criteria: F }).then(function (z) { return b(O.length, z) }) }).then(function () { return v.length > C + _ && g(C + p) }) }) }; return g(0).then(function () { if (m.length > 0) throw new ur("Error modifying one or more objects", m, d, h); return v.length }) }) }) }, e.prototype.delete = function () { var t = this._ctx, r = t.range; return Ze(t) && (t.isPrimKey && !Ko || r.type === 3) ? this._write(function (n) { var i = t.table.core.schema.primaryKey, a = r; return t.table.core.count({ trans: n, query: { index: i, range: a } }).then(function (o) { return t.table.core.mutate({ trans: n, type: "deleteRange", range: a }).then(function (u) { var s = u.failures; u.lastResult, u.results; var c = u.numFailures; if (c) throw new ur("Could not delete some values", Object.keys(s).map(function (l) { return s[l] }), o - c); return o - c }) }) }) : this.modify(Ar) }, e }(), Ar = function (e, t) { return t.value = null }; function Jo(e) { return Nt(Go.prototype, function (r, n) { this.db = e; var i = ea, a = null; if (n) try { i = n() } catch (c) { a = c } var o = r._ctx, u = o.table, s = u.hook.reading.fire; this._ctx = { table: u, index: o.index, isPrimKey: !o.index || u.schema.primKey.keyPath && o.index === u.schema.primKey.name, range: i, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: a, or: o.or, valueMapper: s !== jt ? s : null } }) } function Vo(e, t) { return e < t ? -1 : e === t ? 0 : 1 } function Ho(e, t) { return e > t ? -1 : e === t ? 0 : 1 } function ve(e, t, r) { var n = e instanceof ra ? new e.Collection(e) : e; return n._ctx.error = r ? new r(t) : new TypeError(t), n } function et(e) { return new e.Collection(e, function () { return ta("") }).limit(0) } function qo(e) { return e === "next" ? function (t) { return t.toUpperCase() } : function (t) { return t.toLowerCase() } } function Wo(e) { return e === "next" ? function (t) { return t.toLowerCase() } : function (t) { return t.toUpperCase() } } function Yo(e, t, r, n, i, a) { for (var o = Math.min(e.length, n.length), u = -1, s = 0; s < o; ++s) { var c = t[s]; if (c !== n[s]) return i(e[s], r[s]) < 0 ? e.substr(0, s) + r[s] + r.substr(s + 1) : i(e[s], n[s]) < 0 ? e.substr(0, s) + n[s] + r.substr(s + 1) : u >= 0 ? e.substr(0, u) + t[u] + r.substr(u + 1) : null; i(e[s], c) < 0 && (u = s) } return o < n.length && a === "next" ? e + r.substr(e.length) : o < e.length && a === "prev" ? e.substr(0, r.length) : u < 0 ? null : e.substr(0, u) + n[u] + r.substr(u + 1) } function Jt(e, t, r, n) { var i, a, o, u, s, c, l, f = r.length; if (!r.every(function (h) { return typeof h == "string" })) return ve(e, Qi); function p(h) { i = qo(h), a = Wo(h), o = h === "next" ? Vo : Ho; var b = r.map(function (v) { return { lower: a(v), upper: i(v) } }).sort(function (v, g) { return o(v.lower, g.lower) }); u = b.map(function (v) { return v.upper }), s = b.map(function (v) { return v.lower }), c = h, l = h === "next" ? "" : n } p("next"); var m = new e.Collection(e, function () { return Ke(u[0], s[f - 1] + n) }); m._ondirectionchange = function (h) { p(h) }; var d = 0; return m._addAlgorithm(function (h, b, v) { var g = h.key; if (typeof g != "string") return !1; var C = a(g); if (t(C, s, d)) return !0; for (var _ = null, y = d; y < f; ++y) { var S = Yo(g, C, u[y], s[y], o, c); S === null && _ === null ? d = y + 1 : (_ === null || o(_, S) > 0) && (_ = S) } return b(_ !== null ? function () { h.continue(_ + l) } : v), !1 }), m } function Ke(e, t, r, n) { return { type: 2, lower: e, upper: t, lowerOpen: r, upperOpen: n } } function ta(e) { return { type: 1, lower: e, upper: e } } var ra = function () { function e() { } return Object.defineProperty(e.prototype, "Collection", { get: function () { return this._ctx.table.db.Collection }, enumerable: !1, configurable: !0 }), e.prototype.between = function (t, r, n, i) { n = n !== !1, i = i === !0; try { return this._cmp(t, r) > 0 || this._cmp(t, r) === 0 && (n || i) && !(n && i) ? et(this) : new this.Collection(this, function () { return Ke(t, r, !n, !i) }) } catch { return ve(this, Pe) } }, e.prototype.equals = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return ta(t) }) }, e.prototype.above = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Ke(t, void 0, !0) }) }, e.prototype.aboveOrEqual = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Ke(t, void 0, !1) }) }, e.prototype.below = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Ke(void 0, t, !1, !0) }) }, e.prototype.belowOrEqual = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Ke(void 0, t) }) }, e.prototype.startsWith = function (t) { return typeof t != "string" ? ve(this, Qi) : this.between(t, t + He, !0, !0) }, e.prototype.startsWithIgnoreCase = function (t) { return t === "" ? this.startsWith(t) : Jt(this, function (r, n) { return r.indexOf(n[0]) === 0 }, [t], He) }, e.prototype.equalsIgnoreCase = function (t) { return Jt(this, function (r, n) { return r === n[0] }, [t], "") }, e.prototype.anyOfIgnoreCase = function () { var t = xe.apply(tt, arguments); return t.length === 0 ? et(this) : Jt(this, function (r, n) { return n.indexOf(r) !== -1 }, t, "") }, e.prototype.startsWithAnyOfIgnoreCase = function () { var t = xe.apply(tt, arguments); return t.length === 0 ? et(this) : Jt(this, function (r, n) { return n.some(function (i) { return r.indexOf(i) === 0 }) }, t, He) }, e.prototype.anyOf = function () { var t = this, r = xe.apply(tt, arguments), n = this._cmp; try { r.sort(n) } catch { return ve(this, Pe) } if (r.length === 0) return et(this); var i = new this.Collection(this, function () { return Ke(r[0], r[r.length - 1]) }); i._ondirectionchange = function (o) { n = o === "next" ? t._ascending : t._descending, r.sort(n) }; var a = 0; return i._addAlgorithm(function (o, u, s) { for (var c = o.key; n(c, r[a]) > 0;)if (++a, a === r.length) return u(s), !1; return n(c, r[a]) === 0 ? !0 : (u(function () { o.continue(r[a]) }), !1) }), i }, e.prototype.notEqual = function (t) { return this.inAnyRange([[tn, t], [t, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 }) }, e.prototype.noneOf = function () { var t = xe.apply(tt, arguments); if (t.length === 0) return new this.Collection(this); try { t.sort(this._ascending) } catch { return ve(this, Pe) } var r = t.reduce(function (n, i) { return n ? n.concat([[n[n.length - 1][1], i]]) : [[tn, i]] }, null); return r.push([t[t.length - 1], this.db._maxKey]), this.inAnyRange(r, { includeLowers: !1, includeUppers: !1 }) }, e.prototype.inAnyRange = function (t, r) { var n = this, i = this._cmp, a = this._ascending, o = this._descending, u = this._min, s = this._max; if (t.length === 0) return et(this); if (!t.every(function (y) { return y[0] !== void 0 && y[1] !== void 0 && a(y[0], y[1]) <= 0 })) return ve(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", I.InvalidArgument); var c = !r || r.includeLowers !== !1, l = r && r.includeUppers === !0; function f(y, S) { for (var R = 0, T = y.length; R < T; ++R) { var O = y[R]; if (i(S[0], O[1]) < 0 && i(S[1], O[0]) > 0) { O[0] = u(O[0], S[0]), O[1] = s(O[1], S[1]); break } } return R === T && y.push(S), y } var p = a; function m(y, S) { return p(y[0], S[0]) } var d; try { d = t.reduce(f, []), d.sort(m) } catch { return ve(this, Pe) } var h = 0, b = l ? function (y) { return a(y, d[h][1]) > 0 } : function (y) { return a(y, d[h][1]) >= 0 }, v = c ? function (y) { return o(y, d[h][0]) > 0 } : function (y) { return o(y, d[h][0]) >= 0 }; function g(y) { return !b(y) && !v(y) } var C = b, _ = new this.Collection(this, function () { return Ke(d[0][0], d[d.length - 1][1], !c, !l) }); return _._ondirectionchange = function (y) { y === "next" ? (C = b, p = a) : (C = v, p = o), d.sort(m) }, _._addAlgorithm(function (y, S, R) { for (var T = y.key; C(T);)if (++h, h === d.length) return S(R), !1; return g(T) ? !0 : (n._cmp(T, d[h][1]) === 0 || n._cmp(T, d[h][0]) === 0 || S(function () { p === a ? y.continue(d[h][0]) : y.continue(d[h][1]) }), !1) }), _ }, e.prototype.startsWithAnyOf = function () { var t = xe.apply(tt, arguments); return t.every(function (r) { return typeof r == "string" }) ? t.length === 0 ? et(this) : this.inAnyRange(t.map(function (r) { return [r, r + He] })) : ve(this, "startsWithAnyOf() only works with strings") }, e }(); function Xo(e) { return Nt(ra.prototype, function (r, n, i) { this.db = e, this._ctx = { table: r, index: n === ":id" ? null : n, or: i }; var a = e._deps.indexedDB; if (!a) throw new I.MissingAPI; this._cmp = this._ascending = a.cmp.bind(a), this._descending = function (o, u) { return a.cmp(u, o) }, this._max = function (o, u) { return a.cmp(o, u) > 0 ? o : u }, this._min = function (o, u) { return a.cmp(o, u) < 0 ? o : u }, this._IDBKeyRange = e._deps.IDBKeyRange }) } function Se(e) { return G(function (t) { return Dt(t), e(t.target.error), !1 }) } function Dt(e) { e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault() } var wt = "storagemutated", Le = "x-storagemutated-1", $e = Kt(null, wt), Qo = function () { function e() { } return e.prototype._lock = function () { return yt(!w.global), ++this._reculock, this._reculock === 1 && !w.global && (w.lockOwnerFor = this), this }, e.prototype._unlock = function () { if (yt(!w.global), --this._reculock === 0) for (w.global || (w.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) { var t = this._blockedFuncs.shift(); try { pt(t[1], t[0]) } catch { } } return this }, e.prototype._locked = function () { return this._reculock && w.lockOwnerFor !== this }, e.prototype.create = function (t) { var r = this; if (!this.mode) return this; var n = this.db.idbdb, i = this.db._state.dbOpenError; if (yt(!this.idbtrans), !t && !n) switch (i && i.name) { case "DatabaseClosedError": throw new I.DatabaseClosed(i); case "MissingAPIError": throw new I.MissingAPI(i.message, i); default: throw new I.OpenFailed(i) }if (!this.active) throw new I.TransactionInactive; return yt(this._completion._state === null), t = this.idbtrans = t || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })), t.onerror = G(function (a) { Dt(a), r._reject(t.error) }), t.onabort = G(function (a) { Dt(a), r.active && r._reject(new I.Abort(t.error)), r.active = !1, r.on("abort").fire(a) }), t.oncomplete = G(function () { r.active = !1, r._resolve(), "mutatedParts" in t && $e.storagemutated.fire(t.mutatedParts) }), this }, e.prototype._promise = function (t, r, n) { var i = this; if (t === "readwrite" && this.mode !== "readwrite") return q(new I.ReadOnly("Transaction is readonly")); if (!this.active) return q(new I.TransactionInactive); if (this._locked()) return new E(function (o, u) { i._blockedFuncs.push([function () { i._promise(t, r, n).then(o, u) }, w]) }); if (n) return Ue(function () { var o = new E(function (u, s) { i._lock(); var c = r(u, s, i); c && c.then && c.then(u, s) }); return o.finally(function () { return i._unlock() }), o._lib = !0, o }); var a = new E(function (o, u) { var s = r(o, u, i); s && s.then && s.then(o, u) }); return a._lib = !0, a }, e.prototype._root = function () { return this.parent ? this.parent._root() : this }, e.prototype.waitFor = function (t) { var r = this._root(), n = E.resolve(t); if (r._waitingFor) r._waitingFor = r._waitingFor.then(function () { return n }); else { r._waitingFor = n, r._waitingQueue = []; var i = r.idbtrans.objectStore(r.storeNames[0]); (function o() { for (++r._spinCount; r._waitingQueue.length;)r._waitingQueue.shift()(); r._waitingFor && (i.get(-1 / 0).onsuccess = o) })() } var a = r._waitingFor; return new E(function (o, u) { n.then(function (s) { return r._waitingQueue.push(G(o.bind(null, s))) }, function (s) { return r._waitingQueue.push(G(u.bind(null, s))) }).finally(function () { r._waitingFor === a && (r._waitingFor = null) }) }) }, e.prototype.abort = function () { this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new I.Abort)) }, e.prototype.table = function (t) { var r = this._memoizedTables || (this._memoizedTables = {}); if (ye(r, t)) return r[t]; var n = this.schema[t]; if (!n) throw new I.NotFound("Table " + t + " not part of transaction"); var i = new this.db.Table(t, n, this); return i.core = this.db.core.table(t), r[t] = i, i }, e }(); function Zo(e) { return Nt(Qo.prototype, function (r, n, i, a, o) { var u = this; this.db = e, this.mode = r, this.storeNames = n, this.schema = i, this.chromeTransactionDurability = a, this.idbtrans = null, this.on = Kt(this, "complete", "error", "abort"), this.parent = o || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new E(function (s, c) { u._resolve = s, u._reject = c }), this._completion.then(function () { u.active = !1, u.on.complete.fire() }, function (s) { var c = u.active; return u.active = !1, u.on.error.fire(s), u.parent ? u.parent._reject(s) : c && u.idbtrans && u.idbtrans.abort(), q(s) }) }) } function rn(e, t, r, n, i, a, o) { return { name: e, keyPath: t, unique: r, multi: n, auto: i, compound: a, src: (r && !o ? "&" : "") + (n ? "*" : "") + (i ? "++" : "") + na(t) } } function na(e) { return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "" } function ia(e, t, r) { return { name: e, primKey: t, indexes: r, mappedClass: null, idxByName: ji(r, function (n) { return [n.name, n] }) } } function es(e) { return e.length === 1 ? e[0] : e } var Ot = function (e) { try { return e.only([[]]), Ot = function () { return [[]] }, [[]] } catch { return Ot = function () { return He }, He } }; function nn(e) { return e == null ? function () { } : typeof e == "string" ? ts(e) : function (t) { return Oe(t, e) } } function ts(e) { var t = e.split("."); return t.length === 1 ? function (r) { return r[e] } : function (r) { return Oe(r, e) } } function ei(e) { return [].slice.call(e) } var rs = 0; function kt(e) { return e == null ? ":id" : typeof e == "string" ? e : "[" + e.join("+") + "]" } function ns(e, t, r) { function n(f, p) { var m = ei(f.objectStoreNames); return { schema: { name: f.name, tables: m.map(function (d) { return p.objectStore(d) }).map(function (d) { var h = d.keyPath, b = d.autoIncrement, v = ae(h), g = h == null, C = {}, _ = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g, compound: v, keyPath: h, autoIncrement: b, unique: !0, extractKey: nn(h) }, indexes: ei(d.indexNames).map(function (y) { return d.index(y) }).map(function (y) { var S = y.name, R = y.unique, T = y.multiEntry, O = y.keyPath, k = ae(O), N = { name: S, compound: k, keyPath: O, unique: R, multiEntry: T, extractKey: nn(O) }; return C[kt(O)] = N, N }), getIndexByKeyPath: function (y) { return C[kt(y)] } }; return C[":id"] = _.primaryKey, h != null && (C[kt(h)] = _.primaryKey), _ }) }, hasGetAll: m.length > 0 && "getAll" in p.objectStore(m[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) } } function i(f) { if (f.type === 3) return null; if (f.type === 4) throw new Error("Cannot convert never type to IDBKeyRange"); var p = f.lower, m = f.upper, d = f.lowerOpen, h = f.upperOpen, b = p === void 0 ? m === void 0 ? null : t.upperBound(m, !!h) : m === void 0 ? t.lowerBound(p, !!d) : t.bound(p, m, !!d, !!h); return b } function a(f) { var p = f.name; function m(b) { var v = b.trans, g = b.type, C = b.keys, _ = b.values, y = b.range; return new Promise(function (S, R) { S = G(S); var T = v.objectStore(p), O = T.keyPath == null, k = g === "put" || g === "add"; if (!k && g !== "delete" && g !== "deleteRange") throw new Error("Invalid operation type: " + g); var N = (C || _ || { length: 1 }).length; if (C && _ && C.length !== _.length) throw new Error("Given keys array must have same length as given values array."); if (N === 0) return S({ numFailures: 0, failures: {}, results: [], lastResult: void 0 }); var K, F = [], z = [], M = 0, te = function (me) { ++M, Dt(me) }; if (g === "deleteRange") { if (y.type === 4) return S({ numFailures: M, failures: z, results: [], lastResult: void 0 }); y.type === 3 ? F.push(K = T.clear()) : F.push(K = T.delete(i(y))) } else { var X = k ? O ? [_, C] : [_, null] : [C, null], W = X[0], he = X[1]; if (k) for (var se = 0; se < N; ++se)F.push(K = he && he[se] !== void 0 ? T[g](W[se], he[se]) : T[g](W[se])), K.onerror = te; else for (var se = 0; se < N; ++se)F.push(K = T[g](W[se])), K.onerror = te } var ge = function (me) { var je = me.target.result; F.forEach(function (Y, Be) { return Y.error != null && (z[Be] = Y.error) }), S({ numFailures: M, failures: z, results: g === "delete" ? C : F.map(function (Y) { return Y.result }), lastResult: je }) }; K.onerror = function (me) { te(me), ge(me) }, K.onsuccess = ge }) } function d(b) { var v = b.trans, g = b.values, C = b.query, _ = b.reverse, y = b.unique; return new Promise(function (S, R) { S = G(S); var T = C.index, O = C.range, k = v.objectStore(p), N = T.isPrimaryKey ? k : k.index(T.name), K = _ ? y ? "prevunique" : "prev" : y ? "nextunique" : "next", F = g || !("openKeyCursor" in N) ? N.openCursor(i(O), K) : N.openKeyCursor(i(O), K); F.onerror = Se(R), F.onsuccess = G(function (z) { var M = F.result; if (!M) { S(null); return } M.___id = ++rs, M.done = !1; var te = M.continue.bind(M), X = M.continuePrimaryKey; X && (X = X.bind(M)); var W = M.advance.bind(M), he = function () { throw new Error("Cursor not started") }, se = function () { throw new Error("Cursor not stopped") }; M.trans = v, M.stop = M.continue = M.continuePrimaryKey = M.advance = he, M.fail = G(R), M.next = function () { var ge = this, me = 1; return this.start(function () { return me-- ? ge.continue() : ge.stop() }).then(function () { return ge }) }, M.start = function (ge) { var me = new Promise(function (Y, Be) { Y = G(Y), F.onerror = Se(Be), M.fail = Be, M.stop = function (Fe) { M.stop = M.continue = M.continuePrimaryKey = M.advance = se, Y(Fe) } }), je = function () { if (F.result) try { ge() } catch (Y) { M.fail(Y) } else M.done = !0, M.start = function () { throw new Error("Cursor behind last entry") }, M.stop() }; return F.onsuccess = G(function (Y) { F.onsuccess = je, je() }), M.continue = te, M.continuePrimaryKey = X, M.advance = W, je(), me }, S(M) }, R) }) } function h(b) { return function (v) { return new Promise(function (g, C) { g = G(g); var _ = v.trans, y = v.values, S = v.limit, R = v.query, T = S === 1 / 0 ? void 0 : S, O = R.index, k = R.range, N = _.objectStore(p), K = O.isPrimaryKey ? N : N.index(O.name), F = i(k); if (S === 0) return g({ result: [] }); if (b) { var z = y ? K.getAll(F, T) : K.getAllKeys(F, T); z.onsuccess = function (W) { return g({ result: W.target.result }) }, z.onerror = Se(C) } else { var M = 0, te = y || !("openKeyCursor" in K) ? K.openCursor(F) : K.openKeyCursor(F), X = []; te.onsuccess = function (W) { var he = te.result; if (!he) return g({ result: X }); if (X.push(y ? he.value : he.primaryKey), ++M === S) return g({ result: X }); he.continue() }, te.onerror = Se(C) } }) } } return { name: p, schema: f, mutate: m, getMany: function (b) { var v = b.trans, g = b.keys; return new Promise(function (C, _) { C = G(C); for (var y = v.objectStore(p), S = g.length, R = new Array(S), T = 0, O = 0, k, N = function (M) { var te = M.target; (R[te._pos] = te.result) != null, ++O === T && C(R) }, K = Se(_), F = 0; F < S; ++F) { var z = g[F]; z != null && (k = y.get(g[F]), k._pos = F, k.onsuccess = N, k.onerror = K, ++T) } T === 0 && C(R) }) }, get: function (b) { var v = b.trans, g = b.key; return new Promise(function (C, _) { C = G(C); var y = v.objectStore(p), S = y.get(g); S.onsuccess = function (R) { return C(R.target.result) }, S.onerror = Se(_) }) }, query: h(s), openCursor: d, count: function (b) { var v = b.query, g = b.trans, C = v.index, _ = v.range; return new Promise(function (y, S) { var R = g.objectStore(p), T = C.isPrimaryKey ? R : R.index(C.name), O = i(_), k = O ? T.count(O) : T.count(); k.onsuccess = G(function (N) { return y(N.target.result) }), k.onerror = Se(S) }) } } } var o = n(e, r), u = o.schema, s = o.hasGetAll, c = u.tables.map(function (f) { return a(f) }), l = {}; return c.forEach(function (f) { return l[f.name] = f }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function (f) { var p = l[f]; if (!p) throw new Error("Table '" + f + "' not found"); return l[f] }, MIN_KEY: -1 / 0, MAX_KEY: Ot(t), schema: u } } function is(e, t) { return t.reduce(function (r, n) { var i = n.create; return B(B({}, r), i(r)) }, e) } function as(e, t, r, n) { var i = r.IDBKeyRange; r.indexedDB; var a = is(ns(t, i, n), e.dbcore); return { dbcore: a } } function wn(e, t) { var r = e._novip, n = t.db, i = as(r._middlewares, n, r._deps, t); r.core = i.dbcore, r.tables.forEach(function (a) { var o = a.name; r.core.schema.tables.some(function (u) { return u.name === o }) && (a.core = r.core.table(o), r[o] instanceof r.Table && (r[o].core = a.core)) }) } function mr(e, t, r, n) { var i = e._novip; r.forEach(function (a) { var o = n[a]; t.forEach(function (u) { var s = Cn(u, a); (!s || "value" in s && s.value === void 0) && (u === i.Transaction.prototype || u instanceof i.Transaction ? Ie(u, a, { get: function () { return this.table(a) }, set: function (c) { Ai(this, a, { value: c, writable: !0, configurable: !0, enumerable: !0 }) } }) : u[a] = new i.Table(a, o)) }) }) } function an(e, t) { var r = e._novip; t.forEach(function (n) { for (var i in n) n[i] instanceof r.Table && delete n[i] }) } function os(e, t) { return e._cfg.version - t._cfg.version } function ss(e, t, r, n) { var i = e._dbSchema, a = e._createTransaction("readwrite", e._storeNames, i); a.create(r), a._completion.catch(n); var o = a._reject.bind(a), u = w.transless || w; Ue(function () { w.trans = a, w.transless = u, t === 0 ? (H(i).forEach(function (s) { On(r, s, i[s].primKey, i[s].indexes) }), wn(e, r), E.follow(function () { return e.on.populate.fire(a) }).catch(o)) : cs(e, t, a, r).catch(o) }) } function cs(e, t, r, n) { var i = e._novip, a = [], o = i._versions, u = i._dbSchema = An(i, i.idbdb, n), s = !1, c = o.filter(function (f) { return f._cfg.version >= t }); c.forEach(function (f) { a.push(function () { var p = u, m = f._cfg.dbschema; sn(i, p, n), sn(i, m, n), u = i._dbSchema = m; var d = aa(p, m); d.add.forEach(function (_) { On(n, _[0], _[1].primKey, _[1].indexes) }), d.change.forEach(function (_) { if (_.recreate) throw new I.Upgrade("Not yet support for changing primary key"); var y = n.objectStore(_.name); _.add.forEach(function (S) { return on(y, S) }), _.change.forEach(function (S) { y.deleteIndex(S.name), on(y, S) }), _.del.forEach(function (S) { return y.deleteIndex(S) }) }); var h = f._cfg.contentUpgrade; if (h && f._cfg.version > t) { wn(i, n), r._memoizedTables = {}, s = !0; var b = Bi(m); d.del.forEach(function (_) { b[_] = p[_] }), an(i, [i.Transaction.prototype]), mr(i, [i.Transaction.prototype], H(b), b), r.schema = b; var v = Sn(h); v && ft(); var g, C = E.follow(function () { if (g = h(r), g && v) { var _ = Me.bind(null, null); g.then(_, _) } }); return g && typeof g.then == "function" ? E.resolve(g) : C.then(function () { return g }) } }), a.push(function (p) { if (!s || !Fo) { var m = f._cfg.dbschema; ls(m, p) } an(i, [i.Transaction.prototype]), mr(i, [i.Transaction.prototype], i._storeNames, i._dbSchema), r.schema = i._dbSchema }) }); function l() { return a.length ? E.resolve(a.shift()(r.idbtrans)).then(l) : E.resolve() } return l().then(function () { us(u, n) }) } function aa(e, t) { var r = { del: [], add: [], change: [] }, n; for (n in e) t[n] || r.del.push(n); for (n in t) { var i = e[n], a = t[n]; if (!i) r.add.push([n, a]); else { var o = { name: n, def: a, recreate: !1, del: [], add: [], change: [] }; if ("" + (i.primKey.keyPath || "") != "" + (a.primKey.keyPath || "") || i.primKey.auto !== a.primKey.auto && !kr) o.recreate = !0, r.change.push(o); else { var u = i.idxByName, s = a.idxByName, c = void 0; for (c in u) s[c] || o.del.push(c); for (c in s) { var l = u[c], f = s[c]; l ? l.src !== f.src && o.change.push(f) : o.add.push(f) } (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && r.change.push(o) } } } return r } function On(e, t, r, n) { var i = e.db.createObjectStore(t, r.keyPath ? { keyPath: r.keyPath, autoIncrement: r.auto } : { autoIncrement: r.auto }); return n.forEach(function (a) { return on(i, a) }), i } function us(e, t) { H(e).forEach(function (r) { t.db.objectStoreNames.contains(r) || On(t, r, e[r].primKey, e[r].indexes) }) } function ls(e, t) { [].slice.call(t.db.objectStoreNames).forEach(function (r) { return e[r] == null && t.db.deleteObjectStore(r) }) } function on(e, t) { e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi }) } function An(e, t, r) { var n = {}, i = Sr(t.objectStoreNames, 0); return i.forEach(function (a) { for (var o = r.objectStore(a), u = o.keyPath, s = rn(na(u), u || "", !1, !1, !!o.autoIncrement, u && typeof u != "string", !0), c = [], l = 0; l < o.indexNames.length; ++l) { var f = o.index(o.indexNames[l]); u = f.keyPath; var p = rn(f.name, u, !!f.unique, !!f.multiEntry, !1, u && typeof u != "string", !1); c.push(p) } n[a] = ia(a, s, c) }), n } function fs(e, t, r) { var n = e._novip; n.verno = t.version / 10; var i = n._dbSchema = An(n, t, r); n._storeNames = Sr(t.objectStoreNames, 0), mr(n, [n._allTables], H(i), i) } function ps(e, t) { var r = An(e, e.idbdb, t), n = aa(r, e._dbSchema); return !(n.add.length || n.change.some(function (i) { return i.add.length || i.change.length })) } function sn(e, t, r) { for (var n = e._novip, i = r.db.objectStoreNames, a = 0; a < i.length; ++a) { var o = i[a], u = r.objectStore(o); n._hasGetAll = "getAll" in u; for (var s = 0; s < u.indexNames.length; ++s) { var c = u.indexNames[s], l = u.index(c).keyPath, f = typeof l == "string" ? l : "[" + Sr(l).join("+") + "]"; if (t[o]) { var p = t[o].idxByName[f]; p && (p.name = c, delete t[o].idxByName[f], t[o].idxByName[c] = p) } } } typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && $.WorkerGlobalScope && $ instanceof $.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1) } function ds(e) { return e.split(",").map(function (t, r) { t = t.trim(); var n = t.replace(/([&*]|\+\+)/g, ""), i = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split("+") : n; return rn(n, i || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), ae(i), r === 0) }) } var hs = function () { function e() { } return e.prototype._parseStoresSpec = function (t, r) { H(t).forEach(function (n) { if (t[n] !== null) { var i = ds(t[n]), a = i.shift(); if (a.multi) throw new I.Schema("Primary key cannot be multi-valued"); i.forEach(function (o) { if (o.auto) throw new I.Schema("Only primary key can be marked as autoIncrement (++)"); if (!o.keyPath) throw new I.Schema("Index must have a name and cannot be an empty string") }), r[n] = ia(n, a, i) } }) }, e.prototype.stores = function (t) { var r = this.db; this._cfg.storesSource = this._cfg.storesSource ? ue(this._cfg.storesSource, t) : t; var n = r._versions, i = {}, a = {}; return n.forEach(function (o) { ue(i, o._cfg.storesSource), a = o._cfg.dbschema = {}, o._parseStoresSpec(i, a) }), r._dbSchema = a, an(r, [r._allTables, r, r.Transaction.prototype]), mr(r, [r._allTables, r, r.Transaction.prototype, this._cfg.tables], H(a), a), r._storeNames = H(a), this }, e.prototype.upgrade = function (t) { return this._cfg.contentUpgrade = Pn(this._cfg.contentUpgrade || U, t), this }, e }(); function ms(e) { return Nt(hs.prototype, function (r) { this.db = e, this._cfg = { version: r, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null } }) } function In(e, t) { var r = e._dbNamesDB; return r || (r = e._dbNamesDB = new Fn(Pr, { addons: [], indexedDB: e, IDBKeyRange: t }), r.version(1).stores({ dbnames: "name" })), r.table("dbnames") } function Mn(e) { return e && typeof e.databases == "function" } function vs(e) { var t = e.indexedDB, r = e.IDBKeyRange; return Mn(t) ? Promise.resolve(t.databases()).then(function (n) { return n.map(function (i) { return i.name }).filter(function (i) { return i !== Pr }) }) : In(t, r).toCollection().primaryKeys() } function ys(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !Mn(r) && t !== Pr && In(r, n).put({ name: t }).catch(U) } function gs(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !Mn(r) && t !== Pr && In(r, n).delete(t).catch(U) } function cn(e) { return Ue(function () { return w.letThrough = !0, e() }) } function bs() { var e = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent); if (!e || !indexedDB.databases) return Promise.resolve(); var t; return new Promise(function (r) { var n = function () { return indexedDB.databases().finally(r) }; t = setInterval(n, 100), n() }).finally(function () { return clearInterval(t) }) } function _s(e) { var t = e._state, r = e._deps.indexedDB; if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function () { return t.dbOpenError ? q(t.dbOpenError) : e }); Te && (t.openCanceller._stackHolder = Qe()), t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1; var n = t.openCanceller; function i() { if (t.openCanceller !== n) throw new I.DatabaseClosed("db.open() was cancelled") } var a = t.dbReadyResolve, o = null, u = !1; return E.race([n, (typeof navigator > "u" ? E.resolve() : bs()).then(function () { return new E(function (s, c) { if (i(), !r) throw new I.MissingAPI; var l = e.name, f = t.autoSchema ? r.open(l) : r.open(l, Math.round(e.verno * 10)); if (!f) throw new I.MissingAPI; f.onerror = Se(c), f.onblocked = G(e._fireOnBlocked), f.onupgradeneeded = G(function (p) { if (o = f.transaction, t.autoSchema && !e._options.allowEmptyDB) { f.onerror = Dt, o.abort(), f.result.close(); var m = r.deleteDatabase(l); m.onsuccess = m.onerror = G(function () { c(new I.NoSuchDatabase("Database " + l + " doesnt exist")) }) } else { o.onerror = Se(c); var d = p.oldVersion > Math.pow(2, 62) ? 0 : p.oldVersion; u = d < 1, e._novip.idbdb = f.result, ss(e, d / 10, o, c) } }, c), f.onsuccess = G(function () { o = null; var p = e._novip.idbdb = f.result, m = Sr(p.objectStoreNames); if (m.length > 0) try { var d = p.transaction(es(m), "readonly"); t.autoSchema ? fs(e, p, d) : (sn(e, e._dbSchema, d), ps(e, d) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), wn(e, d) } catch { } Tt.push(e), p.onversionchange = G(function (h) { t.vcFired = !0, e.on("versionchange").fire(h) }), p.onclose = G(function (h) { e.on("close").fire(h) }), u && ys(e._deps, l), s() }, c) }) })]).then(function () { return i(), t.onReadyBeingFired = [], E.resolve(cn(function () { return e.on.ready.fire(e.vip) })).then(function s() { if (t.onReadyBeingFired.length > 0) { var c = t.onReadyBeingFired.reduce(Pn, U); return t.onReadyBeingFired = [], E.resolve(cn(function () { return c(e.vip) })).then(s) } }) }).finally(function () { t.onReadyBeingFired = null, t.isBeingOpened = !1 }).then(function () { return e }).catch(function (s) { t.dbOpenError = s; try { o && o.abort() } catch { } return n === t.openCanceller && e._close(), q(s) }).finally(function () { t.openComplete = !0, a() }) } function un(e) { var t = function (o) { return e.next(o) }, r = function (o) { return e.throw(o) }, n = a(t), i = a(r); function a(o) { return function (u) { var s = o(u), c = s.value; return s.done ? c : !c || typeof c.then != "function" ? ae(c) ? Promise.all(c).then(n, i) : n(c) : c.then(n, i) } } return a(t)() } function Cs(e, t, r) { var n = arguments.length; if (n < 2) throw new I.InvalidArgument("Too few arguments"); for (var i = new Array(n - 1); --n;)i[n - 1] = arguments[n]; r = i.pop(); var a = Fi(i); return [e, a, r] } function oa(e, t, r, n, i) { return E.resolve().then(function () { var a = w.transless || w, o = e._createTransaction(t, r, e._dbSchema, n), u = { trans: o, transless: a }; if (n) o.idbtrans = n.idbtrans; else try { o.create(), e._state.PR1398_maxLoop = 3 } catch (f) { return f.name === kn.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return oa(e, t, r, null, i) })) : q(f) } var s = Sn(i); s && ft(); var c, l = E.follow(function () { if (c = i.call(o, o), c) if (s) { var f = Me.bind(null, null); c.then(f, f) } else typeof c.next == "function" && typeof c.throw == "function" && (c = un(c)) }, u); return (c && typeof c.then == "function" ? E.resolve(c).then(function (f) { return o.active ? f : q(new I.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")) }) : l.then(function () { return c })).then(function (f) { return n && o._resolve(), o._completion.then(function () { return f }) }).catch(function (f) { return o._reject(f), q(f) }) }) } function Vt(e, t, r) { for (var n = ae(e) ? e.slice() : [e], i = 0; i < r; ++i)n.push(t); return n } function Ss(e) { return B(B({}, e), { table: function (t) { var r = e.table(t), n = r.schema, i = {}, a = []; function o(h, b, v) { var g = kt(h), C = i[g] = i[g] || [], _ = h == null ? 0 : typeof h == "string" ? 1 : h.length, y = b > 0, S = B(B({}, v), { isVirtual: y, keyTail: b, keyLength: _, extractKey: nn(h), unique: !y && v.unique }); if (C.push(S), S.isPrimaryKey || a.push(S), _ > 1) { var R = _ === 2 ? h[0] : h.slice(0, _ - 1); o(R, b + 1, v) } return C.sort(function (T, O) { return T.keyTail - O.keyTail }), S } var u = o(n.primaryKey.keyPath, 0, n.primaryKey); i[":id"] = [u]; for (var s = 0, c = n.indexes; s < c.length; s++) { var l = c[s]; o(l.keyPath, 0, l) } function f(h) { var b = i[kt(h)]; return b && b[0] } function p(h, b) { return { type: h.type === 1 ? 2 : h.type, lower: Vt(h.lower, h.lowerOpen ? e.MAX_KEY : e.MIN_KEY, b), lowerOpen: !0, upper: Vt(h.upper, h.upperOpen ? e.MIN_KEY : e.MAX_KEY, b), upperOpen: !0 } } function m(h) { var b = h.query.index; return b.isVirtual ? B(B({}, h), { query: { index: b, range: p(h.query.range, b.keyTail) } }) : h } var d = B(B({}, r), { schema: B(B({}, n), { primaryKey: u, indexes: a, getIndexByKeyPath: f }), count: function (h) { return r.count(m(h)) }, query: function (h) { return r.query(m(h)) }, openCursor: function (h) { var b = h.query.index, v = b.keyTail, g = b.isVirtual, C = b.keyLength; if (!g) return r.openCursor(h); function _(y) { function S(T) { T != null ? y.continue(Vt(T, h.reverse ? e.MAX_KEY : e.MIN_KEY, v)) : h.unique ? y.continue(y.key.slice(0, C).concat(h.reverse ? e.MIN_KEY : e.MAX_KEY, v)) : y.continue() } var R = Object.create(y, { continue: { value: S }, continuePrimaryKey: { value: function (T, O) { y.continuePrimaryKey(Vt(T, e.MAX_KEY, v), O) } }, primaryKey: { get: function () { return y.primaryKey } }, key: { get: function () { var T = y.key; return C === 1 ? T[0] : T.slice(0, C) } }, value: { get: function () { return y.value } } }); return R } return r.openCursor(m(h)).then(function (y) { return y && _(y) }) } }); return d } }) } var Ts = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: Ss }; function jn(e, t, r, n) { return r = r || {}, n = n || "", H(e).forEach(function (i) { if (!ye(t, i)) r[n + i] = void 0; else { var a = e[i], o = t[i]; if (typeof a == "object" && typeof o == "object" && a && o) { var u = $r(a), s = $r(o); u !== s ? r[n + i] = t[i] : u === "Object" ? jn(a, o, r, n + i + ".") : a !== o && (r[n + i] = t[i]) } else a !== o && (r[n + i] = t[i]) } }), H(t).forEach(function (i) { ye(e, i) || (r[n + i] = t[i]) }), r } function ks(e, t) { return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey) } var Ps = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function (e) { return B(B({}, e), { table: function (t) { var r = e.table(t), n = r.schema.primaryKey, i = B(B({}, r), { mutate: function (a) { var o = w.trans, u = o.table(t).hook, s = u.deleting, c = u.creating, l = u.updating; switch (a.type) { case "add": if (c.fire === U) break; return o._promise("readwrite", function () { return f(a) }, !0); case "put": if (c.fire === U && l.fire === U) break; return o._promise("readwrite", function () { return f(a) }, !0); case "delete": if (s.fire === U) break; return o._promise("readwrite", function () { return f(a) }, !0); case "deleteRange": if (s.fire === U) break; return o._promise("readwrite", function () { return p(a) }, !0) }return r.mutate(a); function f(d) { var h = w.trans, b = d.keys || ks(n, d); if (!b) throw new Error("Keys missing"); return d = d.type === "add" || d.type === "put" ? B(B({}, d), { keys: b }) : B({}, d), d.type !== "delete" && (d.values = Ur([], d.values, !0)), d.keys && (d.keys = Ur([], d.keys, !0)), Rs(r, d, b).then(function (v) { var g = b.map(function (C, _) { var y = v[_], S = { onerror: null, onsuccess: null }; if (d.type === "delete") s.fire.call(S, C, y, h); else if (d.type === "add" || y === void 0) { var R = c.fire.call(S, C, d.values[_], h); C == null && R != null && (C = R, d.keys[_] = C, n.outbound || Ce(d.values[_], n.keyPath, C)) } else { var T = jn(y, d.values[_]), O = l.fire.call(S, T, C, y, h); if (O) { var k = d.values[_]; Object.keys(O).forEach(function (N) { ye(k, N) ? k[N] = O[N] : Ce(k, N, O[N]) }) } } return S }); return r.mutate(d).then(function (C) { for (var _ = C.failures, y = C.results, S = C.numFailures, R = C.lastResult, T = 0; T < b.length; ++T) { var O = y ? y[T] : b[T], k = g[T]; O == null ? k.onerror && k.onerror(_[T]) : k.onsuccess && k.onsuccess(d.type === "put" && v[T] ? d.values[T] : O) } return { failures: _, results: y, numFailures: S, lastResult: R } }).catch(function (C) { return g.forEach(function (_) { return _.onerror && _.onerror(C) }), Promise.reject(C) }) }) } function p(d) { return m(d.trans, d.range, 1e4) } function m(d, h, b) { return r.query({ trans: d, values: !1, query: { index: n, range: h }, limit: b }).then(function (v) { var g = v.result; return f({ type: "delete", keys: g, trans: d }).then(function (C) { return C.numFailures > 0 ? Promise.reject(C.failures[0]) : g.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : m(d, B(B({}, h), { lower: g[g.length - 1], lowerOpen: !0 }), b) }) }) } } }); return i } }) } }; function Rs(e, t, r) { return t.type === "add" ? Promise.resolve([]) : e.getMany({ trans: t.trans, keys: r, cache: "immutable" }) } function sa(e, t, r) { try { if (!t || t.keys.length < e.length) return null; for (var n = [], i = 0, a = 0; i < t.keys.length && a < e.length; ++i)ce(t.keys[i], e[a]) === 0 && (n.push(r ? Mt(t.values[i]) : t.values[i]), ++a); return n.length === e.length ? n : null } catch { return null } } var Es = { stack: "dbcore", level: -1, create: function (e) { return { table: function (t) { var r = e.table(t); return B(B({}, r), { getMany: function (n) { if (!n.cache) return r.getMany(n); var i = sa(n.keys, n.trans._cache, n.cache === "clone"); return i ? E.resolve(i) : r.getMany(n).then(function (a) { return n.trans._cache = { keys: n.keys, values: n.cache === "clone" ? Mt(a) : a }, a }) }, mutate: function (n) { return n.type !== "add" && (n.trans._cache = null), r.mutate(n) } }) } } } }, Ir; function Bn(e) { return !("from" in e) } var Ee = function (e, t) { if (this) ue(this, arguments.length ? { d: 1, from: e, to: arguments.length > 1 ? t : e } : { d: 0 }); else { var r = new Ee; return e && "d" in e && ue(r, e), r } }; ct(Ee.prototype, (Ir = { add: function (e) { return vr(this, e), this }, addKey: function (e) { return At(this, e, e), this }, addKeys: function (e) { var t = this; return e.forEach(function (r) { return At(t, r, r) }), this } }, Ir[Gr] = function () { return ln(this) }, Ir)); function At(e, t, r) { var n = ce(t, r); if (!isNaN(n)) { if (n > 0) throw RangeError(); if (Bn(e)) return ue(e, { from: t, to: r, d: 1 }); var i = e.l, a = e.r; if (ce(r, e.from) < 0) return i ? At(i, t, r) : e.l = { from: t, to: r, d: 1, l: null, r: null }, ti(e); if (ce(t, e.to) > 0) return a ? At(a, t, r) : e.r = { from: t, to: r, d: 1, l: null, r: null }, ti(e); ce(t, e.from) < 0 && (e.from = t, e.l = null, e.d = a ? a.d + 1 : 1), ce(r, e.to) > 0 && (e.to = r, e.r = null, e.d = e.l ? e.l.d + 1 : 1); var o = !e.r; i && !e.l && vr(e, i), a && o && vr(e, a) } } function vr(e, t) { function r(n, i) { var a = i.from, o = i.to, u = i.l, s = i.r; At(n, a, o), u && r(n, u), s && r(n, s) } Bn(t) || r(e, t) } function xs(e, t) { var r = ln(t), n = r.next(); if (n.done) return !1; for (var i = n.value, a = ln(e), o = a.next(i.from), u = o.value; !n.done && !o.done;) { if (ce(u.from, i.to) <= 0 && ce(u.to, i.from) >= 0) return !0; ce(i.from, u.from) < 0 ? i = (n = r.next(u.from)).value : u = (o = a.next(i.from)).value } return !1 } function ln(e) { var t = Bn(e) ? null : { s: 0, n: e }; return { next: function (r) { for (var n = arguments.length > 0; t;)switch (t.s) { case 0: if (t.s = 1, n) for (; t.n.l && ce(r, t.n.from) < 0;)t = { up: t, n: t.n.l, s: 1 }; else for (; t.n.l;)t = { up: t, n: t.n.l, s: 1 }; case 1: if (t.s = 2, !n || ce(r, t.n.to) <= 0) return { value: t.n, done: !1 }; case 2: if (t.n.r) { t.s = 3, t = { up: t, n: t.n.r, s: 0 }; continue } case 3: t = t.up }return { done: !0 } } } } function ti(e) { var t, r, n = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((r = e.l) === null || r === void 0 ? void 0 : r.d) || 0), i = n > 1 ? "r" : n < -1 ? "l" : ""; if (i) { var a = i === "r" ? "l" : "r", o = B({}, e), u = e[i]; e.from = u.from, e.to = u.to, e[i] = u[i], o[i] = u[a], e[a] = o, o.d = ri(o) } e.d = ri(e) } function ri(e) { var t = e.r, r = e.l; return (t ? r ? Math.max(t.d, r.d) : t.d : r ? r.d : 0) + 1 } var Ds = { stack: "dbcore", level: 0, create: function (e) { var t = e.schema.name, r = new Ee(e.MIN_KEY, e.MAX_KEY); return B(B({}, e), { table: function (n) { var i = e.table(n), a = i.schema, o = a.primaryKey, u = o.extractKey, s = o.outbound, c = B(B({}, i), { mutate: function (p) { var m = p.trans, d = m.mutatedParts || (m.mutatedParts = {}), h = function (R) { var T = "idb://" + t + "/" + n + "/" + R; return d[T] || (d[T] = new Ee) }, b = h(""), v = h(":dels"), g = p.type, C = p.type === "deleteRange" ? [p.range] : p.type === "delete" ? [p.keys] : p.values.length < 50 ? [[], p.values] : [], _ = C[0], y = C[1], S = p.trans._cache; return i.mutate(p).then(function (R) { if (ae(_)) { g !== "delete" && (_ = R.results), b.addKeys(_); var T = sa(_, S); !T && g !== "add" && v.addKeys(_), (T || y) && ws(h, a, T, y) } else if (_) { var O = { from: _.lower, to: _.upper }; v.add(O), b.add(O) } else b.add(r), v.add(r), a.indexes.forEach(function (k) { return h(k.name).add(r) }); return R }) } }), l = function (p) { var m, d, h = p.query, b = h.index, v = h.range; return [b, new Ee((m = v.lower) !== null && m !== void 0 ? m : e.MIN_KEY, (d = v.upper) !== null && d !== void 0 ? d : e.MAX_KEY)] }, f = { get: function (p) { return [o, new Ee(p.key)] }, getMany: function (p) { return [o, new Ee().addKeys(p.keys)] }, count: l, query: l, openCursor: l }; return H(f).forEach(function (p) { c[p] = function (m) { var d = w.subscr; if (d) { var h = function (S) { var R = "idb://" + t + "/" + n + "/" + S; return d[R] || (d[R] = new Ee) }, b = h(""), v = h(":dels"), g = f[p](m), C = g[0], _ = g[1]; if (h(C.name || "").add(_), !C.isPrimaryKey) if (p === "count") v.add(r); else { var y = p === "query" && s && m.values && i.query(B(B({}, m), { values: !1 })); return i[p].apply(this, arguments).then(function (S) { if (p === "query") { if (s && m.values) return y.then(function (k) { var N = k.result; return b.addKeys(N), S }); var R = m.values ? S.result.map(u) : S.result; m.values ? b.addKeys(R) : v.addKeys(R) } else if (p === "openCursor") { var T = S, O = m.values; return T && Object.create(T, { key: { get: function () { return v.addKey(T.primaryKey), T.key } }, primaryKey: { get: function () { var k = T.primaryKey; return v.addKey(k), k } }, value: { get: function () { return O && b.addKey(T.primaryKey), T.value } } }) } return S }) } } return i[p].apply(this, arguments) } }), c } }) } }; function ws(e, t, r, n) { function i(a) { var o = e(a.name || ""); function u(c) { return c != null ? a.extractKey(c) : null } var s = function (c) { return a.multiEntry && ae(c) ? c.forEach(function (l) { return o.addKey(l) }) : o.addKey(c) }; (r || n).forEach(function (c, l) { var f = r && u(r[l]), p = n && u(n[l]); ce(f, p) !== 0 && (f != null && s(f), p != null && s(p)) }) } t.indexes.forEach(i) } var Fn = function () { function e(t, r) { var n = this; this._middlewares = {}, this.verno = 0; var i = e.dependencies; this._options = r = B({ addons: e.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange }, r), this._deps = { indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange }; var a = r.addons; this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this; var o = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: U, dbReadyPromise: null, cancelOpen: U, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 }; o.dbReadyPromise = new E(function (u) { o.dbReadyResolve = u }), o.openCanceller = new E(function (u, s) { o.cancelOpen = s }), this._state = o, this.name = t, this.on = Kt(this, "populate", "blocked", "versionchange", "close", { ready: [Pn, U] }), this.on.ready.subscribe = Ii(this.on.ready.subscribe, function (u) { return function (s, c) { e.vip(function () { var l = n._state; if (l.openComplete) l.dbOpenError || E.resolve().then(s), c && u(s); else if (l.onReadyBeingFired) l.onReadyBeingFired.push(s), c && u(s); else { u(s); var f = n; c || u(function p() { f.on.ready.unsubscribe(s), f.on.ready.unsubscribe(p) }) } }) } }), this.Collection = Jo(this), this.Table = Lo(this), this.Transaction = Zo(this), this.Version = ms(this), this.WhereClause = Xo(this), this.on("versionchange", function (u) { u.newVersion > 0 ? console.warn("Another connection wants to upgrade database '" + n.name + "'. Closing db now to resume the upgrade.") : console.warn("Another connection wants to delete database '" + n.name + "'. Closing db now to resume the delete request."), n.close() }), this.on("blocked", function (u) { !u.newVersion || u.newVersion < u.oldVersion ? console.warn("Dexie.delete('" + n.name + "') was blocked") : console.warn("Upgrade '" + n.name + "' blocked by other connection holding version " + u.oldVersion / 10) }), this._maxKey = Ot(r.IDBKeyRange), this._createTransaction = function (u, s, c, l) { return new n.Transaction(u, s, c, n._options.chromeTransactionDurability, l) }, this._fireOnBlocked = function (u) { n.on("blocked").fire(u), Tt.filter(function (s) { return s.name === n.name && s !== n && !s._state.vcFired }).map(function (s) { return s.on("versionchange").fire(u) }) }, this.use(Ts), this.use(Ps), this.use(Ds), this.use(Es), this.vip = Object.create(this, { _vip: { value: !0 } }), a.forEach(function (u) { return u(n) }) } return e.prototype.version = function (t) { if (isNaN(t) || t < .1) throw new I.Type("Given version is not a positive number"); if (t = Math.round(t * 10) / 10, this.idbdb || this._state.isBeingOpened) throw new I.Schema("Cannot add version when database is open"); this.verno = Math.max(this.verno, t); var r = this._versions, n = r.filter(function (i) { return i._cfg.version === t })[0]; return n || (n = new this.Version(t), r.push(n), r.sort(os), n.stores({}), this._state.autoSchema = !1, n) }, e.prototype._whenReady = function (t) { var r = this; return this.idbdb && (this._state.openComplete || w.letThrough || this._vip) ? t() : new E(function (n, i) { if (r._state.openComplete) return i(new I.DatabaseClosed(r._state.dbOpenError)); if (!r._state.isBeingOpened) { if (!r._options.autoOpen) { i(new I.DatabaseClosed); return } r.open().catch(U) } r._state.dbReadyPromise.then(n, i) }).then(t) }, e.prototype.use = function (t) { var r = t.stack, n = t.create, i = t.level, a = t.name; a && this.unuse({ stack: r, name: a }); var o = this._middlewares[r] || (this._middlewares[r] = []); return o.push({ stack: r, create: n, level: i == null ? 10 : i, name: a }), o.sort(function (u, s) { return u.level - s.level }), this }, e.prototype.unuse = function (t) { var r = t.stack, n = t.name, i = t.create; return r && this._middlewares[r] && (this._middlewares[r] = this._middlewares[r].filter(function (a) { return i ? a.create !== i : n ? a.name !== n : !1 })), this }, e.prototype.open = function () { return _s(this) }, e.prototype._close = function () { var t = this._state, r = Tt.indexOf(this); if (r >= 0 && Tt.splice(r, 1), this.idbdb) { try { this.idbdb.close() } catch { } this._novip.idbdb = null } t.dbReadyPromise = new E(function (n) { t.dbReadyResolve = n }), t.openCanceller = new E(function (n, i) { t.cancelOpen = i }) }, e.prototype.close = function () { this._close(); var t = this._state; this._options.autoOpen = !1, t.dbOpenError = new I.DatabaseClosed, t.isBeingOpened && t.cancelOpen(t.dbOpenError) }, e.prototype.delete = function () { var t = this, r = arguments.length > 0, n = this._state; return new E(function (i, a) { var o = function () { t.close(); var u = t._deps.indexedDB.deleteDatabase(t.name); u.onsuccess = G(function () { gs(t._deps, t.name), i() }), u.onerror = Se(a), u.onblocked = t._fireOnBlocked }; if (r) throw new I.InvalidArgument("Arguments not allowed in db.delete()"); n.isBeingOpened ? n.dbReadyPromise.then(o) : o() }) }, e.prototype.backendDB = function () { return this.idbdb }, e.prototype.isOpen = function () { return this.idbdb !== null }, e.prototype.hasBeenClosed = function () { var t = this._state.dbOpenError; return t && t.name === "DatabaseClosed" }, e.prototype.hasFailed = function () { return this._state.dbOpenError !== null }, e.prototype.dynamicallyOpened = function () { return this._state.autoSchema }, Object.defineProperty(e.prototype, "tables", { get: function () { var t = this; return H(this._allTables).map(function (r) { return t._allTables[r] }) }, enumerable: !1, configurable: !0 }), e.prototype.transaction = function () { var t = Cs.apply(this, arguments); return this._transaction.apply(this, t) }, e.prototype._transaction = function (t, r, n) { var i = this, a = w.trans; (!a || a.db !== this || t.indexOf("!") !== -1) && (a = null); var o = t.indexOf("?") !== -1; t = t.replace("!", "").replace("?", ""); var u, s; try { if (s = r.map(function (l) { var f = l instanceof i.Table ? l.name : l; if (typeof f != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed"); return f }), t == "r" || t === xr) u = xr; else if (t == "rw" || t == Dr) u = Dr; else throw new I.InvalidArgument("Invalid transaction mode: " + t); if (a) { if (a.mode === xr && u === Dr) if (o) a = null; else throw new I.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY"); a && s.forEach(function (l) { if (a && a.storeNames.indexOf(l) === -1) if (o) a = null; else throw new I.SubTransaction("Table " + l + " not included in parent transaction.") }), o && a && !a.active && (a = null) } } catch (l) { return a ? a._promise(null, function (f, p) { p(l) }) : q(l) } var c = oa.bind(null, this, u, s, a, n); return a ? a._promise(u, c, "lock") : w.trans ? pt(w.transless, function () { return i._whenReady(c) }) : this._whenReady(c) }, e.prototype.table = function (t) { if (!ye(this._allTables, t)) throw new I.InvalidTable("Table " + t + " does not exist"); return this._allTables[t] }, e }(), Os = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", As = function () { function e(t) { this._subscribe = t } return e.prototype.subscribe = function (t, r, n) { return this._subscribe(!t || typeof t == "function" ? { next: t, error: r, complete: n } : t) }, e.prototype[Os] = function () { return this }, e }(); function ca(e, t) { return H(t).forEach(function (r) { var n = e[r] || (e[r] = new Ee); vr(n, t[r]) }), e } function Is(e) { return new As(function (t) { var r = Sn(e); function n(m) { r && ft(); var d = function () { return Ue(e, { subscr: m, trans: null }) }, h = w.trans ? pt(w.transless, d) : d(); return r && h.then(Me, Me), h } var i = !1, a = {}, o = {}, u = { get closed() { return i }, unsubscribe: function () { i = !0, $e.storagemutated.unsubscribe(f) } }; t.start && t.start(u); var s = !1, c = !1; function l() { return H(o).some(function (m) { return a[m] && xs(a[m], o[m]) }) } var f = function (m) { ca(a, m), l() && p() }, p = function () { if (!(s || i)) { a = {}; var m = {}, d = n(m); c || ($e(wt, f), c = !0), s = !0, Promise.resolve(d).then(function (h) { s = !1, !i && (l() ? p() : (a = {}, o = m, t.next && t.next(h))) }, function (h) { s = !1, t.error && t.error(h), u.unsubscribe() }) } }; return p(), u }) } var fn; try { fn = { indexedDB: $.indexedDB || $.mozIndexedDB || $.webkitIndexedDB || $.msIndexedDB, IDBKeyRange: $.IDBKeyRange || $.webkitIDBKeyRange } } catch { fn = { indexedDB: null, IDBKeyRange: null } } var Ve = Fn; ct(Ve, B(B({}, Tr), { delete: function (e) { var t = new Ve(e, { addons: [] }); return t.delete() }, exists: function (e) { return new Ve(e, { addons: [] }).open().then(function (t) { return t.close(), !0 }).catch("NoSuchDatabaseError", function () { return !1 }) }, getDatabaseNames: function (e) { try { return vs(Ve.dependencies).then(e) } catch { return q(new I.MissingAPI) } }, defineClass: function () { function e(t) { ue(this, t) } return e }, ignoreTransaction: function (e) { return w.trans ? pt(w.transless, e) : e() }, vip: cn, async: function (e) { return function () { try { var t = un(e.apply(this, arguments)); return !t || typeof t.then != "function" ? E.resolve(t) : t } catch (r) { return q(r) } } }, spawn: function (e, t, r) { try { var n = un(e.apply(r, t || [])); return !n || typeof n.then != "function" ? E.resolve(n) : n } catch (i) { return q(i) } }, currentTransaction: { get: function () { return w.trans || null } }, waitFor: function (e, t) { var r = E.resolve(typeof e == "function" ? Ve.ignoreTransaction(e) : e).timeout(t || 6e4); return w.trans ? w.trans.waitFor(r) : r }, Promise: E, debug: { get: function () { return Te }, set: function (e) { Ni(e, e === "dexie" ? function () { return !0 } : Zi) } }, derive: ut, extend: ue, props: ct, override: Ii, Events: Kt, on: $e, liveQuery: Is, extendObservabilitySet: ca, getByKeyPath: Oe, setByKeyPath: Ce, delByKeyPath: lo, shallowClone: Bi, deepClone: Mt, getObjectDiff: jn, cmp: ce, asap: Mi, minKey: tn, addons: [], connections: Tt, errnames: kn, dependencies: fn, semVer: Wn, version: Wn.split(".").map(function (e) { return parseInt(e) }).reduce(function (e, t, r) { return e + t / Math.pow(10, r * 2) }) })); Ve.maxKey = Ot(Ve.dependencies.IDBKeyRange); typeof dispatchEvent < "u" && typeof addEventListener < "u" && ($e(wt, function (e) { if (!De) { var t; kr ? (t = document.createEvent("CustomEvent"), t.initCustomEvent(Le, !0, !0, e)) : t = new CustomEvent(Le, { detail: e }), De = !0, dispatchEvent(t), De = !1 } }), addEventListener(Le, function (e) { var t = e.detail; De || yr(t) })); function yr(e) { var t = De; try { De = !0, $e.storagemutated.fire(e) } finally { De = t } } var De = !1; if (typeof BroadcastChannel < "u") { var ni = new BroadcastChannel(Le); $e(wt, function (e) { De || ni.postMessage(e) }), ni.onmessage = function (e) { e.data && yr(e.data) } } else if (typeof self < "u" && typeof navigator < "u") { $e(wt, function (e) { try { De || (typeof localStorage < "u" && localStorage.setItem(Le, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && Ur([], self.clients.matchAll({ includeUncontrolled: !0 }), !0).forEach(function (t) { return t.postMessage({ type: Le, changedParts: e }) })) } catch { } }), typeof addEventListener < "u" && addEventListener("storage", function (e) { if (e.key === Le) { var t = JSON.parse(e.newValue); t && yr(t.changedParts) } }); var ii = self.document && navigator.serviceWorker; ii && ii.addEventListener("message", Ms) } function Ms(e) { var t = e.data; t && t.type === Le && yr(t.changedParts) } E.rejectionMapper = _o; Ni(Te, Zi); class js { constructor(t, r, n, i, a, o, u, s, c, l, f, p, m, d) { P(this, "id"); P(this, "brand"); P(this, "material"); P(this, "color"); P(this, "cost"); P(this, "currency"); P(this, "status"); P(this, "weightTotal"); P(this, "weightPrinted"); P(this, "density"); P(this, "diameter"); P(this, "dateBought"); P(this, "nozzleTemperature"); P(this, "bedTemperature"); P(this, "filamentDepletedCutoff"); this.id = t, this.brand = r, this.material = n, this.color = i, this.cost = a, this.currency = o, this.status = "loaded", this.weightTotal = u, this.weightPrinted = s, this.diameter = l, this.density = c, this.dateBought = f, this.nozzleTemperature = p, this.bedTemperature = m, this.filamentDepletedCutoff = d, this.weightTotal - this.weightPrinted < this.filamentDepletedCutoff && (this.status = "depleted") } get name() { return `${this.brand} ${this.material}` } get percentRemaining() { return Math.round((this.weightTotal - this.weightPrinted) / this.weightTotal * 100) } get percentPrinted() { return Math.round(this.weightPrinted / this.weightTotal * 100) } get weightRemaining() { return this.weightTotal - this.weightPrinted } get costPrinted() { return this.cost - this.percentRemaining * this.cost } get costRemaining() { return this.percentRemaining * this.cost } save(t) { j.filaments.update(this.id, t) } add() { j.filaments.add(this) } remove() { j.filaments.delete(this.id) } toString() { return `${this.brand} ${this.material} status: ${this.status}` } } class ua { constructor(t, r, n, i, a, o) { P(this, "id"); P(this, "fileName"); P(this, "parentDir"); P(this, "isWorkSpaceFile"); P(this, "type"); P(this, "uploaderName"); P(this, "fileContent"); this.id = t, this.fileName = r, this.parentDir = n, this.isWorkSpaceFile = i, this.uploaderName = a, this.type = o } save(t) { j.nanofactoryFiles.update(this.id, t) } add() { j.nanofactoryFiles.add(this) } remove() { j.nanofactoryFiles.delete(this.id) } } class la { constructor(t) { P(this, "id"); P(this, "peerID"); P(this, "apiKey"); this.id = t } async save(t) { await j.networking.update(this.id, t) } async add() { await j.networking.add(this) } remove() { j.networking.delete(this.id) } } var fa = (e => (e.AVAILABLE = "available", e.WHITELISTED = "whitelisted", e.BLACKLISTED = "blacklisted", e))(fa || {}); class pa { constructor() { P(this, "id"); P(this, "whitelisted"); P(this, "blacklisted"); P(this, "available"); this.id = "1", this.whitelisted = new Set([]), this.blacklisted = new Set([]), this.available = new Set([]) } async save(t) { await j.nanofactoryPeers.update(this.id, t) } async add() { await j.nanofactoryPeers.add(this) } remove() { j.nanofactoryPeers.delete(this.id) } async addToList(t, r) { this[t].add(r), t === "whitelisted" && this.available.add(r), await j.nanofactoryPeers.put(this, this.id) } async removeFromList(t, r) { console.log("remove from list called"), console.log(this[t].size), this[t].delete(r), console.log(this[t].size), await j.nanofactoryPeers.put(this, this.id) } } var nt = (e => (e.operational = "Operational", e.offline = "Offline", e.printing = "Printing", e.error = "Error", e.paused = "Paused", e))(nt || {}); class da { constructor(t) { P(this, "id"); P(this, "name"); P(this, "color"); P(this, "model"); P(this, "volume"); P(this, "heatedBed"); P(this, "heatedChamber"); P(this, "axes"); P(this, "extruder"); P(this, "state"); P(this, "bedLevellingGraph"); P(this, "position"); P(this, "connectionOptions"); P(this, "temperatureHistory"); P(this, "filamentID"); P(this, "isQueuePaused"); P(this, "queuePausedReason"); P(this, "nanofactoryInstallDate"); this.id = t, this.name = "", this.model = "", this.volume = { formFactor: "rectangular", centerOrigin: "center", width: 0, depth: 0, height: 0 }, this.heatedBed = !0, this.heatedChamber = !1, this.nanofactoryInstallDate = new Date, this.state = { status: "Offline" }, this.connectionOptions = { ports: [], baudrates: [], printerProfiles: [], portPreference: "auto", baudratePreference: "auto", printerProfilePreference: "_default", autoconnect: !1 }, this.temperatureHistory = [], this.axes = { x: { inverted: !1, speed: 0 }, y: { inverted: !1, speed: 0 }, z: { inverted: !1, speed: 0 }, e: { inverted: !1, speed: 0 } }, this.extruder = { count: 1, offsets: [] }, this.position = { x: 0, y: 0, z: 0, e: 0, relative: !1, speed: 0 }, this.filamentID = "", this.isQueuePaused = !0, this.queuePausedReason = "Printer has not been assigned a job" } async save(t) { await j.printer.update(this.id, t) } async add() { await j.printer.add(this) } remove() { j.printer.delete(this.id) } toString() { return `${this.model} ${this.name} status: ${this.state.status}` } } var gr = (e => (e.TOPRINT = "To Print", e.PRINTING = "Printing", e.DONE = "Done", e.FAILED = "Failed", e.CANCELLED = "Cancelled", e))(gr || {}); class ha { constructor(t, r, n, i, a, o, u, s, c, l) { P(this, "id"); P(this, "printerID"); P(this, "jobName"); P(this, "status"); P(this, "assignerName"); P(this, "estimatedPrintTime"); P(this, "lastPrintTime"); P(this, "estimatedFilamentUsage"); P(this, "actualFilamentUsage"); P(this, "progress"); P(this, "createdDate"); P(this, "startTime"); P(this, "endTime"); P(this, "queuePosition"); P(this, "file"); P(this, "filamentID"); this.id = t, this.printerID = r, this.jobName = n, this.status = "To Print", this.assignerName = i, this.estimatedPrintTime = a != null ? a : 0, this.estimatedFilamentUsage = o != null ? o : { length: 0, volume: 0 }, this.actualFilamentUsage = { length: 0, volume: 0 }, this.createdDate = u != null ? u : new Date, this.progress = { completion: 0, filePosition: 0, printTime: 0, printTimeLeft: 0 }, this.queuePosition = s, this.file = c, this.filamentID = l } async calculatePosition() { let t = 0, r = await j.printJobs.reverse().sortBy("queuePosition"); r.length > 0 && (t = r[0].queuePosition), this.queuePosition = t + 1 } async add() { await this.calculatePosition(), j.printJobs.add(this) } remove() { j.printJobs.delete(this.id) } save(t) { j.printJobs.update(this.id, t) } async getEstimatedFilamentWeight() { let t = await j.filaments.get(this.filamentID); return t ? t.density * this.estimatedFilamentUsage.volume : 0 } async getUsedFilamentWeight() { let t = await j.filaments.get(this.filamentID); return t ? t.density * this.actualFilamentUsage.volume : 0 } toString() { return `${this.jobName}` } } class Bs extends Fn { constructor() { super("NanofactoryDatabase"); P(this, "printer"); P(this, "networking"); P(this, "printJobs"); P(this, "filaments"); P(this, "nanofactoryFiles"); P(this, "nanofactoryPeers"); this.version(1.1).stores({ printer: "id", networking: "id, peerID, apiKey", printJobs: "id,filamentID", filaments: "id", nanofactoryFiles: "id, filename", nanofactoryPeers: "id, available, whitelisted, blacklisted" }), this.version(1).stores({ printer: "id", networking: "id, peerID, apiKey", printJobs: "id,filamentID", filaments: "id", nanofactoryFiles: "id, filename" }), this.printer.mapToClass(da), this.networking.mapToClass(la), this.printJobs.mapToClass(ha), this.filaments.mapToClass(js), this.nanofactoryFiles.mapToClass(ua), this.nanofactoryPeers.mapToClass(pa) } } let j; async function Fs() { j = new Bs, j.open() } async function Ks() { try { let t = await fetch("http://localhost:5000/api/printer?history=true&limit=" + 50, { method: "GET", headers: { "X-API-KEY": V.apiKey } }); return t.ok ? await t.json() : { state: { text: "Offline" } } } catch { return { state: { text: "Offline" } } } } let be = ""; async function Ns(e, t, r, n, i) { switch (r) { case D.jobCreated: let a = new ua(n.file.id, n.file.fileName, n.file.parentDir, n.file.isWorkspaceFile, n.file.uploaderName, n.file.type); a.fileContent = new Blob([i], { type: "text/plain;charset=utf-8" }); let o = new ha(n.id, n.printerID, n.jobName, n.assignerName, n.estimatedPrintTime, n.estimatedFilamentUsage, n.createdDate, n.queuePosition, a, n.filamentID); a.add(), o.add(), await OctoPrint.files.upload("local", new File([a.fileContent], n.jobName + ".gcode")), (await j.printer.toArray())[0].state.status === nt.operational && (be = n.id, o.save({ startTime: new Date().toISOString(), status: gr.PRINTING }), OctoPrint.files.select("local", n.jobName + ".gcode", !0)); break; case D.currentJobUpdatesRequest: Ls(t); break; case D.currentJobUpdatesStop: at[t].close(); break; case D.jobCancelled: let u = await j.printJobs.get(e.id); u && (be == u.id && OctoPrint.job.cancel(), u.save({ status: gr.CANCELLED })); break; case D.jobDeleted: let s = await j.printJobs.get(e.id); s && s.remove(); break; case D.jobRankChange: let c = await j.printJobs.get(e.id); c && c.save({ queuePosition: e.queuePosition }); break; case D.jobPause: OctoPrint.job.pause(); break; case D.jobResume: OctoPrint.job.resume(); break } } function Ls(e) { const t = { label: D.currentJobUpdatesResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("jobProgress connection is open " + e), at[e] = r }), r.on("close", function () { delete at[e] }), r.on("error", function () { delete at[e] }) } function Us() { be = "" } async function zs(e, t, r, n) { switch (r) { case D.connectPrinter: Hs(e.port, e.baudrate, e.autoconnect, e.save); break; case D.disconnectPrinter: OctoPrint.connection.disconnect(); break; case D.executeCustomGcode: OctoPrint.control.sendGcode(e.data); break; case D.temperatureStreamRequest: Vs(t); break; case D.temperatureStreamStop: Ae[t].close(); break; case D.filamentExtrude: OctoPrint.printer.extrude(e.data); break; case D.home: OctoPrint.printer.home(e.axes); break; case D.terminalRequest: qs(t); break; case D.terminalStop: ot[t].close(); break; case D.targetBed: OctoPrint.printer.setBedTargetTemperature(e.data); break; case D.targetTool: OctoPrint.printer.setToolTargetTemperatures({ tool0: e.data }); break; case D.positionChanged: Ws(e); break; case D.positionChangedRequest: Ys(t); break; case D.positionChangedStop: st[t].close(); break } } async function $s() { let e = await OctoPrint.printerprofiles.get("_default"); e.id = de.id, delete e.default, delete e.current, delete e.resource, await ne.save(e) } async function Gs() { await ne.save({ connectionOptions: (await OctoPrint.connection.getSettings()).options }) } async function Js() { let e = await Ks(), t = await j.printer.get(V.peerID), r = { state: { status: ma(e.state.text) } }; if ("temperature" in e && (r.temperatureHistory = e.temperature.history, Object.keys(Ae).length > 0)) { let n = r.temperatureHistory.filter(({ time: i }) => !(t != null && t.temperatureHistory.some(({ time: a }) => a === i))); if (n) for (let i in Ae) Ae[i].send(JSON.stringify({ data: n })) } r.state.status !== (t == null ? void 0 : t.state.status) && Yt(r.state, D.printerStateChanged), await ne.save(r) } function ma(e) { return e.includes("Operational") ? nt.operational : e.includes("Printing") ? nt.printing : e.includes("Paused") ? nt.paused : nt.offline } function Vs(e) { const t = { label: D.temperatureStreamResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("temperatureStream connection is open " + e), Ae[e] = r }), r.on("close", function () { delete Ae[e] }), r.on("error", function () { delete Ae[e] }) } async function Hs(e, t, r, n) { let i = { save: n, autoconnect: r }; e.toLowerCase().includes("auto") || (i.port = e), t.toLowerCase().includes("auto") || (i.baudrate = parseInt(t)), OctoPrint.connection.connect(i) } function qs(e) { const t = { label: D.terminalResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("terminalConnection is open " + e), ot[e] = r }), r.on("close", function () { delete ot[e] }), r.on("error", function () { delete ot[e] }) } function Ws(e) { console.log(e); let t = { x: e.x, y: e.y, z: e.z, absolute: !e.relative }; OctoPrint.printer.jog(t) } function Ys(e) { const t = { label: D.positionChangedResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("positionChangedConnection is open " + e), st[e] = r }), r.on("close", function () { delete st[e] }), r.on("error", function () { delete st[e] }) } const Xs = ".*G90.*", Qs = ".*G91.*", Zs = ".*M82.*", ec = ".*M83.*", ai = "E-?d+.?d+", Mr = "X[-0-9]+", jr = "Y[-0-9]+", Br = "Z[0-9]+", tc = "Recv: X:[0-9]+.[0-9]{2} Y:[0-9]+.[0-9]{2} Z:[0-9]+.[0-9]{2} E:0.00 Count X:[0-9]+ Y:[0-9]+ Z:[0-9]+"; let Fr = !1, Kr = !1, oi = !1, ht = !0; function rc(e) { let t = !1; e.forEach(r => { if (r.includes("G28 X0 Y0") && (Fr = !0, Kr = !0), (r.includes("G28 Z0") || r.replace("Send:", "").trim() === "G28") && (Fr = !0, Kr = !0, oi = !0), (Fr || Kr || oi) && r.match(tc), r.match(Xs) ? ht = !0 : r.match(Qs) && (ht = !1), r.match(Zs) || r.match(ec), (r.includes("G0") || r.includes("G1")) && (r.match(Mr) && (ne.position.x = ht ? parseFloat(r.match(Mr)[0].substring(1)) : ne.position.x + parseFloat(r.match(Mr)[0].substring(1)), t = !0), r.match(jr) && (ne.position.y = ht ? parseFloat(r.match(jr)[0].substring(1)) : ne.position.y + parseFloat(r.match(jr)[0].substring(1)), t = !0), r.match(Br) && (ne.position.z = ht ? parseFloat(r.match(Br)[0].substring(1)) : ne.position.z + parseFloat(r.match(Br)[0].substring(1)), t = !0), r.match(ai) && parseFloat(r.match(ai)[0].substring(1)), t)) { ne.save({ position: ne.position }); for (let n in st) st[n].send(JSON.stringify(ne.position)) } }) } async function nc(e) { const t = { label: D.cameraStreamResponse, metadata: e, serialization: "binary", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("cameraStream connection is open " + e), cr[e] = r }), r.on("close", function () { delete cr[e] }), r.on("error", function () { delete cr[e] }) } var rt = (e => (e.CONNECTED = "connected", e.CURRENT = "current", e.HISTORY = "history", e.REAUTHREQUIRED = "reauthRequired", e.EVENT = "event", e))(rt || {}), nr = (e => (e.PRINTERSTATECHANGED = "PrinterStateChanged", e.PRINTSTARTED = "PrintStarted", e.PRINTDONE = "PrintDone", e))(nr || {}); const ic = [D.jobCreated, D.actionCreated, D.actionModified]; function ac(e, t, r, n) { let i = ""; switch (ic.includes(r) ? i = new TextDecoder("utf-8").decode(e) : e = JSON.parse(e), n = JSON.parse(n), r) { case D.syncAllRequest: oc(t); break; case D.connectPrinter: case D.disconnectPrinter: case D.executeCustomGcode: case D.temperatureStreamRequest: case D.temperatureStreamStop: case D.filamentExtrude: case D.home: case D.terminalRequest: case D.terminalStop: case D.targetBed: case D.targetTool: case D.positionChanged: case D.positionChangedRequest: case D.positionChangedStop: zs(e, t, r); break; case D.jobCreated: case D.currentJobUpdatesRequest: case D.currentJobUpdatesStop: case D.jobCancelled: case D.jobDeleted: case D.jobRankChange: case D.jobPause: case D.jobResume: Ns(e, t, r, n, i); break; case D.handshakeRequest: sc(t); break; case D.cameraStreamRequest: nc(t); break; case D.cameraStreamStop: cr[t].close(); break; default: console.log("Unhandled label: " + r); break } } async function oc(e) { let t = { printer_profile: {}, current_position: { x: 0, y: 0, z: 0, e: 0, speed: 0, relative: !1 }, bed_levelling_data: [], queue_state: { isQueuePaused: !1, queuePausedReason: "testing" }, current_job: { id: "" }, print_queue: [], jobs_history: [], current_filament: { current_filament: {} }, scripts: {} }; t.printer_profile = (await j.printer.toArray())[0], _n(e, t, D.syncAllResponse), Cr.addToList(fa.AVAILABLE, e) } async function sc(e) { _n(e, { status: (await j.printer.toArray())[0].state.status }, D.handshakeResponse) } async function cc(e) { var t, r; switch (e.event) { case rt.CONNECTED: case rt.REAUTHREQUIRED: OctoPrint.browser.passiveLogin().done(function (i) { OctoPrint.socket.sendAuth(i.name, i.session) }); break; case rt.HISTORY: console.log(e); break; case rt.CURRENT: let n = await j.printer.get(V.peerID); if (be && "job" in e.data && console.log(e), be && "progress" in e.data) { let i = { data: { id: be, progress: { completion: parseFloat(e.data.progress.completion).toFixed(1) }, estimatedFilamentUsage: (r = (t = e.data.job.filament) == null ? void 0 : t.tool0) != null ? r : { length: 0, volume: 0 }, actualFilamentUsage: { length: 0, volume: 0 } } }; if (i.data.progress.completion) for (let a in at) at[a].send(JSON.stringify(i)) } if ("temps" in e.data && e.data.temps.length > 0) { for (let i in Ae) Ae[i].send(JSON.stringify({ data: e.data.temps })); for (e.data.temps.forEach(i => { n == null || n.temperatureHistory.push(i) }); (n == null ? void 0 : n.temperatureHistory.length) > 50;)n == null || n.temperatureHistory.shift(); n == null || n.save({ temperatureHistory: n.temperatureHistory }) } if ("logs" in e.data) { for (let i in ot) ot[i].send(JSON.stringify(e.data.logs)); rc(e.data.logs) } break; case rt.EVENT: console.log(e), uc(e); break; default: console.log("Unhandled socketEventType: ", e) } } async function uc(e) { let t = await j.printer.get(V.peerID); switch (e.data.type) { case nr.PRINTERSTATECHANGED: let r = { status: ma(e.data.payload.state_string) }; t == null || t.save({ state: r }), Yt(r, D.printerStateChanged); break; case nr.PRINTSTARTED: be && Yt({ data: { id: be, startTime: new Date().toISOString() } }, D.jobPrinting); break; case nr.PRINTDONE: if (be) { Yt({ data: { id: be, endTime: new Date().toISOString() } }, D.jobDone); let n = await j.printJobs.get(be); n && n.save({ endTime: new Date().toISOString(), status: gr.DONE }), Us() } break } } var Kn = { exports: {} }; (function (e) { var t = {}; t.useBlobBuilder = function () { try { return new Blob([]), !1 } catch { return !0 } }(), t.useArrayBufferView = !t.useBlobBuilder && function () { try { return new Blob([new Uint8Array([])]).size === 0 } catch { return !0 } }(), e.exports.binaryFeatures = t; var r = e.exports.BlobBuilder; typeof window < "u" && (r = e.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder); function n() { this._pieces = [], this._parts = [] } n.prototype.append = function (i) { typeof i == "number" ? this._pieces.push(i) : (this.flush(), this._parts.push(i)) }, n.prototype.flush = function () { if (this._pieces.length > 0) { var i = new Uint8Array(this._pieces); t.useArrayBufferView || (i = i.buffer), this._parts.push(i), this._pieces = [] } }, n.prototype.getBuffer = function () { if (this.flush(), t.useBlobBuilder) { for (var i = new r, a = 0, o = this._parts.length; a < o; a++)i.append(this._parts[a]); return i.getBlob() } else return new Blob(this._parts) }, e.exports.BufferBuilder = n })(Kn); var lc = Kn.exports.BufferBuilder, si = Kn.exports.binaryFeatures, fc = { unpack: function (e) { var t = new Z(e); return t.unpack() }, pack: function (e) { var t = new ee; t.pack(e); var r = t.getBuffer(); return r } }, ci = fc; function Z(e) { this.index = 0, this.dataBuffer = e, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength } Z.prototype.unpack = function () { var e = this.unpack_uint8(); if (e < 128) return e; if ((e ^ 224) < 32) return (e ^ 224) - 32; var t; if ((t = e ^ 160) <= 15) return this.unpack_raw(t); if ((t = e ^ 176) <= 15) return this.unpack_string(t); if ((t = e ^ 144) <= 15) return this.unpack_array(t); if ((t = e ^ 128) <= 15) return this.unpack_map(t); switch (e) { case 192: return null; case 193: return; case 194: return !1; case 195: return !0; case 202: return this.unpack_float(); case 203: return this.unpack_double(); case 204: return this.unpack_uint8(); case 205: return this.unpack_uint16(); case 206: return this.unpack_uint32(); case 207: return this.unpack_uint64(); case 208: return this.unpack_int8(); case 209: return this.unpack_int16(); case 210: return this.unpack_int32(); case 211: return this.unpack_int64(); case 212: return; case 213: return; case 214: return; case 215: return; case 216: return t = this.unpack_uint16(), this.unpack_string(t); case 217: return t = this.unpack_uint32(), this.unpack_string(t); case 218: return t = this.unpack_uint16(), this.unpack_raw(t); case 219: return t = this.unpack_uint32(), this.unpack_raw(t); case 220: return t = this.unpack_uint16(), this.unpack_array(t); case 221: return t = this.unpack_uint32(), this.unpack_array(t); case 222: return t = this.unpack_uint16(), this.unpack_map(t); case 223: return t = this.unpack_uint32(), this.unpack_map(t) } }; Z.prototype.unpack_uint8 = function () { var e = this.dataView[this.index] & 255; return this.index++, e }; Z.prototype.unpack_uint16 = function () { var e = this.read(2), t = (e[0] & 255) * 256 + (e[1] & 255); return this.index += 2, t }; Z.prototype.unpack_uint32 = function () { var e = this.read(4), t = ((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]; return this.index += 4, t }; Z.prototype.unpack_uint64 = function () { var e = this.read(8), t = ((((((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]) * 256 + e[4]) * 256 + e[5]) * 256 + e[6]) * 256 + e[7]; return this.index += 8, t }; Z.prototype.unpack_int8 = function () { var e = this.unpack_uint8(); return e < 128 ? e : e - (1 << 8) }; Z.prototype.unpack_int16 = function () { var e = this.unpack_uint16(); return e < 32768 ? e : e - (1 << 16) }; Z.prototype.unpack_int32 = function () { var e = this.unpack_uint32(); return e < Math.pow(2, 31) ? e : e - Math.pow(2, 32) }; Z.prototype.unpack_int64 = function () { var e = this.unpack_uint64(); return e < Math.pow(2, 63) ? e : e - Math.pow(2, 64) }; Z.prototype.unpack_raw = function (e) { if (this.length < this.index + e) throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + e + " " + this.length); var t = this.dataBuffer.slice(this.index, this.index + e); return this.index += e, t }; Z.prototype.unpack_string = function (e) { for (var t = this.read(e), r = 0, n = "", i, a; r < e;)i = t[r], i < 128 ? (n += String.fromCharCode(i), r++) : (i ^ 192) < 32 ? (a = (i ^ 192) << 6 | t[r + 1] & 63, n += String.fromCharCode(a), r += 2) : (a = (i & 15) << 12 | (t[r + 1] & 63) << 6 | t[r + 2] & 63, n += String.fromCharCode(a), r += 3); return this.index += e, n }; Z.prototype.unpack_array = function (e) { for (var t = new Array(e), r = 0; r < e; r++)t[r] = this.unpack(); return t }; Z.prototype.unpack_map = function (e) { for (var t = {}, r = 0; r < e; r++) { var n = this.unpack(), i = this.unpack(); t[n] = i } return t }; Z.prototype.unpack_float = function () { var e = this.unpack_uint32(), t = e >> 31, r = (e >> 23 & 255) - 127, n = e & 8388607 | 8388608; return (t === 0 ? 1 : -1) * n * Math.pow(2, r - 23) }; Z.prototype.unpack_double = function () { var e = this.unpack_uint32(), t = this.unpack_uint32(), r = e >> 31, n = (e >> 20 & 2047) - 1023, i = e & 1048575 | 1048576, a = i * Math.pow(2, n - 20) + t * Math.pow(2, n - 52); return (r === 0 ? 1 : -1) * a }; Z.prototype.read = function (e) { var t = this.index; if (t + e <= this.length) return this.dataView.subarray(t, t + e); throw new Error("BinaryPackFailure: read index out of range") }; function ee() { this.bufferBuilder = new lc } ee.prototype.getBuffer = function () { return this.bufferBuilder.getBuffer() }; ee.prototype.pack = function (e) { var t = typeof e; if (t === "string") this.pack_string(e); else if (t === "number") Math.floor(e) === e ? this.pack_integer(e) : this.pack_double(e); else if (t === "boolean") e === !0 ? this.bufferBuilder.append(195) : e === !1 && this.bufferBuilder.append(194); else if (t === "undefined") this.bufferBuilder.append(192); else if (t === "object") if (e === null) this.bufferBuilder.append(192); else { var r = e.constructor; if (r == Array) this.pack_array(e); else if (r == Blob || r == File || e instanceof Blob || e instanceof File) this.pack_bin(e); else if (r == ArrayBuffer) si.useArrayBufferView ? this.pack_bin(new Uint8Array(e)) : this.pack_bin(e); else if ("BYTES_PER_ELEMENT" in e) si.useArrayBufferView ? this.pack_bin(new Uint8Array(e.buffer)) : this.pack_bin(e.buffer); else if (r == Object || r.toString().startsWith("class")) this.pack_object(e); else if (r == Date) this.pack_string(e.toString()); else if (typeof e.toBinaryPack == "function") this.bufferBuilder.append(e.toBinaryPack()); else throw new Error('Type "' + r.toString() + '" not yet supported') } else throw new Error('Type "' + t + '" not yet supported'); this.bufferBuilder.flush() }; ee.prototype.pack_bin = function (e) { var t = e.length || e.byteLength || e.size; if (t <= 15) this.pack_uint8(160 + t); else if (t <= 65535) this.bufferBuilder.append(218), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(219), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; ee.prototype.pack_string = function (e) { var t = dc(e); if (t <= 15) this.pack_uint8(176 + t); else if (t <= 65535) this.bufferBuilder.append(216), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(217), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; ee.prototype.pack_array = function (e) { var t = e.length; if (t <= 15) this.pack_uint8(144 + t); else if (t <= 65535) this.bufferBuilder.append(220), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(221), this.pack_uint32(t); else throw new Error("Invalid length"); for (var r = 0; r < t; r++)this.pack(e[r]) }; ee.prototype.pack_integer = function (e) { if (e >= -32 && e <= 127) this.bufferBuilder.append(e & 255); else if (e >= 0 && e <= 255) this.bufferBuilder.append(204), this.pack_uint8(e); else if (e >= -128 && e <= 127) this.bufferBuilder.append(208), this.pack_int8(e); else if (e >= 0 && e <= 65535) this.bufferBuilder.append(205), this.pack_uint16(e); else if (e >= -32768 && e <= 32767) this.bufferBuilder.append(209), this.pack_int16(e); else if (e >= 0 && e <= 4294967295) this.bufferBuilder.append(206), this.pack_uint32(e); else if (e >= -2147483648 && e <= 2147483647) this.bufferBuilder.append(210), this.pack_int32(e); else if (e >= -9223372036854776e3 && e <= 9223372036854776e3) this.bufferBuilder.append(211), this.pack_int64(e); else if (e >= 0 && e <= 18446744073709552e3) this.bufferBuilder.append(207), this.pack_uint64(e); else throw new Error("Invalid integer") }; ee.prototype.pack_double = function (e) { var t = 0; e < 0 && (t = 1, e = -e); var r = Math.floor(Math.log(e) / Math.LN2), n = e / Math.pow(2, r) - 1, i = Math.floor(n * Math.pow(2, 52)), a = Math.pow(2, 32), o = t << 31 | r + 1023 << 20 | i / a & 1048575, u = i % a; this.bufferBuilder.append(203), this.pack_int32(o), this.pack_int32(u) }; ee.prototype.pack_object = function (e) { var t = Object.keys(e), r = t.length; if (r <= 15) this.pack_uint8(128 + r); else if (r <= 65535) this.bufferBuilder.append(222), this.pack_uint16(r); else if (r <= 4294967295) this.bufferBuilder.append(223), this.pack_uint32(r); else throw new Error("Invalid length"); for (var n in e) e.hasOwnProperty(n) && (this.pack(n), this.pack(e[n])) }; ee.prototype.pack_uint8 = function (e) { this.bufferBuilder.append(e) }; ee.prototype.pack_uint16 = function (e) { this.bufferBuilder.append(e >> 8), this.bufferBuilder.append(e & 255) }; ee.prototype.pack_uint32 = function (e) { var t = e & 4294967295; this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255) }; ee.prototype.pack_uint64 = function (e) { var t = e / Math.pow(2, 32), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; ee.prototype.pack_int8 = function (e) { this.bufferBuilder.append(e & 255) }; ee.prototype.pack_int16 = function (e) { this.bufferBuilder.append((e & 65280) >> 8), this.bufferBuilder.append(e & 255) }; ee.prototype.pack_int32 = function (e) { this.bufferBuilder.append(e >>> 24 & 255), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255) }; ee.prototype.pack_int64 = function (e) { var t = Math.floor(e / Math.pow(2, 32)), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; function pc(e) { var t = e.charCodeAt(0); return t <= 2047 ? "00" : t <= 65535 ? "000" : t <= 2097151 ? "0000" : t <= 67108863 ? "00000" : "000000" } function dc(e) { return e.length > 600 ? new Blob([e]).size : e.replace(/[^\u0000-\u007F]/g, pc).length } let va = !0, ya = !0; function bt(e, t, r) { const n = e.match(t); return n && n.length >= r && parseInt(n[r], 10) } function dt(e, t, r) { if (!e.RTCPeerConnection) return; const n = e.RTCPeerConnection.prototype, i = n.addEventListener; n.addEventListener = function (o, u) { if (o !== t) return i.apply(this, arguments); const s = c => { const l = r(c); l && (u.handleEvent ? u.handleEvent(l) : u(l)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(u, s), i.apply(this, [o, s]) }; const a = n.removeEventListener; n.removeEventListener = function (o, u) { if (o !== t || !this._eventMap || !this._eventMap[t]) return a.apply(this, arguments); if (!this._eventMap[t].has(u)) return a.apply(this, arguments); const s = this._eventMap[t].get(u); return this._eventMap[t].delete(u), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, a.apply(this, [o, s]) }, Object.defineProperty(n, "on" + t, { get() { return this["_on" + t] }, set(o) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), o && this.addEventListener(t, this["_on" + t] = o) }, enumerable: !0, configurable: !0 }) } function hc(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (va = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function mc(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (ya = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function Nn() { if (typeof window == "object") { if (va) return; typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments) } } function Rr(e, t) { !ya || console.warn(e + " is deprecated, please use " + t + " instead.") } function vc(e) { const t = { browser: null, version: null }; if (typeof e > "u" || !e.navigator) return t.browser = "Not a browser.", t; const { navigator: r } = e; if (r.mozGetUserMedia) t.browser = "firefox", t.version = bt(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || e.isSecureContext === !1 && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = bt(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (r.mediaDevices && r.userAgent.match(/Edge\/(\d+).(\d+)$/)) t.browser = "edge", t.version = bt(r.userAgent, /Edge\/(\d+).(\d+)$/, 2); else if (e.RTCPeerConnection && r.userAgent.match(/AppleWebKit\/(\d+)\./)) t.browser = "safari", t.version = bt(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype; else return t.browser = "Not a supported browser.", t; return t } function ui(e) { return Object.prototype.toString.call(e) === "[object Object]" } function ga(e) { return ui(e) ? Object.keys(e).reduce(function (t, r) { const n = ui(e[r]), i = n ? ga(e[r]) : e[r], a = n && !Object.keys(i).length; return i === void 0 || a ? t : Object.assign(t, { [r]: i }) }, {}) : e } function pn(e, t, r) { !t || r.has(t.id) || (r.set(t.id, t), Object.keys(t).forEach(n => { n.endsWith("Id") ? pn(e, e.get(t[n]), r) : n.endsWith("Ids") && t[n].forEach(i => { pn(e, e.get(i), r) }) })) } function li(e, t, r) { const n = r ? "outbound-rtp" : "inbound-rtp", i = new Map; if (t === null) return i; const a = []; return e.forEach(o => { o.type === "track" && o.trackIdentifier === t.id && a.push(o) }), a.forEach(o => { e.forEach(u => { u.type === n && u.trackId === o.id && pn(e, u, i) }) }), i } const fi = Nn; function ba(e, t) { const r = e && e.navigator; if (!r.mediaDevices) return; const n = function (u) { if (typeof u != "object" || u.mandatory || u.optional) return u; const s = {}; return Object.keys(u).forEach(c => { if (c === "require" || c === "advanced" || c === "mediaSource") return; const l = typeof u[c] == "object" ? u[c] : { ideal: u[c] }; l.exact !== void 0 && typeof l.exact == "number" && (l.min = l.max = l.exact); const f = function (p, m) { return p ? p + m.charAt(0).toUpperCase() + m.slice(1) : m === "deviceId" ? "sourceId" : m }; if (l.ideal !== void 0) { s.optional = s.optional || []; let p = {}; typeof l.ideal == "number" ? (p[f("min", c)] = l.ideal, s.optional.push(p), p = {}, p[f("max", c)] = l.ideal, s.optional.push(p)) : (p[f("", c)] = l.ideal, s.optional.push(p)) } l.exact !== void 0 && typeof l.exact != "number" ? (s.mandatory = s.mandatory || {}, s.mandatory[f("", c)] = l.exact) : ["min", "max"].forEach(p => { l[p] !== void 0 && (s.mandatory = s.mandatory || {}, s.mandatory[f(p, c)] = l[p]) }) }), u.advanced && (s.optional = (s.optional || []).concat(u.advanced)), s }, i = function (u, s) { if (t.version >= 61) return s(u); if (u = JSON.parse(JSON.stringify(u)), u && typeof u.audio == "object") { const c = function (l, f, p) { f in l && !(p in l) && (l[p] = l[f], delete l[f]) }; u = JSON.parse(JSON.stringify(u)), c(u.audio, "autoGainControl", "googAutoGainControl"), c(u.audio, "noiseSuppression", "googNoiseSuppression"), u.audio = n(u.audio) } if (u && typeof u.video == "object") { let c = u.video.facingMode; c = c && (typeof c == "object" ? c : { ideal: c }); const l = t.version < 66; if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && !(r.mediaDevices.getSupportedConstraints && r.mediaDevices.getSupportedConstraints().facingMode && !l)) { delete u.video.facingMode; let f; if (c.exact === "environment" || c.ideal === "environment" ? f = ["back", "rear"] : (c.exact === "user" || c.ideal === "user") && (f = ["front"]), f) return r.mediaDevices.enumerateDevices().then(p => { p = p.filter(d => d.kind === "videoinput"); let m = p.find(d => f.some(h => d.label.toLowerCase().includes(h))); return !m && p.length && f.includes("back") && (m = p[p.length - 1]), m && (u.video.deviceId = c.exact ? { exact: m.deviceId } : { ideal: m.deviceId }), u.video = n(u.video), fi("chrome: " + JSON.stringify(u)), s(u) }) } u.video = n(u.video) } return fi("chrome: " + JSON.stringify(u)), s(u) }, a = function (u) { return t.version >= 64 ? u : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[u.name] || u.name, message: u.message, constraint: u.constraint || u.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }, o = function (u, s, c) { i(u, l => { r.webkitGetUserMedia(l, s, f => { c && c(a(f)) }) }) }; if (r.getUserMedia = o.bind(r), r.mediaDevices.getUserMedia) { const u = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = function (s) { return i(s, c => u(c).then(l => { if (c.audio && !l.getAudioTracks().length || c.video && !l.getVideoTracks().length) throw l.getTracks().forEach(f => { f.stop() }), new DOMException("", "NotFoundError"); return l }, l => Promise.reject(a(l)))) } } } function yc(e, t) { if (!(e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices) && !!e.navigator.mediaDevices) { if (typeof t != "function") { console.error("shimGetDisplayMedia: getSourceId argument is not a function"); return } e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then(i => { const a = n.video && n.video.width, o = n.video && n.video.height, u = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: i, maxFrameRate: u || 3 } }, a && (n.video.mandatory.maxWidth = a), o && (n.video.mandatory.maxHeight = o), e.navigator.mediaDevices.getUserMedia(n) }) } } } function _a(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function Ca(e) { if (typeof e == "object" && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(r) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = r) }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = n => { n.stream.addEventListener("addtrack", i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.track.id) : a = { track: i.track }; const o = new Event("track"); o.track = i.track, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }), n.stream.getTracks().forEach(i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.id) : a = { track: i }; const o = new Event("track"); o.track = i, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else dt(e, "track", t => (t.transceiver || Object.defineProperty(t, "transceiver", { value: { receiver: t.receiver } }), t)) } function Sa(e) { if (typeof e == "object" && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { const t = function (i, a) { return { track: a, get dtmf() { return this._dtmf === void 0 && (a.kind === "audio" ? this._dtmf = i.createDTMFSender(a) : this._dtmf = null), this._dtmf }, _pc: i } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const i = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (u, s) { let c = i.apply(this, arguments); return c || (c = t(this, u), this._senders.push(c)), c }; const a = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (u) { a.apply(this, arguments); const s = this._senders.indexOf(u); s !== -1 && this._senders.splice(s, 1) } } const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (a) { this._senders = this._senders || [], r.apply(this, [a]), a.getTracks().forEach(o => { this._senders.push(t(this, o)) }) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (a) { this._senders = this._senders || [], n.apply(this, [a]), a.getTracks().forEach(o => { const u = this._senders.find(s => s.track === o); u && this._senders.splice(this._senders.indexOf(u), 1) }) } } else if (typeof e == "object" && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function Ta(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [n, i, a] = arguments; if (arguments.length > 0 && typeof n == "function") return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof n != "function")) return t.apply(this, []); const o = function (s) { const c = {}; return s.result().forEach(f => { const p = { id: f.id, timestamp: f.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[f.type] || f.type }; f.names().forEach(m => { p[m] = f.stat(m) }), c[p.id] = p }), c }, u = function (s) { return new Map(Object.keys(s).map(c => [c, s[c]])) }; if (arguments.length >= 2) { const s = function (c) { i(u(o(c))) }; return t.apply(this, [s, n]) } return new Promise((s, c) => { t.apply(this, [function (l) { s(u(o(l))) }, c]) }).then(i, a) } } function ka(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!("getStats" in e.RTCRtpSender.prototype)) { const r = e.RTCPeerConnection.prototype.getSenders; r && (e.RTCPeerConnection.prototype.getSenders = function () { const a = r.apply(this, []); return a.forEach(o => o._pc = this), a }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const a = n.apply(this, arguments); return a._pc = this, a }), e.RTCRtpSender.prototype.getStats = function () { const a = this; return this._pc.getStats().then(o => li(o, a.track, !0)) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { const r = e.RTCPeerConnection.prototype.getReceivers; r && (e.RTCPeerConnection.prototype.getReceivers = function () { const i = r.apply(this, []); return i.forEach(a => a._pc = this), i }), dt(e, "track", n => (n.receiver._pc = n.srcElement, n)), e.RTCRtpReceiver.prototype.getStats = function () { const i = this; return this._pc.getStats().then(a => li(a, i.track, !1)) } } if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const n = arguments[0]; let i, a, o; return this.getSenders().forEach(u => { u.track === n && (i ? o = !0 : i = u) }), this.getReceivers().forEach(u => (u.track === n && (a ? o = !0 : a = u), u.track === n)), o || i && a ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : i ? i.getStats() : a ? a.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) } } function Pa(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(o => this._shimmedLocalStreams[o][0]) }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (o, u) { if (!u) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const s = t.apply(this, arguments); return this._shimmedLocalStreams[u.id] ? this._shimmedLocalStreams[u.id].indexOf(s) === -1 && this._shimmedLocalStreams[u.id].push(s) : this._shimmedLocalStreams[u.id] = [u, s], s }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (o) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o.getTracks().forEach(c => { if (this.getSenders().find(f => f.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError") }); const u = this.getSenders(); r.apply(this, arguments); const s = this.getSenders().filter(c => u.indexOf(c) === -1); this._shimmedLocalStreams[o.id] = [o].concat(s) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[o.id], n.apply(this, arguments) }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o && Object.keys(this._shimmedLocalStreams).forEach(u => { const s = this._shimmedLocalStreams[u].indexOf(o); s !== -1 && this._shimmedLocalStreams[u].splice(s, 1), this._shimmedLocalStreams[u].length === 1 && delete this._shimmedLocalStreams[u] }), i.apply(this, arguments) } } function Ra(e, t) { if (!e.RTCPeerConnection) return; if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return Pa(e); const r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const l = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, l.map(f => this._reverseStreams[f.id]) }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (l) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, l.getTracks().forEach(f => { if (this.getSenders().find(m => m.track === f)) throw new DOMException("Track already exists.", "InvalidAccessError") }), !this._reverseStreams[l.id]) { const f = new e.MediaStream(l.getTracks()); this._streams[l.id] = f, this._reverseStreams[f.id] = l, l = f } n.apply(this, [l]) }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (l) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[l.id] || l]), delete this._reverseStreams[this._streams[l.id] ? this._streams[l.id].id : l.id], delete this._streams[l.id] }, e.RTCPeerConnection.prototype.addTrack = function (l, f) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const p = [].slice.call(arguments, 1); if (p.length !== 1 || !p[0].getTracks().find(h => h === l)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find(h => h.track === l)) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const d = this._streams[f.id]; if (d) d.addTrack(l), Promise.resolve().then(() => { this.dispatchEvent(new Event("negotiationneeded")) }); else { const h = new e.MediaStream([l]); this._streams[f.id] = h, this._reverseStreams[h.id] = f, this.addStream(h) } return this.getSenders().find(h => h.track === l) }; function a(c, l) { let f = l.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const m = c._reverseStreams[p], d = c._streams[m.id]; f = f.replace(new RegExp(d.id, "g"), m.id) }), new RTCSessionDescription({ type: l.type, sdp: f }) } function o(c, l) { let f = l.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const m = c._reverseStreams[p], d = c._streams[m.id]; f = f.replace(new RegExp(m.id, "g"), d.id) }), new RTCSessionDescription({ type: l.type, sdp: f }) } ["createOffer", "createAnswer"].forEach(function (c) { const l = e.RTCPeerConnection.prototype[c], f = { [c]() { const p = arguments; return arguments.length && typeof arguments[0] == "function" ? l.apply(this, [d => { const h = a(this, d); p[0].apply(null, [h]) }, d => { p[1] && p[1].apply(null, d) }, arguments[2]]) : l.apply(this, arguments).then(d => a(this, d)) } }; e.RTCPeerConnection.prototype[c] = f[c] }); const u = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return !arguments.length || !arguments[0].type ? u.apply(this, arguments) : (arguments[0] = o(this, arguments[0]), u.apply(this, arguments)) }; const s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { const c = s.get.apply(this); return c.type === "" ? c : a(this, c) } }), e.RTCPeerConnection.prototype.removeTrack = function (l) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!l._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (!(l._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; let p; Object.keys(this._streams).forEach(m => { this._streams[m].getTracks().find(h => l.track === h) && (p = this._streams[m]) }), p && (p.getTracks().length === 1 ? this.removeStream(this._reverseStreams[p.id]) : p.removeTrack(l.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function dn(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), !!e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (r) { const n = e.RTCPeerConnection.prototype[r], i = { [r]() { return arguments[0] = new (r === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[r] = i[r] }) } function Ea(e, t) { dt(e, "negotiationneeded", r => { const n = r.target; if (!((t.version < 72 || n.getConfiguration && n.getConfiguration().sdpSemantics === "plan-b") && n.signalingState !== "stable")) return r }) } const pi = Object.freeze(Object.defineProperty({ __proto__: null, shimMediaStream: _a, shimOnTrack: Ca, shimGetSendersWithDtmf: Sa, shimGetStats: Ta, shimSenderReceiverGetStats: ka, shimAddTrackRemoveTrackWithNative: Pa, shimAddTrackRemoveTrack: Ra, shimPeerConnection: dn, fixNegotiationNeeded: Ea, shimGetUserMedia: ba, shimGetDisplayMedia: yc }, Symbol.toStringTag, { value: "Module" })); function gc(e, t) { let r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(n => { if (n && (n.urls || n.url)) { let i = n.urls || n.url; n.url && !n.urls && Rr("RTCIceServer.url", "RTCIceServer.urls"); const a = typeof i == "string"; return a && (i = [i]), i = i.filter(o => { if (o.indexOf("stun:") === 0) return !1; const u = o.startsWith("turn") && !o.startsWith("turn:[") && o.includes("transport=udp"); return u && !r ? (r = !0, !0) : u && !r }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } var Ln = { exports: {} }; (function (e) {
    var t = {}; t.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10) }, t.localCName = t.generateIdentifier(), t.splitLines = function (r) {
        return r.trim().split(`
`).map(function (n) { return n.trim() })
    }, t.splitSections = function (r) {
        var n = r.split(`
m=`); return n.map(function (i, a) {
            return (a > 0 ? "m=" + i : i).trim() + `\r
`})
    }, t.getDescription = function (r) { var n = t.splitSections(r); return n && n[0] }, t.getMediaSections = function (r) { var n = t.splitSections(r); return n.shift(), n }, t.matchPrefix = function (r, n) { return t.splitLines(r).filter(function (i) { return i.indexOf(n) === 0 }) }, t.parseCandidate = function (r) { var n; r.indexOf("a=candidate:") === 0 ? n = r.substring(12).split(" ") : n = r.substring(10).split(" "); for (var i = { foundation: n[0], component: parseInt(n[1], 10), protocol: n[2].toLowerCase(), priority: parseInt(n[3], 10), ip: n[4], address: n[4], port: parseInt(n[5], 10), type: n[7] }, a = 8; a < n.length; a += 2)switch (n[a]) { case "raddr": i.relatedAddress = n[a + 1]; break; case "rport": i.relatedPort = parseInt(n[a + 1], 10); break; case "tcptype": i.tcpType = n[a + 1]; break; case "ufrag": i.ufrag = n[a + 1], i.usernameFragment = n[a + 1]; break; default: i[n[a]] = n[a + 1]; break }return i }, t.writeCandidate = function (r) { var n = []; n.push(r.foundation), n.push(r.component), n.push(r.protocol.toUpperCase()), n.push(r.priority), n.push(r.address || r.ip), n.push(r.port); var i = r.type; return n.push("typ"), n.push(i), i !== "host" && r.relatedAddress && r.relatedPort && (n.push("raddr"), n.push(r.relatedAddress), n.push("rport"), n.push(r.relatedPort)), r.tcpType && r.protocol.toLowerCase() === "tcp" && (n.push("tcptype"), n.push(r.tcpType)), (r.usernameFragment || r.ufrag) && (n.push("ufrag"), n.push(r.usernameFragment || r.ufrag)), "candidate:" + n.join(" ") }, t.parseIceOptions = function (r) { return r.substr(14).split(" ") }, t.parseRtpMap = function (r) { var n = r.substr(9).split(" "), i = { payloadType: parseInt(n.shift(), 10) }; return n = n[0].split("/"), i.name = n[0], i.clockRate = parseInt(n[1], 10), i.channels = n.length === 3 ? parseInt(n[2], 10) : 1, i.numChannels = i.channels, i }, t.writeRtpMap = function (r) {
        var n = r.payloadType; r.preferredPayloadType !== void 0 && (n = r.preferredPayloadType); var i = r.channels || r.numChannels || 1; return "a=rtpmap:" + n + " " + r.name + "/" + r.clockRate + (i !== 1 ? "/" + i : "") + `\r
`}, t.parseExtmap = function (r) { var n = r.substr(9).split(" "); return { id: parseInt(n[0], 10), direction: n[0].indexOf("/") > 0 ? n[0].split("/")[1] : "sendrecv", uri: n[1] } }, t.writeExtmap = function (r) {
            return "a=extmap:" + (r.id || r.preferredId) + (r.direction && r.direction !== "sendrecv" ? "/" + r.direction : "") + " " + r.uri + `\r
`}, t.parseFmtp = function (r) { for (var n = {}, i, a = r.substr(r.indexOf(" ") + 1).split(";"), o = 0; o < a.length; o++)i = a[o].trim().split("="), n[i[0].trim()] = i[1]; return n }, t.writeFmtp = function (r) {
            var n = "", i = r.payloadType; if (r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.parameters && Object.keys(r.parameters).length) {
                var a = []; Object.keys(r.parameters).forEach(function (o) { r.parameters[o] ? a.push(o + "=" + r.parameters[o]) : a.push(o) }), n += "a=fmtp:" + i + " " + a.join(";") + `\r
`} return n
        }, t.parseRtcpFb = function (r) { var n = r.substr(r.indexOf(" ") + 1).split(" "); return { type: n.shift(), parameter: n.join(" ") } }, t.writeRtcpFb = function (r) {
            var n = "", i = r.payloadType; return r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.rtcpFeedback && r.rtcpFeedback.length && r.rtcpFeedback.forEach(function (a) {
                n += "a=rtcp-fb:" + i + " " + a.type + (a.parameter && a.parameter.length ? " " + a.parameter : "") + `\r
`}), n
        }, t.parseSsrcMedia = function (r) { var n = r.indexOf(" "), i = { ssrc: parseInt(r.substr(7, n - 7), 10) }, a = r.indexOf(":", n); return a > -1 ? (i.attribute = r.substr(n + 1, a - n - 1), i.value = r.substr(a + 1)) : i.attribute = r.substr(n + 1), i }, t.parseSsrcGroup = function (r) { var n = r.substr(13).split(" "); return { semantics: n.shift(), ssrcs: n.map(function (i) { return parseInt(i, 10) }) } }, t.getMid = function (r) { var n = t.matchPrefix(r, "a=mid:")[0]; if (n) return n.substr(6) }, t.parseFingerprint = function (r) { var n = r.substr(14).split(" "); return { algorithm: n[0].toLowerCase(), value: n[1] } }, t.getDtlsParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=fingerprint:"); return { role: "auto", fingerprints: i.map(t.parseFingerprint) } }, t.writeDtlsParameters = function (r, n) {
            var i = "a=setup:" + n + `\r
`; return r.fingerprints.forEach(function (a) {
                i += "a=fingerprint:" + a.algorithm + " " + a.value + `\r
`}), i
        }, t.parseCryptoLine = function (r) { var n = r.substr(9).split(" "); return { tag: parseInt(n[0], 10), cryptoSuite: n[1], keyParams: n[2], sessionParams: n.slice(3) } }, t.writeCryptoLine = function (r) {
            return "a=crypto:" + r.tag + " " + r.cryptoSuite + " " + (typeof r.keyParams == "object" ? t.writeCryptoKeyParams(r.keyParams) : r.keyParams) + (r.sessionParams ? " " + r.sessionParams.join(" ") : "") + `\r
`}, t.parseCryptoKeyParams = function (r) { if (r.indexOf("inline:") !== 0) return null; var n = r.substr(7).split("|"); return { keyMethod: "inline", keySalt: n[0], lifeTime: n[1], mkiValue: n[2] ? n[2].split(":")[0] : void 0, mkiLength: n[2] ? n[2].split(":")[1] : void 0 } }, t.writeCryptoKeyParams = function (r) { return r.keyMethod + ":" + r.keySalt + (r.lifeTime ? "|" + r.lifeTime : "") + (r.mkiValue && r.mkiLength ? "|" + r.mkiValue + ":" + r.mkiLength : "") }, t.getCryptoParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=crypto:"); return i.map(t.parseCryptoLine) }, t.getIceParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=ice-ufrag:")[0], a = t.matchPrefix(r + n, "a=ice-pwd:")[0]; return i && a ? { usernameFragment: i.substr(12), password: a.substr(10) } : null }, t.writeIceParameters = function (r) {
            return "a=ice-ufrag:" + r.usernameFragment + `\r
a=ice-pwd:`+ r.password + `\r
`}, t.parseRtpParameters = function (r) { for (var n = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i = t.splitLines(r), a = i[0].split(" "), o = 3; o < a.length; o++) { var u = a[o], s = t.matchPrefix(r, "a=rtpmap:" + u + " ")[0]; if (s) { var c = t.parseRtpMap(s), l = t.matchPrefix(r, "a=fmtp:" + u + " "); switch (c.parameters = l.length ? t.parseFmtp(l[0]) : {}, c.rtcpFeedback = t.matchPrefix(r, "a=rtcp-fb:" + u + " ").map(t.parseRtcpFb), n.codecs.push(c), c.name.toUpperCase()) { case "RED": case "ULPFEC": n.fecMechanisms.push(c.name.toUpperCase()); break } } } return t.matchPrefix(r, "a=extmap:").forEach(function (f) { n.headerExtensions.push(t.parseExtmap(f)) }), n }, t.writeRtpDescription = function (r, n) {
            var i = ""; i += "m=" + r + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map(function (o) { return o.preferredPayloadType !== void 0 ? o.preferredPayloadType : o.payloadType }).join(" ") + `\r
`, i += `c=IN IP4 0.0.0.0\r
`, i += `a=rtcp:9 IN IP4 0.0.0.0\r
`, n.codecs.forEach(function (o) { i += t.writeRtpMap(o), i += t.writeFmtp(o), i += t.writeRtcpFb(o) }); var a = 0; return n.codecs.forEach(function (o) { o.maxptime > a && (a = o.maxptime) }), a > 0 && (i += "a=maxptime:" + a + `\r
`), i += `a=rtcp-mux\r
`, n.headerExtensions && n.headerExtensions.forEach(function (o) { i += t.writeExtmap(o) }), i
        }, t.parseRtpEncodingParameters = function (r) { var n = [], i = t.parseRtpParameters(r), a = i.fecMechanisms.indexOf("RED") !== -1, o = i.fecMechanisms.indexOf("ULPFEC") !== -1, u = t.matchPrefix(r, "a=ssrc:").map(function (p) { return t.parseSsrcMedia(p) }).filter(function (p) { return p.attribute === "cname" }), s = u.length > 0 && u[0].ssrc, c, l = t.matchPrefix(r, "a=ssrc-group:FID").map(function (p) { var m = p.substr(17).split(" "); return m.map(function (d) { return parseInt(d, 10) }) }); l.length > 0 && l[0].length > 1 && l[0][0] === s && (c = l[0][1]), i.codecs.forEach(function (p) { if (p.name.toUpperCase() === "RTX" && p.parameters.apt) { var m = { ssrc: s, codecPayloadType: parseInt(p.parameters.apt, 10) }; s && c && (m.rtx = { ssrc: c }), n.push(m), a && (m = JSON.parse(JSON.stringify(m)), m.fec = { ssrc: s, mechanism: o ? "red+ulpfec" : "red" }, n.push(m)) } }), n.length === 0 && s && n.push({ ssrc: s }); var f = t.matchPrefix(r, "b="); return f.length && (f[0].indexOf("b=TIAS:") === 0 ? f = parseInt(f[0].substr(7), 10) : f[0].indexOf("b=AS:") === 0 ? f = parseInt(f[0].substr(5), 10) * 1e3 * .95 - 50 * 40 * 8 : f = void 0, n.forEach(function (p) { p.maxBitrate = f })), n }, t.parseRtcpParameters = function (r) { var n = {}, i = t.matchPrefix(r, "a=ssrc:").map(function (u) { return t.parseSsrcMedia(u) }).filter(function (u) { return u.attribute === "cname" })[0]; i && (n.cname = i.value, n.ssrc = i.ssrc); var a = t.matchPrefix(r, "a=rtcp-rsize"); n.reducedSize = a.length > 0, n.compound = a.length === 0; var o = t.matchPrefix(r, "a=rtcp-mux"); return n.mux = o.length > 0, n }, t.parseMsid = function (r) { var n, i = t.matchPrefix(r, "a=msid:"); if (i.length === 1) return n = i[0].substr(7).split(" "), { stream: n[0], track: n[1] }; var a = t.matchPrefix(r, "a=ssrc:").map(function (o) { return t.parseSsrcMedia(o) }).filter(function (o) { return o.attribute === "msid" }); if (a.length > 0) return n = a[0].value.split(" "), { stream: n[0], track: n[1] } }, t.parseSctpDescription = function (r) { var n = t.parseMLine(r), i = t.matchPrefix(r, "a=max-message-size:"), a; i.length > 0 && (a = parseInt(i[0].substr(19), 10)), isNaN(a) && (a = 65536); var o = t.matchPrefix(r, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: n.fmt, maxMessageSize: a }; var u = t.matchPrefix(r, "a=sctpmap:"); if (u.length > 0) { var s = t.matchPrefix(r, "a=sctpmap:")[0].substr(10).split(" "); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: a } } }, t.writeSctpDescription = function (r, n) {
            var i = []; return r.protocol !== "DTLS/SCTP" ? i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + n.port + `\r
`] : i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + n.port + " " + n.protocol + ` 65535\r
`], n.maxMessageSize !== void 0 && i.push("a=max-message-size:" + n.maxMessageSize + `\r
`), i.join("")
        }, t.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, t.writeSessionBoilerplate = function (r, n, i) {
            var a, o = n !== void 0 ? n : 2; r ? a = r : a = t.generateSessionId(); var u = i || "thisisadapterortc"; return `v=0\r
o=`+ u + " " + a + " " + o + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`}, t.writeMediaSection = function (r, n, i, a) {
            var o = t.writeRtpDescription(r.kind, n); if (o += t.writeIceParameters(r.iceGatherer.getLocalParameters()), o += t.writeDtlsParameters(r.dtlsTransport.getLocalParameters(), i === "offer" ? "actpass" : "active"), o += "a=mid:" + r.mid + `\r
`, r.direction ? o += "a=" + r.direction + `\r
`: r.rtpSender && r.rtpReceiver ? o += `a=sendrecv\r
`: r.rtpSender ? o += `a=sendonly\r
`: r.rtpReceiver ? o += `a=recvonly\r
`: o += `a=inactive\r
`, r.rtpSender) {
                var u = "msid:" + a.id + " " + r.rtpSender.track.id + `\r
`; o += "a=" + u, o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " " + u, r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " " + u, o += "a=ssrc-group:FID " + r.sendEncodingParameters[0].ssrc + " " + r.sendEncodingParameters[0].rtx.ssrc + `\r
`)
            } return o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " cname:" + t.localCName + `\r
`, r.rtpSender && r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " cname:" + t.localCName + `\r
`), o
        }, t.getDirection = function (r, n) { for (var i = t.splitLines(r), a = 0; a < i.length; a++)switch (i[a]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return i[a].substr(2) }return n ? t.getDirection(n) : "sendrecv" }, t.getKind = function (r) { var n = t.splitLines(r), i = n[0].split(" "); return i[0].substr(2) }, t.isRejected = function (r) { return r.split(" ", 2)[1] === "0" }, t.parseMLine = function (r) { var n = t.splitLines(r), i = n[0].substr(2).split(" "); return { kind: i[0], port: parseInt(i[1], 10), protocol: i[2], fmt: i.slice(3).join(" ") } }, t.parseOLine = function (r) { var n = t.matchPrefix(r, "o=")[0], i = n.substr(2).split(" "); return { username: i[0], sessionId: i[1], sessionVersion: parseInt(i[2], 10), netType: i[3], addressType: i[4], address: i[5] } }, t.isValidSDP = function (r) { if (typeof r != "string" || r.length === 0) return !1; for (var n = t.splitLines(r), i = 0; i < n.length; i++)if (n[i].length < 2 || n[i].charAt(1) !== "=") return !1; return !0 }, e.exports = t
})(Ln); const ir = Ln.exports; var A = Ln.exports; function bc(e) { return { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type } function di(e, t, r, n, i) {
    var a = A.writeRtpDescription(e.kind, t); if (a += A.writeIceParameters(e.iceGatherer.getLocalParameters()), a += A.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === "offer" ? "actpass" : i || "active"), a += "a=mid:" + e.mid + `\r
`, e.rtpSender && e.rtpReceiver ? a += `a=sendrecv\r
`: e.rtpSender ? a += `a=sendonly\r
`: e.rtpReceiver ? a += `a=recvonly\r
`: a += `a=inactive\r
`, e.rtpSender) {
        var o = e.rtpSender._initialTrackId || e.rtpSender.track.id; e.rtpSender._initialTrackId = o; var u = "msid:" + (n ? n.id : "-") + " " + o + `\r
`; a += "a=" + u, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + u, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + u, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + `\r
`)
    } return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + A.localCName + `\r
`, e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + A.localCName + `\r
`), a
} function _c(e, t) { var r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(function (n) { if (n && (n.urls || n.url)) { var i = n.urls || n.url; n.url && !n.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead."); var a = typeof i == "string"; return a && (i = [i]), i = i.filter(function (o) { var u = o.indexOf("turn:") === 0 && o.indexOf("transport=udp") !== -1 && o.indexOf("turn:[") === -1 && !r; return u ? (r = !0, !0) : o.indexOf("stun:") === 0 && t >= 14393 && o.indexOf("?transport=udp") === -1 }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } function Ht(e, t) { var r = { codecs: [], headerExtensions: [], fecMechanisms: [] }, n = function (a, o) { a = parseInt(a, 10); for (var u = 0; u < o.length; u++)if (o[u].payloadType === a || o[u].preferredPayloadType === a) return o[u] }, i = function (a, o, u, s) { var c = n(a.parameters.apt, u), l = n(o.parameters.apt, s); return c && l && c.name.toLowerCase() === l.name.toLowerCase() }; return e.codecs.forEach(function (a) { for (var o = 0; o < t.codecs.length; o++) { var u = t.codecs[o]; if (a.name.toLowerCase() === u.name.toLowerCase() && a.clockRate === u.clockRate) { if (a.name.toLowerCase() === "rtx" && a.parameters && u.parameters.apt && !i(a, u, e.codecs, t.codecs)) continue; u = JSON.parse(JSON.stringify(u)), u.numChannels = Math.min(a.numChannels, u.numChannels), r.codecs.push(u), u.rtcpFeedback = u.rtcpFeedback.filter(function (s) { for (var c = 0; c < a.rtcpFeedback.length; c++)if (a.rtcpFeedback[c].type === s.type && a.rtcpFeedback[c].parameter === s.parameter) return !0; return !1 }); break } } }), e.headerExtensions.forEach(function (a) { for (var o = 0; o < t.headerExtensions.length; o++) { var u = t.headerExtensions[o]; if (a.uri === u.uri) { r.headerExtensions.push(u); break } } }), r } function hi(e, t, r) { return { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t][e].indexOf(r) !== -1 } function Nr(e, t) { var r = e.getRemoteCandidates().find(function (n) { return t.foundation === n.foundation && t.ip === n.ip && t.port === n.port && t.priority === n.priority && t.protocol === n.protocol && t.type === n.type }); return r || e.addRemoteCandidate(t), !r } function re(e, t) { var r = new Error(t); return r.name = e, r.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e], r } var Cc = function (e, t) {
    function r(s, c) { c.addTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", { track: s })) } function n(s, c) { c.removeTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", { track: s })) } function i(s, c, l, f) { var p = new Event("track"); p.track = c, p.receiver = l, p.transceiver = { receiver: l }, p.streams = f, e.setTimeout(function () { s._dispatchEvent("track", p) }) } var a = function (s) { var c = this, l = document.createDocumentFragment(); if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (p) { c[p] = l[p].bind(l) }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", s = JSON.parse(JSON.stringify(s || {})), this.usingBundle = s.bundlePolicy === "max-bundle", s.rtcpMuxPolicy === "negotiate") throw re("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported"); switch (s.rtcpMuxPolicy || (s.rtcpMuxPolicy = "require"), s.iceTransportPolicy) { case "all": case "relay": break; default: s.iceTransportPolicy = "all"; break }switch (s.bundlePolicy) { case "balanced": case "max-compat": case "max-bundle": break; default: s.bundlePolicy = "balanced"; break }if (s.iceServers = _c(s.iceServers || [], t), this._iceGatherers = [], s.iceCandidatePoolSize) for (var f = s.iceCandidatePoolSize; f > 0; f--)this._iceGatherers.push(new e.RTCIceGatherer({ iceServers: s.iceServers, gatherPolicy: s.iceTransportPolicy })); else s.iceCandidatePoolSize = 0; this._config = s, this.transceivers = [], this._sdpSessionId = A.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1 }; Object.defineProperty(a.prototype, "localDescription", { configurable: !0, get: function () { return this._localDescription } }), Object.defineProperty(a.prototype, "remoteDescription", { configurable: !0, get: function () { return this._remoteDescription } }), a.prototype.onicecandidate = null, a.prototype.onaddstream = null, a.prototype.ontrack = null, a.prototype.onremovestream = null, a.prototype.onsignalingstatechange = null, a.prototype.oniceconnectionstatechange = null, a.prototype.onconnectionstatechange = null, a.prototype.onicegatheringstatechange = null, a.prototype.onnegotiationneeded = null, a.prototype.ondatachannel = null, a.prototype._dispatchEvent = function (s, c) { this._isClosed || (this.dispatchEvent(c), typeof this["on" + s] == "function" && this["on" + s](c)) }, a.prototype._emitGatheringStateChange = function () { var s = new Event("icegatheringstatechange"); this._dispatchEvent("icegatheringstatechange", s) }, a.prototype.getConfiguration = function () { return this._config }, a.prototype.getLocalStreams = function () { return this.localStreams }, a.prototype.getRemoteStreams = function () { return this.remoteStreams }, a.prototype._createTransceiver = function (s, c) { var l = this.transceivers.length > 0, f = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: s, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: !0 }; if (this.usingBundle && l) f.iceTransport = this.transceivers[0].iceTransport, f.dtlsTransport = this.transceivers[0].dtlsTransport; else { var p = this._createIceAndDtlsTransports(); f.iceTransport = p.iceTransport, f.dtlsTransport = p.dtlsTransport } return c || this.transceivers.push(f), f }, a.prototype.addTrack = function (s, c) { if (this._isClosed) throw re("InvalidStateError", "Attempted to call addTrack on a closed peerconnection."); var l = this.transceivers.find(function (m) { return m.track === s }); if (l) throw re("InvalidAccessError", "Track already exists."); for (var f, p = 0; p < this.transceivers.length; p++)!this.transceivers[p].track && this.transceivers[p].kind === s.kind && (f = this.transceivers[p]); return f || (f = this._createTransceiver(s.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(c) === -1 && this.localStreams.push(c), f.track = s, f.stream = c, f.rtpSender = new e.RTCRtpSender(s, f.dtlsTransport), f.rtpSender }, a.prototype.addStream = function (s) { var c = this; if (t >= 15025) s.getTracks().forEach(function (f) { c.addTrack(f, s) }); else { var l = s.clone(); s.getTracks().forEach(function (f, p) { var m = l.getTracks()[p]; f.addEventListener("enabled", function (d) { m.enabled = d.enabled }) }), l.getTracks().forEach(function (f) { c.addTrack(f, l) }) } }, a.prototype.removeTrack = function (s) { if (this._isClosed) throw re("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection."); if (!(s instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender."); var c = this.transceivers.find(function (p) { return p.rtpSender === s }); if (!c) throw re("InvalidAccessError", "Sender was not created by this connection."); var l = c.stream; c.rtpSender.stop(), c.rtpSender = null, c.track = null, c.stream = null; var f = this.transceivers.map(function (p) { return p.stream }); f.indexOf(l) === -1 && this.localStreams.indexOf(l) > -1 && this.localStreams.splice(this.localStreams.indexOf(l), 1), this._maybeFireNegotiationNeeded() }, a.prototype.removeStream = function (s) { var c = this; s.getTracks().forEach(function (l) { var f = c.getSenders().find(function (p) { return p.track === l }); f && c.removeTrack(f) }) }, a.prototype.getSenders = function () { return this.transceivers.filter(function (s) { return !!s.rtpSender }).map(function (s) { return s.rtpSender }) }, a.prototype.getReceivers = function () { return this.transceivers.filter(function (s) { return !!s.rtpReceiver }).map(function (s) { return s.rtpReceiver }) }, a.prototype._createIceGatherer = function (s, c) { var l = this; if (c && s > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var f = new e.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(f, "state", { value: "new", writable: !0 }), this.transceivers[s].bufferedCandidateEvents = [], this.transceivers[s].bufferCandidates = function (p) { var m = !p.candidate || Object.keys(p.candidate).length === 0; f.state = m ? "completed" : "gathering", l.transceivers[s].bufferedCandidateEvents !== null && l.transceivers[s].bufferedCandidateEvents.push(p) }, f.addEventListener("localcandidate", this.transceivers[s].bufferCandidates), f }, a.prototype._gather = function (s, c) {
        var l = this, f = this.transceivers[c].iceGatherer; if (!f.onlocalcandidate) {
            var p = this.transceivers[c].bufferedCandidateEvents; this.transceivers[c].bufferedCandidateEvents = null, f.removeEventListener("localcandidate", this.transceivers[c].bufferCandidates), f.onlocalcandidate = function (m) {
                if (!(l.usingBundle && c > 0)) {
                    var d = new Event("icecandidate"); d.candidate = { sdpMid: s, sdpMLineIndex: c }; var h = m.candidate, b = !h || Object.keys(h).length === 0; if (b) (f.state === "new" || f.state === "gathering") && (f.state = "completed"); else { f.state === "new" && (f.state = "gathering"), h.component = 1, h.ufrag = f.getLocalParameters().usernameFragment; var v = A.writeCandidate(h); d.candidate = Object.assign(d.candidate, A.parseCandidate(v)), d.candidate.candidate = v, d.candidate.toJSON = function () { return { candidate: d.candidate.candidate, sdpMid: d.candidate.sdpMid, sdpMLineIndex: d.candidate.sdpMLineIndex, usernameFragment: d.candidate.usernameFragment } } } var g = A.getMediaSections(l._localDescription.sdp); b ? g[d.candidate.sdpMLineIndex] += `a=end-of-candidates\r
`: g[d.candidate.sdpMLineIndex] += "a=" + d.candidate.candidate + `\r
`, l._localDescription.sdp = A.getDescription(l._localDescription.sdp) + g.join(""); var C = l.transceivers.every(function (_) { return _.iceGatherer && _.iceGatherer.state === "completed" }); l.iceGatheringState !== "gathering" && (l.iceGatheringState = "gathering", l._emitGatheringStateChange()), b || l._dispatchEvent("icecandidate", d), C && (l._dispatchEvent("icecandidate", new Event("icecandidate")), l.iceGatheringState = "complete", l._emitGatheringStateChange())
                }
            }, e.setTimeout(function () { p.forEach(function (m) { f.onlocalcandidate(m) }) }, 0)
        }
    }, a.prototype._createIceAndDtlsTransports = function () { var s = this, c = new e.RTCIceTransport(null); c.onicestatechange = function () { s._updateIceConnectionState(), s._updateConnectionState() }; var l = new e.RTCDtlsTransport(c); return l.ondtlsstatechange = function () { s._updateConnectionState() }, l.onerror = function () { Object.defineProperty(l, "state", { value: "failed", writable: !0 }), s._updateConnectionState() }, { iceTransport: c, dtlsTransport: l } }, a.prototype._disposeIceAndDtlsTransports = function (s) { var c = this.transceivers[s].iceGatherer; c && (delete c.onlocalcandidate, delete this.transceivers[s].iceGatherer); var l = this.transceivers[s].iceTransport; l && (delete l.onicestatechange, delete this.transceivers[s].iceTransport); var f = this.transceivers[s].dtlsTransport; f && (delete f.ondtlsstatechange, delete f.onerror, delete this.transceivers[s].dtlsTransport) }, a.prototype._transceive = function (s, c, l) { var f = Ht(s.localCapabilities, s.remoteCapabilities); c && s.rtpSender && (f.encodings = s.sendEncodingParameters, f.rtcp = { cname: A.localCName, compound: s.rtcpParameters.compound }, s.recvEncodingParameters.length && (f.rtcp.ssrc = s.recvEncodingParameters[0].ssrc), s.rtpSender.send(f)), l && s.rtpReceiver && f.codecs.length > 0 && (s.kind === "video" && s.recvEncodingParameters && t < 15019 && s.recvEncodingParameters.forEach(function (p) { delete p.rtx }), s.recvEncodingParameters.length ? f.encodings = s.recvEncodingParameters : f.encodings = [{}], f.rtcp = { compound: s.rtcpParameters.compound }, s.rtcpParameters.cname && (f.rtcp.cname = s.rtcpParameters.cname), s.sendEncodingParameters.length && (f.rtcp.ssrc = s.sendEncodingParameters[0].ssrc), s.rtpReceiver.receive(f)) }, a.prototype.setLocalDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(re("TypeError", 'Unsupported type "' + s.type + '"')); if (!hi("setLocalDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(re("InvalidStateError", "Can not set local " + s.type + " in state " + c.signalingState)); var l, f; if (s.type === "offer") l = A.splitSections(s.sdp), f = l.shift(), l.forEach(function (m, d) { var h = A.parseRtpParameters(m); c.transceivers[d].localCapabilities = h }), c.transceivers.forEach(function (m, d) { c._gather(m.mid, d) }); else if (s.type === "answer") { l = A.splitSections(c._remoteDescription.sdp), f = l.shift(); var p = A.matchPrefix(f, "a=ice-lite").length > 0; l.forEach(function (m, d) { var h = c.transceivers[d], b = h.iceGatherer, v = h.iceTransport, g = h.dtlsTransport, C = h.localCapabilities, _ = h.remoteCapabilities, y = A.isRejected(m) && A.matchPrefix(m, "a=bundle-only").length === 0; if (!y && !h.rejected) { var S = A.getIceParameters(m, f), R = A.getDtlsParameters(m, f); p && (R.role = "server"), (!c.usingBundle || d === 0) && (c._gather(h.mid, d), v.state === "new" && v.start(b, S, p ? "controlling" : "controlled"), g.state === "new" && g.start(R)); var T = Ht(C, _); c._transceive(h, T.codecs.length > 0, !1) } }) } return c._localDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-local-offer") : c._updateSignalingState("stable"), Promise.resolve() }, a.prototype.setRemoteDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(re("TypeError", 'Unsupported type "' + s.type + '"')); if (!hi("setRemoteDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(re("InvalidStateError", "Can not set remote " + s.type + " in state " + c.signalingState)); var l = {}; c.remoteStreams.forEach(function (v) { l[v.id] = v }); var f = [], p = A.splitSections(s.sdp), m = p.shift(), d = A.matchPrefix(m, "a=ice-lite").length > 0, h = A.matchPrefix(m, "a=group:BUNDLE ").length > 0; c.usingBundle = h; var b = A.matchPrefix(m, "a=ice-options:")[0]; return b ? c.canTrickleIceCandidates = b.substr(14).split(" ").indexOf("trickle") >= 0 : c.canTrickleIceCandidates = !1, p.forEach(function (v, g) { var C = A.splitLines(v), _ = A.getKind(v), y = A.isRejected(v) && A.matchPrefix(v, "a=bundle-only").length === 0, S = C[0].substr(2).split(" ")[2], R = A.getDirection(v, m), T = A.parseMsid(v), O = A.getMid(v) || A.generateIdentifier(); if (y || _ === "application" && (S === "DTLS/SCTP" || S === "UDP/DTLS/SCTP")) { c.transceivers[g] = { mid: O, kind: _, protocol: S, rejected: !0 }; return } !y && c.transceivers[g] && c.transceivers[g].rejected && (c.transceivers[g] = c._createTransceiver(_, !0)); var k, N, K, F, z, M, te, X, W, he = A.parseRtpParameters(v), se, ge; y || (se = A.getIceParameters(v, m), ge = A.getDtlsParameters(v, m), ge.role = "client"), te = A.parseRtpEncodingParameters(v); var me = A.parseRtcpParameters(v), je = A.matchPrefix(v, "a=end-of-candidates", m).length > 0, Y = A.matchPrefix(v, "a=candidate:").map(function (fe) { return A.parseCandidate(fe) }).filter(function (fe) { return fe.component === 1 }); if ((s.type === "offer" || s.type === "answer") && !y && h && g > 0 && c.transceivers[g] && (c._disposeIceAndDtlsTransports(g), c.transceivers[g].iceGatherer = c.transceivers[0].iceGatherer, c.transceivers[g].iceTransport = c.transceivers[0].iceTransport, c.transceivers[g].dtlsTransport = c.transceivers[0].dtlsTransport, c.transceivers[g].rtpSender && c.transceivers[g].rtpSender.setTransport(c.transceivers[0].dtlsTransport), c.transceivers[g].rtpReceiver && c.transceivers[g].rtpReceiver.setTransport(c.transceivers[0].dtlsTransport)), s.type === "offer" && !y) { k = c.transceivers[g] || c._createTransceiver(_), k.mid = O, k.iceGatherer || (k.iceGatherer = c._createIceGatherer(g, h)), Y.length && k.iceTransport.state === "new" && (je && (!h || g === 0) ? k.iceTransport.setRemoteCandidates(Y) : Y.forEach(function (fe) { Nr(k.iceTransport, fe) })), X = e.RTCRtpReceiver.getCapabilities(_), t < 15019 && (X.codecs = X.codecs.filter(function (fe) { return fe.name !== "rtx" })), M = k.sendEncodingParameters || [{ ssrc: (2 * g + 2) * 1001 }]; var Be = !1; if (R === "sendrecv" || R === "sendonly") { if (Be = !k.rtpReceiver, z = k.rtpReceiver || new e.RTCRtpReceiver(k.dtlsTransport, _), Be) { var Fe; W = z.track, T && T.stream === "-" || (T ? (l[T.stream] || (l[T.stream] = new e.MediaStream, Object.defineProperty(l[T.stream], "id", { get: function () { return T.stream } })), Object.defineProperty(W, "id", { get: function () { return T.track } }), Fe = l[T.stream]) : (l.default || (l.default = new e.MediaStream), Fe = l.default)), Fe && (r(W, Fe), k.associatedRemoteMediaStreams.push(Fe)), f.push([W, z, Fe]) } } else k.rtpReceiver && k.rtpReceiver.track && (k.associatedRemoteMediaStreams.forEach(function (fe) { var Gn = fe.getTracks().find(function (no) { return no.id === k.rtpReceiver.track.id }); Gn && n(Gn, fe) }), k.associatedRemoteMediaStreams = []); k.localCapabilities = X, k.remoteCapabilities = he, k.rtpReceiver = z, k.rtcpParameters = me, k.sendEncodingParameters = M, k.recvEncodingParameters = te, c._transceive(c.transceivers[g], !1, Be) } else if (s.type === "answer" && !y) { k = c.transceivers[g], N = k.iceGatherer, K = k.iceTransport, F = k.dtlsTransport, z = k.rtpReceiver, M = k.sendEncodingParameters, X = k.localCapabilities, c.transceivers[g].recvEncodingParameters = te, c.transceivers[g].remoteCapabilities = he, c.transceivers[g].rtcpParameters = me, Y.length && K.state === "new" && ((d || je) && (!h || g === 0) ? K.setRemoteCandidates(Y) : Y.forEach(function (fe) { Nr(k.iceTransport, fe) })), (!h || g === 0) && (K.state === "new" && K.start(N, se, "controlling"), F.state === "new" && F.start(ge)); var to = Ht(k.localCapabilities, k.remoteCapabilities), ro = to.codecs.filter(function (fe) { return fe.name.toLowerCase() === "rtx" }).length; !ro && k.sendEncodingParameters[0].rtx && delete k.sendEncodingParameters[0].rtx, c._transceive(k, R === "sendrecv" || R === "recvonly", R === "sendrecv" || R === "sendonly"), z && (R === "sendrecv" || R === "sendonly") ? (W = z.track, T ? (l[T.stream] || (l[T.stream] = new e.MediaStream), r(W, l[T.stream]), f.push([W, z, l[T.stream]])) : (l.default || (l.default = new e.MediaStream), r(W, l.default), f.push([W, z, l.default]))) : delete k.rtpReceiver } }), c._dtlsRole === void 0 && (c._dtlsRole = s.type === "offer" ? "active" : "passive"), c._remoteDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-remote-offer") : c._updateSignalingState("stable"), Object.keys(l).forEach(function (v) { var g = l[v]; if (g.getTracks().length) { if (c.remoteStreams.indexOf(g) === -1) { c.remoteStreams.push(g); var C = new Event("addstream"); C.stream = g, e.setTimeout(function () { c._dispatchEvent("addstream", C) }) } f.forEach(function (_) { var y = _[0], S = _[1]; g.id === _[2].id && i(c, y, S, [g]) }) } }), f.forEach(function (v) { v[2] || i(c, v[0], v[1], []) }), e.setTimeout(function () { !(c && c.transceivers) || c.transceivers.forEach(function (v) { v.iceTransport && v.iceTransport.state === "new" && v.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), v.iceTransport.addRemoteCandidate({})) }) }, 4e3), Promise.resolve() }, a.prototype.close = function () { this.transceivers.forEach(function (s) { s.iceTransport && s.iceTransport.stop(), s.dtlsTransport && s.dtlsTransport.stop(), s.rtpSender && s.rtpSender.stop(), s.rtpReceiver && s.rtpReceiver.stop() }), this._isClosed = !0, this._updateSignalingState("closed") }, a.prototype._updateSignalingState = function (s) { this.signalingState = s; var c = new Event("signalingstatechange"); this._dispatchEvent("signalingstatechange", c) }, a.prototype._maybeFireNegotiationNeeded = function () { var s = this; this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, e.setTimeout(function () { if (s.needNegotiation) { s.needNegotiation = !1; var c = new Event("negotiationneeded"); s._dispatchEvent("negotiationneeded", c) } }, 0)) }, a.prototype._updateIceConnectionState = function () { var s, c = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (f) { f.iceTransport && !f.rejected && c[f.iceTransport.state]++ }), s = "new", c.failed > 0 ? s = "failed" : c.checking > 0 ? s = "checking" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 ? s = "connected" : c.completed > 0 && (s = "completed"), s !== this.iceConnectionState) { this.iceConnectionState = s; var l = new Event("iceconnectionstatechange"); this._dispatchEvent("iceconnectionstatechange", l) } }, a.prototype._updateConnectionState = function () { var s, c = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (f) { f.iceTransport && f.dtlsTransport && !f.rejected && (c[f.iceTransport.state]++, c[f.dtlsTransport.state]++) }), c.connected += c.completed, s = "new", c.failed > 0 ? s = "failed" : c.connecting > 0 ? s = "connecting" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 && (s = "connected"), s !== this.connectionState) { this.connectionState = s; var l = new Event("connectionstatechange"); this._dispatchEvent("connectionstatechange", l) } }, a.prototype.createOffer = function () {
        var s = this; if (s._isClosed) return Promise.reject(re("InvalidStateError", "Can not call createOffer after close")); var c = s.transceivers.filter(function (d) { return d.kind === "audio" }).length, l = s.transceivers.filter(function (d) { return d.kind === "video" }).length, f = arguments[0]; if (f) { if (f.mandatory || f.optional) throw new TypeError("Legacy mandatory/optional constraints not supported."); f.offerToReceiveAudio !== void 0 && (f.offerToReceiveAudio === !0 ? c = 1 : f.offerToReceiveAudio === !1 ? c = 0 : c = f.offerToReceiveAudio), f.offerToReceiveVideo !== void 0 && (f.offerToReceiveVideo === !0 ? l = 1 : f.offerToReceiveVideo === !1 ? l = 0 : l = f.offerToReceiveVideo) } for (s.transceivers.forEach(function (d) { d.kind === "audio" ? (c--, c < 0 && (d.wantReceive = !1)) : d.kind === "video" && (l--, l < 0 && (d.wantReceive = !1)) }); c > 0 || l > 0;)c > 0 && (s._createTransceiver("audio"), c--), l > 0 && (s._createTransceiver("video"), l--); var p = A.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.transceivers.forEach(function (d, h) { var b = d.track, v = d.kind, g = d.mid || A.generateIdentifier(); d.mid = g, d.iceGatherer || (d.iceGatherer = s._createIceGatherer(h, s.usingBundle)); var C = e.RTCRtpSender.getCapabilities(v); t < 15019 && (C.codecs = C.codecs.filter(function (y) { return y.name !== "rtx" })), C.codecs.forEach(function (y) { y.name === "H264" && y.parameters["level-asymmetry-allowed"] === void 0 && (y.parameters["level-asymmetry-allowed"] = "1"), d.remoteCapabilities && d.remoteCapabilities.codecs && d.remoteCapabilities.codecs.forEach(function (S) { y.name.toLowerCase() === S.name.toLowerCase() && y.clockRate === S.clockRate && (y.preferredPayloadType = S.payloadType) }) }), C.headerExtensions.forEach(function (y) { var S = d.remoteCapabilities && d.remoteCapabilities.headerExtensions || []; S.forEach(function (R) { y.uri === R.uri && (y.id = R.id) }) }); var _ = d.sendEncodingParameters || [{ ssrc: (2 * h + 1) * 1001 }]; b && t >= 15019 && v === "video" && !_[0].rtx && (_[0].rtx = { ssrc: _[0].ssrc + 1 }), d.wantReceive && (d.rtpReceiver = new e.RTCRtpReceiver(d.dtlsTransport, v)), d.localCapabilities = C, d.sendEncodingParameters = _ }), s._config.bundlePolicy !== "max-compat" && (p += "a=group:BUNDLE " + s.transceivers.map(function (d) { return d.mid }).join(" ") + `\r
`), p += `a=ice-options:trickle\r
`, s.transceivers.forEach(function (d, h) {
            p += di(d, d.localCapabilities, "offer", d.stream, s._dtlsRole), p += `a=rtcp-rsize\r
`, d.iceGatherer && s.iceGatheringState !== "new" && (h === 0 || !s.usingBundle) && (d.iceGatherer.getLocalCandidates().forEach(function (b) {
                b.component = 1, p += "a=" + A.writeCandidate(b) + `\r
`}), d.iceGatherer.state === "completed" && (p += `a=end-of-candidates\r
`))
        }); var m = new e.RTCSessionDescription({ type: "offer", sdp: p }); return Promise.resolve(m)
    }, a.prototype.createAnswer = function () {
        var s = this; if (s._isClosed) return Promise.reject(re("InvalidStateError", "Can not call createAnswer after close")); if (!(s.signalingState === "have-remote-offer" || s.signalingState === "have-local-pranswer")) return Promise.reject(re("InvalidStateError", "Can not call createAnswer in signalingState " + s.signalingState)); var c = A.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.usingBundle && (c += "a=group:BUNDLE " + s.transceivers.map(function (p) { return p.mid }).join(" ") + `\r
`), c += `a=ice-options:trickle\r
`; var l = A.getMediaSections(s._remoteDescription.sdp).length; s.transceivers.forEach(function (p, m) {
            if (!(m + 1 > l)) {
                if (p.rejected) {
                    p.kind === "application" ? p.protocol === "DTLS/SCTP" ? c += `m=application 0 DTLS/SCTP 5000\r
`: c += "m=application 0 " + p.protocol + ` webrtc-datachannel\r
`: p.kind === "audio" ? c += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
`: p.kind === "video" && (c += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), c += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:`+ p.mid + `\r
`; return
                } if (p.stream) { var d; p.kind === "audio" ? d = p.stream.getAudioTracks()[0] : p.kind === "video" && (d = p.stream.getVideoTracks()[0]), d && t >= 15019 && p.kind === "video" && !p.sendEncodingParameters[0].rtx && (p.sendEncodingParameters[0].rtx = { ssrc: p.sendEncodingParameters[0].ssrc + 1 }) } var h = Ht(p.localCapabilities, p.remoteCapabilities), b = h.codecs.filter(function (v) { return v.name.toLowerCase() === "rtx" }).length; !b && p.sendEncodingParameters[0].rtx && delete p.sendEncodingParameters[0].rtx, c += di(p, h, "answer", p.stream, s._dtlsRole), p.rtcpParameters && p.rtcpParameters.reducedSize && (c += `a=rtcp-rsize\r
`)
            }
        }); var f = new e.RTCSessionDescription({ type: "answer", sdp: c }); return Promise.resolve(f)
    }, a.prototype.addIceCandidate = function (s) {
        var c = this, l; return s && !(s.sdpMLineIndex !== void 0 || s.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function (f, p) {
            if (c._remoteDescription) if (!s || s.candidate === "") for (var m = 0; m < c.transceivers.length && !(!c.transceivers[m].rejected && (c.transceivers[m].iceTransport.addRemoteCandidate({}), l = A.getMediaSections(c._remoteDescription.sdp), l[m] += `a=end-of-candidates\r
`, c._remoteDescription.sdp = A.getDescription(c._remoteDescription.sdp) + l.join(""), c.usingBundle)); m++); else {
                var d = s.sdpMLineIndex; if (s.sdpMid) { for (var h = 0; h < c.transceivers.length; h++)if (c.transceivers[h].mid === s.sdpMid) { d = h; break } } var b = c.transceivers[d]; if (b) {
                    if (b.rejected) return f(); var v = Object.keys(s.candidate).length > 0 ? A.parseCandidate(s.candidate) : {}; if (v.protocol === "tcp" && (v.port === 0 || v.port === 9) || v.component && v.component !== 1) return f(); if ((d === 0 || d > 0 && b.iceTransport !== c.transceivers[0].iceTransport) && !Nr(b.iceTransport, v)) return p(re("OperationError", "Can not add ICE candidate")); var g = s.candidate.trim(); g.indexOf("a=") === 0 && (g = g.substr(2)), l = A.getMediaSections(c._remoteDescription.sdp), l[d] += "a=" + (v.type ? g : "end-of-candidates") + `\r
`, c._remoteDescription.sdp = A.getDescription(c._remoteDescription.sdp) + l.join("")
                } else return p(re("OperationError", "Can not add ICE candidate"))
            } else return p(re("InvalidStateError", "Can not add ICE candidate without a remote description")); f()
        })
    }, a.prototype.getStats = function (s) { if (s && s instanceof e.MediaStreamTrack) { var c = null; if (this.transceivers.forEach(function (f) { f.rtpSender && f.rtpSender.track === s ? c = f.rtpSender : f.rtpReceiver && f.rtpReceiver.track === s && (c = f.rtpReceiver) }), !c) throw re("InvalidAccessError", "Invalid selector."); return c.getStats() } var l = []; return this.transceivers.forEach(function (f) { ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function (p) { f[p] && l.push(f[p].getStats()) }) }), Promise.all(l).then(function (f) { var p = new Map; return f.forEach(function (m) { m.forEach(function (d) { p.set(d.id, d) }) }), p }) }; var o = ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"]; o.forEach(function (s) { var c = e[s]; if (c && c.prototype && c.prototype.getStats) { var l = c.prototype.getStats; c.prototype.getStats = function () { return l.apply(this).then(function (f) { var p = new Map; return Object.keys(f).forEach(function (m) { f[m].type = bc(f[m]), p.set(m, f[m]) }), p }) } } }); var u = ["createOffer", "createAnswer"]; return u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[0] == "function" || typeof l[1] == "function" ? c.apply(this, [arguments[2]]).then(function (f) { typeof l[0] == "function" && l[0].apply(null, [f]) }, function (f) { typeof l[1] == "function" && l[1].apply(null, [f]) }) : c.apply(this, arguments) } }), u = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[1] == "function" || typeof l[2] == "function" ? c.apply(this, arguments).then(function () { typeof l[1] == "function" && l[1].apply(null) }, function (f) { typeof l[2] == "function" && l[2].apply(null, [f]) }) : c.apply(this, arguments) } }), ["getStats"].forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[1] == "function" ? c.apply(this, arguments).then(function () { typeof l[1] == "function" && l[1].apply(null) }) : c.apply(this, arguments) } }), a
}; function xa(e) { const t = e && e.navigator, r = function (i) { return { name: { PermissionDeniedError: "NotAllowedError" }[i.name] || i.name, message: i.message, constraint: i.constraint, toString() { return this.name } } }, n = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (i) { return n(i).catch(a => Promise.reject(r(a))) } } function Da(e) { "getDisplayMedia" in e.navigator && (!e.navigator.mediaDevices || e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator))) } function hn(e, t) { if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function (i) { return i }), e.RTCSessionDescription || (e.RTCSessionDescription = function (i) { return i }), t.version < 15025)) { const n = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled"); Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", { set(i) { n.set.call(this, i); const a = new Event("enabled"); a.enabled = i, this.dispatchEvent(a) } }) } e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype) && Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf } }), e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender); const r = Cc(e, t.version); e.RTCPeerConnection = function (i) { return i && i.iceServers && (i.iceServers = gc(i.iceServers, t.version), Nn("ICE servers after filtering:", i.iceServers)), new r(i) }, e.RTCPeerConnection.prototype = r.prototype } function wa(e) { e.RTCRtpSender && !("replaceTrack" in e.RTCRtpSender.prototype) && (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack) } const mi = Object.freeze(Object.defineProperty({ __proto__: null, shimPeerConnection: hn, shimReplaceTrack: wa, shimGetUserMedia: xa, shimGetDisplayMedia: Da }, Symbol.toStringTag, { value: "Module" })); function Oa(e, t) { const r = e && e.navigator, n = e && e.MediaStreamTrack; if (r.getUserMedia = function (i, a, o) { Rr("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r.mediaDevices.getUserMedia(i).then(a, o) }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) { const i = function (o, u, s) { u in o && !(s in o) && (o[s] = o[u], delete o[u]) }, a = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (o) { return typeof o == "object" && typeof o.audio == "object" && (o = JSON.parse(JSON.stringify(o)), i(o.audio, "autoGainControl", "mozAutoGainControl"), i(o.audio, "noiseSuppression", "mozNoiseSuppression")), a(o) }, n && n.prototype.getSettings) { const o = n.prototype.getSettings; n.prototype.getSettings = function () { const u = o.apply(this, arguments); return i(u, "mozAutoGainControl", "autoGainControl"), i(u, "mozNoiseSuppression", "noiseSuppression"), u } } if (n && n.prototype.applyConstraints) { const o = n.prototype.applyConstraints; n.prototype.applyConstraints = function (u) { return this.kind === "audio" && typeof u == "object" && (u = JSON.parse(JSON.stringify(u)), i(u, "autoGainControl", "mozAutoGainControl"), i(u, "noiseSuppression", "mozNoiseSuppression")), o.apply(this, [u]) } } } } function Sc(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || !e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = function (n) { if (!(n && n.video)) { const i = new DOMException("getDisplayMedia without video constraints is undefined"); return i.name = "NotFoundError", i.code = 8, Promise.reject(i) } return n.video === !0 ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n) }) } function Aa(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function mn(e, t) { if (typeof e != "object" || !(e.RTCPeerConnection || e.mozRTCPeerConnection)) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (i) { const a = e.RTCPeerConnection.prototype[i], o = { [i]() { return arguments[0] = new (i === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), a.apply(this, arguments) } }; e.RTCPeerConnection.prototype[i] = o[i] }); const r = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [a, o, u] = arguments; return n.apply(this, [a || null]).then(s => { if (t.version < 53 && !o) try { s.forEach(c => { c.type = r[c.type] || c.type }) } catch (c) { if (c.name !== "TypeError") throw c; s.forEach((l, f) => { s.set(f, Object.assign({}, l, { type: r[l.type] || l.type })) }) } return s }).then(o, u) } } function Ia(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const i = t.apply(this, []); return i.forEach(a => a._pc = this), i }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const i = r.apply(this, arguments); return i._pc = this, i }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function Ma(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }), dt(e, "track", r => (r.receiver._pc = r.srcElement, r)), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function ja(e) { !e.RTCPeerConnection || "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { Rr("removeStream", "removeTrack"), this.getSenders().forEach(n => { n.track && r.getTracks().includes(n.track) && this.removeTrack(n) }) }) } function Ba(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function Fa(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const n = arguments[1], i = n && "sendEncodings" in n; i && n.sendEncodings.forEach(o => { if ("rid" in o && !/^[a-z0-9]{0,16}$/i.test(o.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in o && !(parseFloat(o.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in o && !(parseFloat(o.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") }); const a = t.apply(this, arguments); if (i) { const { sender: o } = a, u = o.getParameters(); (!("encodings" in u) || u.encodings.length === 1 && Object.keys(u.encodings[0]).length === 0) && (u.encodings = n.sendEncodings, o.sendEncodings = n.sendEncodings, this.setParametersPromises.push(o.setParameters(u).then(() => { delete o.sendEncodings }).catch(() => { delete o.sendEncodings }))) } return a }) } function Ka(e) { if (!(typeof e == "object" && e.RTCRtpSender)) return; const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const n = t.apply(this, arguments); return "encodings" in n || (n.encodings = [].concat(this.sendEncodings || [{}])), n }) } function Na(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } function La(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } const vi = Object.freeze(Object.defineProperty({ __proto__: null, shimOnTrack: Aa, shimPeerConnection: mn, shimSenderGetStats: Ia, shimReceiverGetStats: Ma, shimRemoveStream: ja, shimRTCDataChannel: Ba, shimAddTransceiver: Fa, shimGetParameters: Ka, shimCreateOffer: Na, shimCreateAnswer: La, shimGetUserMedia: Oa, shimGetDisplayMedia: Sc }, Symbol.toStringTag, { value: "Module" })); function Ua(e) { if (!(typeof e != "object" || !e.RTCPeerConnection)) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (n) { this._localStreams || (this._localStreams = []), this._localStreams.includes(n) || this._localStreams.push(n), n.getAudioTracks().forEach(i => t.call(this, i, n)), n.getVideoTracks().forEach(i => t.call(this, i, n)) }, e.RTCPeerConnection.prototype.addTrack = function (n, ...i) { return i && i.forEach(a => { this._localStreams ? this._localStreams.includes(a) || this._localStreams.push(a) : this._localStreams = [a] }), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { this._localStreams || (this._localStreams = []); const n = this._localStreams.indexOf(r); if (n === -1) return; this._localStreams.splice(n, 1); const i = r.getTracks(); this.getSenders().forEach(a => { i.includes(a.track) && this.removeTrack(a) }) }) } } function za(e) { if (!(typeof e != "object" || !e.RTCPeerConnection) && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(r) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = r), this.addEventListener("track", this._onaddstreampoly = n => { n.streams.forEach(i => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(i)) return; this._remoteStreams.push(i); const a = new Event("addstream"); a.stream = i, this.dispatchEvent(a) }) }) } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const n = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (i) { i.streams.forEach(a => { if (n._remoteStreams || (n._remoteStreams = []), n._remoteStreams.indexOf(a) >= 0) return; n._remoteStreams.push(a); const o = new Event("addstream"); o.stream = a, n.dispatchEvent(o) }) }), t.apply(n, arguments) } } } function $a(e) { if (typeof e != "object" || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer, i = t.setLocalDescription, a = t.setRemoteDescription, o = t.addIceCandidate; t.createOffer = function (c, l) { const f = arguments.length >= 2 ? arguments[2] : arguments[0], p = r.apply(this, [f]); return l ? (p.then(c, l), Promise.resolve()) : p }, t.createAnswer = function (c, l) { const f = arguments.length >= 2 ? arguments[2] : arguments[0], p = n.apply(this, [f]); return l ? (p.then(c, l), Promise.resolve()) : p }; let u = function (s, c, l) { const f = i.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }; t.setLocalDescription = u, u = function (s, c, l) { const f = a.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }, t.setRemoteDescription = u, u = function (s, c, l) { const f = o.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }, t.addIceCandidate = u } function Ga(e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const r = t.mediaDevices, n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = i => n(Ja(i)) } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (n, i, a) { t.mediaDevices.getUserMedia(n).then(i, a) }.bind(t)) } function Ja(e) { return e && e.video !== void 0 ? Object.assign({}, e, { video: ga(e.video) }) : e } function Va(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection; e.RTCPeerConnection = function (n, i) { if (n && n.iceServers) { const a = []; for (let o = 0; o < n.iceServers.length; o++) { let u = n.iceServers[o]; !u.hasOwnProperty("urls") && u.hasOwnProperty("url") ? (Rr("RTCIceServer.url", "RTCIceServer.urls"), u = JSON.parse(JSON.stringify(u)), u.urls = u.url, delete u.url, a.push(u)) : a.push(n.iceServers[o]) } n.iceServers = a } return new t(n, i) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get() { return t.generateCertificate } }) } function Ha(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function qa(e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (n) { if (n) { typeof n.offerToReceiveAudio < "u" && (n.offerToReceiveAudio = !!n.offerToReceiveAudio); const i = this.getTransceivers().find(o => o.receiver.track.kind === "audio"); n.offerToReceiveAudio === !1 && i ? i.direction === "sendrecv" ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : i.direction === "recvonly" && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : n.offerToReceiveAudio === !0 && !i && this.addTransceiver("audio"), typeof n.offerToReceiveVideo < "u" && (n.offerToReceiveVideo = !!n.offerToReceiveVideo); const a = this.getTransceivers().find(o => o.receiver.track.kind === "video"); n.offerToReceiveVideo === !1 && a ? a.direction === "sendrecv" ? a.setDirection ? a.setDirection("sendonly") : a.direction = "sendonly" : a.direction === "recvonly" && (a.setDirection ? a.setDirection("inactive") : a.direction = "inactive") : n.offerToReceiveVideo === !0 && !a && this.addTransceiver("video") } return t.apply(this, arguments) } } function Wa(e) { typeof e != "object" || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } const yi = Object.freeze(Object.defineProperty({ __proto__: null, shimLocalStreamsAPI: Ua, shimRemoteStreamsAPI: za, shimCallbacksAPI: $a, shimGetUserMedia: Ga, shimConstraints: Ja, shimRTCIceServerUrls: Va, shimTrackEventTransceiver: Ha, shimCreateOfferLegacy: qa, shimAudioContext: Wa }, Symbol.toStringTag, { value: "Module" })); function ar(e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (n) { if (typeof n == "object" && n.candidate && n.candidate.indexOf("a=") === 0 && (n = JSON.parse(JSON.stringify(n)), n.candidate = n.candidate.substr(2)), n.candidate && n.candidate.length) { const i = new t(n), a = ir.parseCandidate(n.candidate), o = Object.assign(i, a); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(n) }, e.RTCIceCandidate.prototype = t.prototype, dt(e, "icecandidate", r => (r.candidate && Object.defineProperty(r, "candidate", { value: new e.RTCIceCandidate(r.candidate), writable: "false" }), r)) } function _t(e, t) { if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp } }); const r = function (u) { if (!u || !u.sdp) return !1; const s = ir.splitSections(u.sdp); return s.shift(), s.some(c => { const l = ir.parseMLine(c); return l && l.kind === "application" && l.protocol.indexOf("SCTP") !== -1 }) }, n = function (u) { const s = u.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (s === null || s.length < 2) return -1; const c = parseInt(s[1], 10); return c !== c ? -1 : c }, i = function (u) { let s = 65536; return t.browser === "firefox" && (t.version < 57 ? u === -1 ? s = 16384 : s = 2147483637 : t.version < 60 ? s = t.version === 57 ? 65535 : 65536 : s = 2147483637), s }, a = function (u, s) { let c = 65536; t.browser === "firefox" && t.version === 57 && (c = 65535); const l = ir.matchPrefix(u.sdp, "a=max-message-size:"); return l.length > 0 ? c = parseInt(l[0].substr(19), 10) : t.browser === "firefox" && s !== -1 && (c = 2147483637), c }, o = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, t.browser === "chrome" && t.version >= 76) { const { sdpSemantics: s } = this.getConfiguration(); s === "plan-b" && Object.defineProperty(this, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (r(arguments[0])) { const s = n(arguments[0]), c = i(s), l = a(arguments[0], s); let f; c === 0 && l === 0 ? f = Number.POSITIVE_INFINITY : c === 0 || l === 0 ? f = Math.max(c, l) : f = Math.min(c, l); const p = {}; Object.defineProperty(p, "maxMessageSize", { get() { return f } }), this._sctp = p } return o.apply(this, arguments) } } function Ct(e) { if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return; function t(n, i) { const a = n.send; n.send = function () { const u = arguments[0], s = u.length || u.size || u.byteLength; if (n.readyState === "open" && i.sctp && s > i.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + i.sctp.maxMessageSize + " bytes)"); return a.apply(n, arguments) } } const r = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const i = r.apply(this, arguments); return t(i, this), i }, dt(e, "datachannel", n => (t(n.channel, n.target), n)) } function vn(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(r) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), r && this.addEventListener("connectionstatechange", this._onconnectionstatechange = r) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach(r => { const n = t[r]; t[r] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = i => { const a = i.target; if (a._lastConnectionState !== a.connectionState) { a._lastConnectionState = a.connectionState; const o = new Event("connectionstatechange", i); a.dispatchEvent(o) } return i }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } }) } function yn(e, t) {
    if (!e.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605) return; const r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (i) {
        if (i && i.sdp && i.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
            const a = i.sdp.split(`
`).filter(o => o.trim() !== "a=extmap-allow-mixed").join(`
`); e.RTCSessionDescription && i instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: i.type, sdp: a }) : i.sdp = a
        } return r.apply(this, arguments)
    }
} function or(e, t) { if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype)) return; const r = e.RTCPeerConnection.prototype.addIceCandidate; !r || r.length === 0 || (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } const Tc = Object.freeze(Object.defineProperty({ __proto__: null, shimRTCIceCandidate: ar, shimMaxMessageSize: _t, shimSendThrowTypeError: Ct, shimConnectionState: vn, removeExtmapAllowMixed: yn, shimAddIceCandidateNullOrEmpty: or }, Symbol.toStringTag, { value: "Module" })); function kc({ window: e } = {}, t = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }) { const r = Nn, n = vc(e), i = { browserDetails: n, commonShim: Tc, extractVersion: bt, disableLog: hc, disableWarnings: mc }; switch (n.browser) { case "chrome": if (!pi || !dn || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), i; if (n.version === null) return r("Chrome shim can not determine version, not shimming."), i; r("adapter.js shimming chrome."), i.browserShim = pi, or(e, n), ba(e, n), _a(e), dn(e, n), Ca(e), Ra(e, n), Sa(e), Ta(e), ka(e), Ea(e, n), ar(e), vn(e), _t(e, n), Ct(e), yn(e, n); break; case "firefox": if (!vi || !mn || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), i; r("adapter.js shimming firefox."), i.browserShim = vi, or(e, n), Oa(e, n), mn(e, n), Aa(e), ja(e), Ia(e), Ma(e), Ba(e), Fa(e), Ka(e), Na(e), La(e), ar(e), vn(e), _t(e, n), Ct(e); break; case "edge": if (!mi || !hn || !t.shimEdge) return r("MS edge shim is not included in this adapter release."), i; r("adapter.js shimming edge."), i.browserShim = mi, xa(e), Da(e), hn(e, n), wa(e), _t(e, n), Ct(e); break; case "safari": if (!yi || !t.shimSafari) return r("Safari shim is not included in this adapter release."), i; r("adapter.js shimming safari."), i.browserShim = yi, or(e, n), Va(e), qa(e), $a(e), Ua(e), za(e), Ha(e), Ga(e), Wa(e), ar(e), _t(e, n), Ct(e), yn(e, n); break; default: r("Unsupported browser!"); break }return i } const gi = kc({ window: typeof window > "u" ? void 0 : window }); function ke(e, t, r, n) { Object.defineProperty(e, t, { get: r, set: n, enumerable: !0, configurable: !0 }) } var Lr = gi.default || gi, mt = new (function () {
    function e() { this.isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform), this.supportedBrowsers = ["firefox", "chrome", "safari"], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605 } return e.prototype.isWebRTCSupported = function () { return typeof RTCPeerConnection < "u" }, e.prototype.isBrowserSupported = function () { var t = this.getBrowser(), r = this.getVersion(), n = this.supportedBrowsers.includes(t); return n ? t === "chrome" ? r >= this.minChromeVersion : t === "firefox" ? r >= this.minFirefoxVersion : t === "safari" ? !this.isIOS && r >= this.minSafariVersion : !1 : !1 }, e.prototype.getBrowser = function () { return Lr.browserDetails.browser }, e.prototype.getVersion = function () { return Lr.browserDetails.version || 0 }, e.prototype.isUnifiedPlanSupported = function () { var t = this.getBrowser(), r = Lr.browserDetails.version || 0; if (t === "chrome" && r < this.minChromeVersion) return !1; if (t === "firefox" && r >= this.minFirefoxVersion) return !0; if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1; var n, i = !1; try { n = new RTCPeerConnection, n.addTransceiver("audio"), i = !0 } catch { } finally { n && n.close() } return i }, e.prototype.toString = function () {
        return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported())
    }, e
}()), bi = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: ["turn:eu-0.turn.peerjs.com:3478", "turn:us-0.turn.peerjs.com:3478"], username: "peerjs", credential: "peerjsp" }], sdpSemantics: "unified-plan" }, Pc = function () { function e() { this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = { Chrome: 1, chrome: 1 }, this.chunkedMTU = 16300, this.defaultConfig = bi, this.browser = mt.getBrowser(), this.browserVersion = mt.getVersion(), this.supports = function () { var t = { browser: mt.isBrowserSupported(), webRTC: mt.isWebRTCSupported(), audioVideo: !1, data: !1, binaryBlob: !1, reliable: !1 }; if (!t.webRTC) return t; var r; try { r = new RTCPeerConnection(bi), t.audioVideo = !0; var n = void 0; try { n = r.createDataChannel("_PEERJSTEST", { ordered: !0 }), t.data = !0, t.reliable = !!n.ordered; try { n.binaryType = "blob", t.binaryBlob = !mt.isIOS } catch { } } catch { } finally { n && n.close() } } catch { } finally { r && r.close() } return t }(), this.pack = ci.pack, this.unpack = ci.unpack, this._dataCount = 1 } return e.prototype.noop = function () { }, e.prototype.validateId = function (t) { return !t || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(t) }, e.prototype.chunk = function (t) { for (var r = [], n = t.size, i = Math.ceil(n / L.chunkedMTU), a = 0, o = 0; o < n;) { var u = Math.min(n, o + L.chunkedMTU), s = t.slice(o, u), c = { __peerData: this._dataCount, n: a, data: s, total: i }; r.push(c), o = u, a++ } return this._dataCount++, r }, e.prototype.blobToArrayBuffer = function (t, r) { var n = new FileReader; return n.onload = function (i) { i.target && r(i.target.result) }, n.readAsArrayBuffer(t), n }, e.prototype.binaryStringToArrayBuffer = function (t) { for (var r = new Uint8Array(t.length), n = 0; n < t.length; n++)r[n] = t.charCodeAt(n) & 255; return r.buffer }, e.prototype.randomToken = function () { return Math.random().toString(36).slice(2) }, e.prototype.isSecure = function () { return location.protocol === "https:" }, e }(), L = new Pc, Ya = {}; ke(Ya, "Peer", () => wi, e => wi = e); var Lt = {}, Rc = Object.prototype.hasOwnProperty, le = "~"; function It() { } Object.create && (It.prototype = Object.create(null), new It().__proto__ || (le = !1)); function Ec(e, t, r) { this.fn = e, this.context = t, this.once = r || !1 } function Xa(e, t, r, n, i) { if (typeof r != "function") throw new TypeError("The listener must be a function"); var a = new Ec(r, n || e, i), o = le ? le + t : t; return e._events[o] ? e._events[o].fn ? e._events[o] = [e._events[o], a] : e._events[o].push(a) : (e._events[o] = a, e._eventsCount++), e } function sr(e, t) { --e._eventsCount === 0 ? e._events = new It : delete e._events[t] } function oe() { this._events = new It, this._eventsCount = 0 } oe.prototype.eventNames = function () { var t = [], r, n; if (this._eventsCount === 0) return t; for (n in r = this._events) Rc.call(r, n) && t.push(le ? n.slice(1) : n); return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(r)) : t }; oe.prototype.listeners = function (t) { var r = le ? le + t : t, n = this._events[r]; if (!n) return []; if (n.fn) return [n.fn]; for (var i = 0, a = n.length, o = new Array(a); i < a; i++)o[i] = n[i].fn; return o }; oe.prototype.listenerCount = function (t) { var r = le ? le + t : t, n = this._events[r]; return n ? n.fn ? 1 : n.length : 0 }; oe.prototype.emit = function (t, r, n, i, a, o) { var u = le ? le + t : t; if (!this._events[u]) return !1; var s = this._events[u], c = arguments.length, l, f; if (s.fn) { switch (s.once && this.removeListener(t, s.fn, void 0, !0), c) { case 1: return s.fn.call(s.context), !0; case 2: return s.fn.call(s.context, r), !0; case 3: return s.fn.call(s.context, r, n), !0; case 4: return s.fn.call(s.context, r, n, i), !0; case 5: return s.fn.call(s.context, r, n, i, a), !0; case 6: return s.fn.call(s.context, r, n, i, a, o), !0 }for (f = 1, l = new Array(c - 1); f < c; f++)l[f - 1] = arguments[f]; s.fn.apply(s.context, l) } else { var p = s.length, m; for (f = 0; f < p; f++)switch (s[f].once && this.removeListener(t, s[f].fn, void 0, !0), c) { case 1: s[f].fn.call(s[f].context); break; case 2: s[f].fn.call(s[f].context, r); break; case 3: s[f].fn.call(s[f].context, r, n); break; case 4: s[f].fn.call(s[f].context, r, n, i); break; default: if (!l) for (m = 1, l = new Array(c - 1); m < c; m++)l[m - 1] = arguments[m]; s[f].fn.apply(s[f].context, l) } } return !0 }; oe.prototype.on = function (t, r, n) { return Xa(this, t, r, n, !1) }; oe.prototype.once = function (t, r, n) { return Xa(this, t, r, n, !0) }; oe.prototype.removeListener = function (t, r, n, i) { var a = le ? le + t : t; if (!this._events[a]) return this; if (!r) return sr(this, a), this; var o = this._events[a]; if (o.fn) o.fn === r && (!i || o.once) && (!n || o.context === n) && sr(this, a); else { for (var u = 0, s = [], c = o.length; u < c; u++)(o[u].fn !== r || i && !o[u].once || n && o[u].context !== n) && s.push(o[u]); s.length ? this._events[a] = s.length === 1 ? s[0] : s : sr(this, a) } return this }; oe.prototype.removeAllListeners = function (t) { var r; return t ? (r = le ? le + t : t, this._events[r] && sr(this, r)) : (this._events = new It, this._eventsCount = 0), this }; oe.prototype.off = oe.prototype.removeListener; oe.prototype.addListener = oe.prototype.on; oe.prefixed = le; oe.EventEmitter = oe; Lt = oe; var x = {}; ke(x, "LogLevel", () => pe, e => pe = e); ke(x, "default", () => _i, e => _i = e); var Ge = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Je = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, xc = "PeerJS: ", pe; (function (e) { e[e.Disabled = 0] = "Disabled", e[e.Errors = 1] = "Errors", e[e.Warnings = 2] = "Warnings", e[e.All = 3] = "All" })(pe || (pe = {})); var Dc = function () { function e() { this._logLevel = pe.Disabled } return Object.defineProperty(e.prototype, "logLevel", { get: function () { return this._logLevel }, set: function (t) { this._logLevel = t }, enumerable: !1, configurable: !0 }), e.prototype.log = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= pe.All && this._print.apply(this, Je([pe.All], Ge(t), !1)) }, e.prototype.warn = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= pe.Warnings && this._print.apply(this, Je([pe.Warnings], Ge(t), !1)) }, e.prototype.error = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= pe.Errors && this._print.apply(this, Je([pe.Errors], Ge(t), !1)) }, e.prototype.setLogFunction = function (t) { this._print = t }, e.prototype._print = function (t) { for (var r = [], n = 1; n < arguments.length; n++)r[n - 1] = arguments[n]; var i = Je([xc], Ge(r), !1); for (var a in i) i[a] instanceof Error && (i[a] = "(" + i[a].name + ") " + i[a].message); t >= pe.All ? console.log.apply(console, Je([], Ge(i), !1)) : t >= pe.Warnings ? console.warn.apply(console, Je(["WARNING"], Ge(i), !1)) : t >= pe.Errors && console.error.apply(console, Je(["ERROR"], Ge(i), !1)) }, e }(), _i = new Dc, Qa = {}; ke(Qa, "Socket", () => Ci, e => Ci = e); var _e; (function (e) { e.Data = "data", e.Media = "media" })(_e || (_e = {})); var J; (function (e) { e.BrowserIncompatible = "browser-incompatible", e.Disconnected = "disconnected", e.InvalidID = "invalid-id", e.InvalidKey = "invalid-key", e.Network = "network", e.PeerUnavailable = "peer-unavailable", e.SslUnavailable = "ssl-unavailable", e.ServerError = "server-error", e.SocketError = "socket-error", e.SocketClosed = "socket-closed", e.UnavailableID = "unavailable-id", e.WebRTC = "webrtc" })(J || (J = {})); var Re; (function (e) { e.Binary = "binary", e.BinaryUTF8 = "binary-utf8", e.JSON = "json" })(Re || (Re = {})); var we; (function (e) { e.Message = "message", e.Disconnected = "disconnected", e.Error = "error", e.Close = "close" })(we || (we = {})); var Q; (function (e) { e.Heartbeat = "HEARTBEAT", e.Candidate = "CANDIDATE", e.Offer = "OFFER", e.Answer = "ANSWER", e.Open = "OPEN", e.Error = "ERROR", e.IdTaken = "ID-TAKEN", e.InvalidKey = "INVALID-KEY", e.Leave = "LEAVE", e.Expire = "EXPIRE" })(Q || (Q = {})); var Un = {}; Un = JSON.parse('{"name":"peerjs","version":"1.4.6","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xFCckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"type":"module","sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.cjs","browser-unminified":"dist/peerjs.cjs","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"includeNodeModules":true,"context":"browser","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"includeNodeModules":true,"context":"browser","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build && cp dist/peerjs.cjs dist/peerjs.js && cp dist/peerjs.min.cjs dist/peerjs.min.js","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}'); var wc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Oc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Ac = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, Ic = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Ci = function (e) { wc(t, e); function t(r, n, i, a, o, u) { u === void 0 && (u = 5e3); var s = e.call(this) || this; s.pingInterval = u, s._disconnected = !0, s._messagesQueue = []; var c = r ? "wss://" : "ws://"; return s._baseUrl = c + n + ":" + i + a + "peerjs?key=" + o, s } return t.prototype.start = function (r, n) { var i = this; this._id = r; var a = "".concat(this._baseUrl, "&id=").concat(r, "&token=").concat(n); !!this._socket || !this._disconnected || (this._socket = new WebSocket(a + "&version=" + Un.version), this._disconnected = !1, this._socket.onmessage = function (o) { var u; try { u = JSON.parse(o.data), x.default.log("Server message received:", u) } catch { x.default.log("Invalid server message", o.data); return } i.emit(we.Message, u) }, this._socket.onclose = function (o) { i._disconnected || (x.default.log("Socket closed.", o), i._cleanup(), i._disconnected = !0, i.emit(we.Disconnected)) }, this._socket.onopen = function () { i._disconnected || (i._sendQueuedMessages(), x.default.log("Socket open"), i._scheduleHeartbeat()) }) }, t.prototype._scheduleHeartbeat = function () { var r = this; this._wsPingTimer = setTimeout(function () { r._sendHeartbeat() }, this.pingInterval) }, t.prototype._sendHeartbeat = function () { if (!this._wsOpen()) { x.default.log("Cannot send heartbeat, because socket closed"); return } var r = JSON.stringify({ type: Q.Heartbeat }); this._socket.send(r), this._scheduleHeartbeat() }, t.prototype._wsOpen = function () { return !!this._socket && this._socket.readyState === 1 }, t.prototype._sendQueuedMessages = function () { var r, n, i = Ac([], Oc(this._messagesQueue), !1); this._messagesQueue = []; try { for (var a = Ic(i), o = a.next(); !o.done; o = a.next()) { var u = o.value; this.send(u) } } catch (s) { r = { error: s } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } }, t.prototype.send = function (r) { if (!this._disconnected) { if (!this._id) { this._messagesQueue.push(r); return } if (!r.type) { this.emit(we.Error, "Invalid message"); return } if (!!this._wsOpen()) { var n = JSON.stringify(r); this._socket.send(n) } } }, t.prototype.close = function () { this._disconnected || (this._cleanup(), this._disconnected = !0) }, t.prototype._cleanup = function () { this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer) }, t }(Lt.EventEmitter), gn = {}; ke(gn, "MediaConnection", () => ki, e => ki = e); var zn = {}; ke(zn, "Negotiator", () => Si, e => Si = e); var br = function () { return br = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, br.apply(this, arguments) }, qt = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(l) { try { c(n.next(l)) } catch (f) { o(f) } } function s(l) { try { c(n.throw(l)) } catch (f) { o(f) } } function c(l) { l.done ? a(l.value) : i(l.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, Wt = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (l) { return s([c, l]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (l) { c = [6, l], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, Si = function () { function e(t) { this.connection = t } return e.prototype.startConnection = function (t) { var r = this._startPeerConnection(); if (this.connection.peerConnection = r, this.connection.type === _e.Media && t._stream && this._addTracksToConnection(t._stream, r), t.originator) { if (this.connection.type === _e.Data) { var n = this.connection, i = { ordered: !!t.reliable }, a = r.createDataChannel(n.label, i); n.initialize(a) } this._makeOffer() } else this.handleSDP("OFFER", t.sdp) }, e.prototype._startPeerConnection = function () { x.default.log("Creating RTCPeerConnection."); var t = new RTCPeerConnection(this.connection.provider.options.config); return this._setupListeners(t), t }, e.prototype._setupListeners = function (t) { var r = this, n = this.connection.peer, i = this.connection.connectionId, a = this.connection.type, o = this.connection.provider; x.default.log("Listening for ICE candidates."), t.onicecandidate = function (u) { !u.candidate || !u.candidate.candidate || (x.default.log("Received ICE candidates for ".concat(n, ":"), u.candidate), o.socket.send({ type: Q.Candidate, payload: { candidate: u.candidate, type: a, connectionId: i }, dst: n })) }, t.oniceconnectionstatechange = function () { switch (t.iceConnectionState) { case "failed": x.default.log("iceConnectionState is failed, closing connections to " + n), r.connection.emit("error", new Error("Negotiation of connection to " + n + " failed.")), r.connection.close(); break; case "closed": x.default.log("iceConnectionState is closed, closing connections to " + n), r.connection.emit("error", new Error("Connection to " + n + " closed.")), r.connection.close(); break; case "disconnected": x.default.log("iceConnectionState changed to disconnected on the connection with " + n); break; case "completed": t.onicecandidate = L.noop; break }r.connection.emit("iceStateChanged", t.iceConnectionState) }, x.default.log("Listening for data channel"), t.ondatachannel = function (u) { x.default.log("Received data channel"); var s = u.channel, c = o.getConnection(n, i); c.initialize(s) }, x.default.log("Listening for remote stream"), t.ontrack = function (u) { x.default.log("Received remote stream"); var s = u.streams[0], c = o.getConnection(n, i); if (c.type === _e.Media) { var l = c; r._addStreamToMediaConnection(s, l) } } }, e.prototype.cleanup = function () { x.default.log("Cleaning up PeerConnection to " + this.connection.peer); var t = this.connection.peerConnection; if (!!t) { this.connection.peerConnection = null, t.onicecandidate = t.oniceconnectionstatechange = t.ondatachannel = t.ontrack = function () { }; var r = t.signalingState !== "closed", n = !1; if (this.connection.type === _e.Data) { var i = this.connection, a = i.dataChannel; a && (n = !!a.readyState && a.readyState !== "closed") } (r || n) && t.close() } }, e.prototype._makeOffer = function () { return qt(this, void 0, Promise, function () { var t, r, n, i, a, o, u; return Wt(this, function (s) { switch (s.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 7, , 8]), [4, t.createOffer(this.connection.options.constraints)]; case 2: n = s.sent(), x.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), s.label = 3; case 3: return s.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return s.sent(), x.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), i = { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, metadata: this.connection.metadata, browser: L.browser }, this.connection.type === _e.Data && (a = this.connection, i = br(br({}, i), { label: a.label, reliable: a.reliable, serialization: a.serialization })), r.socket.send({ type: Q.Offer, payload: i, dst: this.connection.peer }), [3, 6]; case 5: return o = s.sent(), o != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (r.emitError(J.WebRTC, o), x.default.log("Failed to setLocalDescription, ", o)), [3, 6]; case 6: return [3, 8]; case 7: return u = s.sent(), r.emitError(J.WebRTC, u), x.default.log("Failed to createOffer, ", u), [3, 8]; case 8: return [2] } }) }) }, e.prototype._makeAnswer = function () { return qt(this, void 0, Promise, function () { var t, r, n, i, a; return Wt(this, function (o) { switch (o.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, o.label = 1; case 1: return o.trys.push([1, 7, , 8]), [4, t.createAnswer()]; case 2: n = o.sent(), x.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), o.label = 3; case 3: return o.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return o.sent(), x.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), r.socket.send({ type: Q.Answer, payload: { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, browser: L.browser }, dst: this.connection.peer }), [3, 6]; case 5: return i = o.sent(), r.emitError(J.WebRTC, i), x.default.log("Failed to setLocalDescription, ", i), [3, 6]; case 6: return [3, 8]; case 7: return a = o.sent(), r.emitError(J.WebRTC, a), x.default.log("Failed to create answer, ", a), [3, 8]; case 8: return [2] } }) }) }, e.prototype.handleSDP = function (t, r) { return qt(this, void 0, Promise, function () { var n, i, a, o; return Wt(this, function (u) { switch (u.label) { case 0: r = new RTCSessionDescription(r), n = this.connection.peerConnection, i = this.connection.provider, x.default.log("Setting remote description", r), a = this, u.label = 1; case 1: return u.trys.push([1, 5, , 6]), [4, n.setRemoteDescription(r)]; case 2: return u.sent(), x.default.log("Set remoteDescription:".concat(t, " for:").concat(this.connection.peer)), t !== "OFFER" ? [3, 4] : [4, a._makeAnswer()]; case 3: u.sent(), u.label = 4; case 4: return [3, 6]; case 5: return o = u.sent(), i.emitError(J.WebRTC, o), x.default.log("Failed to setRemoteDescription, ", o), [3, 6]; case 6: return [2] } }) }) }, e.prototype.handleCandidate = function (t) { return qt(this, void 0, Promise, function () { var r, n, i, a, o, u; return Wt(this, function (s) { switch (s.label) { case 0: x.default.log("handleCandidate:", t), r = t.candidate, n = t.sdpMLineIndex, i = t.sdpMid, a = this.connection.peerConnection, o = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 3, , 4]), [4, a.addIceCandidate(new RTCIceCandidate({ sdpMid: i, sdpMLineIndex: n, candidate: r }))]; case 2: return s.sent(), x.default.log("Added ICE candidate for:".concat(this.connection.peer)), [3, 4]; case 3: return u = s.sent(), o.emitError(J.WebRTC, u), x.default.log("Failed to handleCandidate, ", u), [3, 4]; case 4: return [2] } }) }) }, e.prototype._addTracksToConnection = function (t, r) { if (x.default.log("add tracks from stream ".concat(t.id, " to peer connection")), !r.addTrack) return x.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored."); t.getTracks().forEach(function (n) { r.addTrack(n, t) }) }, e.prototype._addStreamToMediaConnection = function (t, r) { x.default.log("add stream ".concat(t.id, " to media connection ").concat(r.connectionId)), r.addStream(t) }, e }(), $n = {}; ke($n, "BaseConnection", () => Ti, e => Ti = e); var Mc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Ti = function (e) { Mc(t, e); function t(r, n, i) { var a = e.call(this) || this; return a.peer = r, a.provider = n, a.options = i, a._open = !1, a.metadata = i.metadata, a } return Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), t }(Lt.EventEmitter), jc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), _r = function () { return _r = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, _r.apply(this, arguments) }, Bc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, ki = function (e) { jc(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a._localStream = a.options._stream, a.connectionId = a.options.connectionId || t.ID_PREFIX + L.randomToken(), a._negotiator = new zn.Negotiator(a), a._localStream && a._negotiator.startConnection({ _stream: a._localStream, originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return _e.Media }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "localStream", { get: function () { return this._localStream }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "remoteStream", { get: function () { return this._remoteStream }, enumerable: !1, configurable: !0 }), t.prototype.addStream = function (r) { x.default.log("Receiving stream", r), this._remoteStream = r, e.prototype.emit.call(this, "stream", r) }, t.prototype.handleMessage = function (r) { var n = r.type, i = r.payload; switch (r.type) { case Q.Answer: this._negotiator.handleSDP(n, i.sdp), this._open = !0; break; case Q.Candidate: this._negotiator.handleCandidate(i.candidate); break; default: x.default.warn("Unrecognized message type:".concat(n, " from peer:").concat(this.peer)); break } }, t.prototype.answer = function (r, n) { var i, a; if (n === void 0 && (n = {}), this._localStream) { x.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?"); return } this._localStream = r, n && n.sdpTransform && (this.options.sdpTransform = n.sdpTransform), this._negotiator.startConnection(_r(_r({}, this.options._payload), { _stream: r })); var o = this.provider._getMessages(this.connectionId); try { for (var u = Bc(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; this.handleMessage(c) } } catch (l) { i = { error: l } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } this._open = !0 }, t.prototype.close = function () { this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.ID_PREFIX = "mc_", t }($n.BaseConnection), bn = {}; ke(bn, "DataConnection", () => Ri, e => Ri = e); var Za = {}; ke(Za, "EncodingQueue", () => Pi, e => Pi = e); var Fc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Pi = function (e) { Fc(t, e); function t() { var r = e.call(this) || this; return r.fileReader = new FileReader, r._queue = [], r._processing = !1, r.fileReader.onload = function (n) { r._processing = !1, n.target && r.emit("done", n.target.result), r.doNextTask() }, r.fileReader.onerror = function (n) { x.default.error("EncodingQueue error:", n), r._processing = !1, r.destroy(), r.emit("error", n) }, r } return Object.defineProperty(t.prototype, "queue", { get: function () { return this._queue }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "size", { get: function () { return this.queue.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "processing", { get: function () { return this._processing }, enumerable: !1, configurable: !0 }), t.prototype.enque = function (r) { this.queue.push(r), !this.processing && this.doNextTask() }, t.prototype.destroy = function () { this.fileReader.abort(), this._queue = [] }, t.prototype.doNextTask = function () { this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift()))) }, t }(Lt.EventEmitter), Kc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Nc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Ri = function (e) { Kc(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a.stringify = JSON.stringify, a.parse = JSON.parse, a._buffer = [], a._bufferSize = 0, a._buffering = !1, a._chunkedData = {}, a._encodingQueue = new Za.EncodingQueue, a.connectionId = a.options.connectionId || t.ID_PREFIX + L.randomToken(), a.label = a.options.label || a.connectionId, a.serialization = a.options.serialization || Re.Binary, a.reliable = !!a.options.reliable, a._encodingQueue.on("done", function (o) { a._bufferedSend(o) }), a._encodingQueue.on("error", function () { x.default.error("DC#".concat(a.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), a.close() }), a._negotiator = new zn.Negotiator(a), a._negotiator.startConnection(a.options._payload || { originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return _e.Data }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dataChannel", { get: function () { return this._dc }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "bufferSize", { get: function () { return this._bufferSize }, enumerable: !1, configurable: !0 }), t.prototype.initialize = function (r) { this._dc = r, this._configureDataChannel() }, t.prototype._configureDataChannel = function () { var r = this; (!L.supports.binaryBlob || L.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function () { x.default.log("DC#".concat(r.connectionId, " dc connection success")), r._open = !0, r.emit("open") }, this.dataChannel.onmessage = function (n) { x.default.log("DC#".concat(r.connectionId, " dc onmessage:"), n.data), r._handleDataMessage(n) }, this.dataChannel.onclose = function () { x.default.log("DC#".concat(r.connectionId, " dc closed for:"), r.peer), r.close() } }, t.prototype._handleDataMessage = function (r) { var n = this, i = r.data, a = i.constructor, o = this.serialization === Re.Binary || this.serialization === Re.BinaryUTF8, u = i; if (o) { if (a === Blob) { L.blobToArrayBuffer(i, function (c) { var l = L.unpack(c); n.emit("data", l) }); return } else if (a === ArrayBuffer) u = L.unpack(i); else if (a === String) { var s = L.binaryStringToArrayBuffer(i); u = L.unpack(s) } } else this.serialization === Re.JSON && (u = this.parse(i)); if (u.__peerData) { this._handleChunk(u); return } e.prototype.emit.call(this, "data", u) }, t.prototype._handleChunk = function (r) { var n = r.__peerData, i = this._chunkedData[n] || { data: [], count: 0, total: r.total }; if (i.data[r.n] = r.data, i.count++, this._chunkedData[n] = i, i.total === i.count) { delete this._chunkedData[n]; var a = new Blob(i.data); this._handleDataMessage({ data: a }) } }, t.prototype.close = function () { this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.prototype.send = function (r, n) { if (!this.open) { e.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages.")); return } if (this.serialization === Re.JSON) this._bufferedSend(this.stringify(r)); else if (this.serialization === Re.Binary || this.serialization === Re.BinaryUTF8) { var i = L.pack(r); if (!n && i.size > L.chunkedMTU) { this._sendChunks(i); return } L.supports.binaryBlob ? this._bufferedSend(i) : this._encodingQueue.enque(i) } else this._bufferedSend(r) }, t.prototype._bufferedSend = function (r) { (this._buffering || !this._trySend(r)) && (this._buffer.push(r), this._bufferSize = this._buffer.length) }, t.prototype._trySend = function (r) { var n = this; if (!this.open) return !1; if (this.dataChannel.bufferedAmount > t.MAX_BUFFERED_AMOUNT) return this._buffering = !0, setTimeout(function () { n._buffering = !1, n._tryBuffer() }, 50), !1; try { this.dataChannel.send(r) } catch (i) { return x.default.error("DC#:".concat(this.connectionId, " Error when sending:"), i), this._buffering = !0, this.close(), !1 } return !0 }, t.prototype._tryBuffer = function () { if (!!this.open && this._buffer.length !== 0) { var r = this._buffer[0]; this._trySend(r) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer()) } }, t.prototype._sendChunks = function (r) { var n, i, a = L.chunk(r); x.default.log("DC#".concat(this.connectionId, " Try to send ").concat(a.length, " chunks...")); try { for (var o = Nc(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; this.send(s, !0) } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.handleMessage = function (r) { var n = r.payload; switch (r.type) { case Q.Answer: this._negotiator.handleSDP(r.type, n.sdp); break; case Q.Candidate: this._negotiator.handleCandidate(n.candidate); break; default: x.default.warn("Unrecognized message type:", r.type, "from peer:", this.peer); break } }, t.ID_PREFIX = "dc_", t.MAX_BUFFERED_AMOUNT = 8388608, t }($n.BaseConnection), eo = {}; ke(eo, "API", () => Di, e => Di = e); var Ei = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(l) { try { c(n.next(l)) } catch (f) { o(f) } } function s(l) { try { c(n.throw(l)) } catch (f) { o(f) } } function c(l) { l.done ? a(l.value) : i(l.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, xi = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (l) { return s([c, l]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (l) { c = [6, l], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, Di = function () { function e(t) { this._options = t } return e.prototype._buildRequest = function (t) { var r = this._options.secure ? "https" : "http", n = this._options, i = n.host, a = n.port, o = n.path, u = n.key, s = new URL("".concat(r, "://").concat(i, ":").concat(a).concat(o).concat(u, "/").concat(t)); return s.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), s.searchParams.set("version", Un.version), fetch(s.href, { referrerPolicy: this._options.referrerPolicy }) }, e.prototype.retrieveId = function () { return Ei(this, void 0, Promise, function () { var t, r, n; return xi(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("id")]; case 1: if (t = i.sent(), t.status !== 200) throw new Error("Error. Status:".concat(t.status)); return [2, t.text()]; case 2: throw r = i.sent(), x.default.error("Error retrieving ID", r), n = "", this._options.path === "/" && this._options.host !== L.CLOUD_HOST && (n = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + n); case 3: return [2] } }) }) }, e.prototype.listAllPeers = function () { return Ei(this, void 0, Promise, function () { var t, r, n; return xi(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("peers")]; case 1: if (t = i.sent(), t.status !== 200) throw t.status === 401 ? (r = "", this._options.host === L.CLOUD_HOST ? r = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : r = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + r)) : new Error("Error. Status:".concat(t.status)); return [2, t.json()]; case 2: throw n = i.sent(), x.default.error("Error retrieving list peers", n), new Error("Could not get list peers from the server." + n); case 3: return [2] } }) }) }, e }(), Lc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Pt = function () { return Pt = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, Pt.apply(this, arguments) }, vt = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Uc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, wi = function (e) { Lc(t, e); function t(r, n) { var i = e.call(this) || this; i._id = null, i._lastServerId = null, i._destroyed = !1, i._disconnected = !1, i._open = !1, i._connections = new Map, i._lostMessages = new Map; var a; return r && r.constructor == Object ? n = r : r && (a = r.toString()), n = Pt({ debug: 0, host: L.CLOUD_HOST, port: L.CLOUD_PORT, path: "/", key: t.DEFAULT_KEY, token: L.randomToken(), config: L.defaultConfig, referrerPolicy: "strict-origin-when-cross-origin" }, n), i._options = n, i._options.host === "/" && (i._options.host = window.location.hostname), i._options.path && (i._options.path[0] !== "/" && (i._options.path = "/" + i._options.path), i._options.path[i._options.path.length - 1] !== "/" && (i._options.path += "/")), i._options.secure === void 0 && i._options.host !== L.CLOUD_HOST ? i._options.secure = L.isSecure() : i._options.host == L.CLOUD_HOST && (i._options.secure = !0), i._options.logFunction && x.default.setLogFunction(i._options.logFunction), x.default.logLevel = i._options.debug || 0, i._api = new eo.API(n), i._socket = i._createServerConnection(), !L.supports.audioVideo && !L.supports.data ? (i._delayedAbort(J.BrowserIncompatible, "The current browser does not support WebRTC"), i) : !!a && !L.validateId(a) ? (i._delayedAbort(J.InvalidID, 'ID "'.concat(a, '" is invalid')), i) : (a ? i._initialize(a) : i._api.retrieveId().then(function (o) { return i._initialize(o) }).catch(function (o) { return i._abort(J.ServerError, o) }), i) } return Object.defineProperty(t.prototype, "id", { get: function () { return this._id }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "options", { get: function () { return this._options }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "socket", { get: function () { return this._socket }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "connections", { get: function () { var r, n, i = Object.create(null); try { for (var a = vt(this._connections), o = a.next(); !o.done; o = a.next()) { var u = Uc(o.value, 2), s = u[0], c = u[1]; i[s] = c } } catch (l) { r = { error: l } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } return i }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "destroyed", { get: function () { return this._destroyed }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "disconnected", { get: function () { return this._disconnected }, enumerable: !1, configurable: !0 }), t.prototype._createServerConnection = function () { var r = this, n = new Qa.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval); return n.on(we.Message, function (i) { r._handleMessage(i) }), n.on(we.Error, function (i) { r._abort(J.SocketError, i) }), n.on(we.Disconnected, function () { r.disconnected || (r.emitError(J.Network, "Lost connection to server."), r.disconnect()) }), n.on(we.Close, function () { r.disconnected || r._abort(J.SocketClosed, "Underlying socket is already closed.") }), n }, t.prototype._initialize = function (r) { this._id = r, this.socket.start(r, this._options.token) }, t.prototype._handleMessage = function (r) { var n, i, a = r.type, o = r.payload, u = r.src; switch (a) { case Q.Open: this._lastServerId = this.id, this._open = !0, this.emit("open", this.id); break; case Q.Error: this._abort(J.ServerError, o.msg); break; case Q.IdTaken: this._abort(J.UnavailableID, 'ID "'.concat(this.id, '" is taken')); break; case Q.InvalidKey: this._abort(J.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid')); break; case Q.Leave: x.default.log("Received leave message from ".concat(u)), this._cleanupPeer(u), this._connections.delete(u); break; case Q.Expire: this.emitError(J.PeerUnavailable, "Could not connect to peer ".concat(u)); break; case Q.Offer: var d = o.connectionId, h = this.getConnection(u, d); if (h && (h.close(), x.default.warn("Offer received for existing Connection ID:".concat(d))), o.type === _e.Media) { var s = new gn.MediaConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata }); h = s, this._addConnection(u, h), this.emit("call", s) } else if (o.type === _e.Data) { var c = new bn.DataConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata, label: o.label, serialization: o.serialization, reliable: o.reliable }); h = c, this._addConnection(u, h), this.emit("connection", c) } else { x.default.warn("Received malformed connection type:".concat(o.type)); return } var l = this._getMessages(d); try { for (var f = vt(l), p = f.next(); !p.done; p = f.next()) { var m = p.value; h.handleMessage(m) } } catch (b) { n = { error: b } } finally { try { p && !p.done && (i = f.return) && i.call(f) } finally { if (n) throw n.error } } break; default: if (!o) { x.default.warn("You received a malformed message from ".concat(u, " of type ").concat(a)); return } var d = o.connectionId, h = this.getConnection(u, d); h && h.peerConnection ? h.handleMessage(r) : d ? this._storeMessage(d, r) : x.default.warn("You received an unrecognized message:", r); break } }, t.prototype._storeMessage = function (r, n) { this._lostMessages.has(r) || this._lostMessages.set(r, []), this._lostMessages.get(r).push(n) }, t.prototype._getMessages = function (r) { var n = this._lostMessages.get(r); return n ? (this._lostMessages.delete(r), n) : [] }, t.prototype.connect = function (r, n) { if (n === void 0 && (n = {}), this.disconnected) { x.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } var i = new bn.DataConnection(r, this, n); return this._addConnection(r, i), i }, t.prototype.call = function (r, n, i) { if (i === void 0 && (i = {}), this.disconnected) { x.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } if (!n) { x.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`."); return } var a = new gn.MediaConnection(r, this, Pt(Pt({}, i), { _stream: n })); return this._addConnection(r, a), a }, t.prototype._addConnection = function (r, n) { x.default.log("add connection ".concat(n.type, ":").concat(n.connectionId, " to peerId:").concat(r)), this._connections.has(r) || this._connections.set(r, []), this._connections.get(r).push(n) }, t.prototype._removeConnection = function (r) { var n = this._connections.get(r.peer); if (n) { var i = n.indexOf(r); i !== -1 && n.splice(i, 1) } this._lostMessages.delete(r.connectionId) }, t.prototype.getConnection = function (r, n) { var i, a, o = this._connections.get(r); if (!o) return null; try { for (var u = vt(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; if (c.connectionId === n) return c } } catch (l) { i = { error: l } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } return null }, t.prototype._delayedAbort = function (r, n) { var i = this; setTimeout(function () { i._abort(r, n) }, 0) }, t.prototype._abort = function (r, n) { x.default.error("Aborting!"), this.emitError(r, n), this._lastServerId ? this.disconnect() : this.destroy() }, t.prototype.emitError = function (r, n) { x.default.error("Error:", n); var i; typeof n == "string" ? i = new Error(n) : i = n, i.type = r, this.emit("error", i) }, t.prototype.destroy = function () { this.destroyed || (x.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close")) }, t.prototype._cleanup = function () { var r, n; try { for (var i = vt(this._connections.keys()), a = i.next(); !a.done; a = i.next()) { var o = a.value; this._cleanupPeer(o), this._connections.delete(o) } } catch (u) { r = { error: u } } finally { try { a && !a.done && (n = i.return) && n.call(i) } finally { if (r) throw r.error } } this.socket.removeAllListeners() }, t.prototype._cleanupPeer = function (r) { var n, i, a = this._connections.get(r); if (!!a) try { for (var o = vt(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; s.close() } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.disconnect = function () { if (!this.disconnected) { var r = this.id; x.default.log("Disconnect peer with ID:".concat(r)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = r, this._id = null, this.emit("disconnected", r) } }, t.prototype.reconnect = function () { if (this.disconnected && !this.destroyed) x.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId); else { if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed."); if (!this.disconnected && !this.open) x.default.error("In a hurry? We're still trying to make the initial connection!"); else throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!")) } }, t.prototype.listAllPeers = function (r) { var n = this; r === void 0 && (r = function (i) { }), this._api.listAllPeers().then(function (i) { return r(i) }).catch(function (i) { return n._abort(J.ServerError, i) }) }, t.DEFAULT_KEY = "peerjs", t }(Lt.EventEmitter), zc = Ya.Peer; let de, V, ne, Cr, at = {}, Ae = {}, cr = {}, ot = {}, st = {}; const $c = [D.positionChanged]; OctoPrint.options.baseurl = "http://localhost:5000/"; Fs().then(async () => { let e = await j.printer.toArray(); e.length > 0 && (ne = e[0]); let t = await j.nanofactoryPeers.toArray(); if (t.length > 0 ? Cr = t[0] : Cr = new pa, V = await j.networking.get("1"), V || (V = new la("1"), await V.add()), !V.peerID || !V.apiKey) { let r = setInterval(async () => { window.peerID && !V.peerID && (V.save({ peerID: window.peerID }), V.peerID = window.peerID, ne || (ne = new da(window.peerID), ne.add())), window.apiKey && !V.apiKey && (V.save({ apiKey: window.apiKey }), V.apiKey = window.apiKey), V.peerID && V.apiKey && (clearInterval(r), Oi()) }, 1e3) } else Oi() }); async function Oi() { OctoPrint.options.apikey = V.apiKey, de = new zc(V.peerID), Gc(), await $s(), await Gs(), await Js(), await OctoPrint.socket.connect(), OctoPrint.socket.onMessage("*", e => cc(e)) } function Gc() { de.on("open", function (e) { console.log("Connected to peer server with id:" + e) }), de.on("connection", function (e) { console.log("Connected with peer:" + e.peer), e.on("data", function (t) { console.log("Received Label: " + e.label), ac(t, e.peer, e.label, e.metadata), $c.includes(e.label) || e.close() }) }), de.on("disconnected", function () { console.log("Disconnected from signaling server, reconnecting..."), de.reconnect() }), de.on("close", function () { console.log("Peer destroyed, cannot reconnect") }), de.on("error", function (e) { console.error(e) }) }
