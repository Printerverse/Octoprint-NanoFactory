var fo = Object.defineProperty; var po = (e, t, r) => t in e ? fo(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; var E = (e, t, r) => (po(e, typeof t != "symbol" ? t + "" : t, r), r); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function r(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerpolicy && (a.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? a.credentials = "include" : i.crossorigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function n(i) { if (i.ep) return; i.ep = !0; const a = r(i); fetch(i.href, a) } })(); var S = (e => (e.syncAllRequest = "1", e.syncAllResponse = "2", e.profileChanged = "3", e.positionChanged = "57", e.positionChangedResponse = "4", e.positionChangedRequest = "53", e.positionChangedStop = "54", e.cameraStreamRequest = "5", e.cameraStreamResponse = "34", e.cameraStreamStop = "44", e.temperatureStreamRequest = "6", e.temperatureStreamResponse = "35", e.temperatureStreamStop = "43", e.bedLevelingRequest = "7", e.bedLevelingResponse = "8", e.terminalRequest = "9", e.terminalResponse = "10", e.terminalStop = "42", e.filamentModified = "58", e.filamentAssigned = "11", e.filamentRemoved = "12", e.filamentModifiedResponse = "40", e.filamentModifiedRequest = "52", e.filamentModifiedStop = "55", e.jobCreated = "13", e.jobFile = "41", e.jobDone = "14", e.jobCancelled = "15", e.jobFailed = "16", e.jobDeleted = "17", e.jobPause = "25", e.jobResume = "26", e.jobPrinting = "37", e.jobFilamentModified = "30", e.currentJobUpdatesResponse = "49", e.currentJobUpdatesRequest = "51", e.currentJobUpdatesStop = "56", e.jobRankChange = "18", e.actionCreated = "19", e.actionModified = "20", e.actionExecuted = "21", e.actionDeleted = "22", e.executeCustomGcode = "23", e.emergencyStop = "24", e.connectPrinter = "27", e.disconnectPrinter = "28", e.connectionOptionsChanged = "38", e.printerStateChanged = "39", e.refreshConnectionOptions = "45", e.filamentExtrude = "46", e.targetTool = "47", e.targetBed = "48", e.handshakeRequest = "50", e.handshakeResponse = "31", e.queuePaused = "29", e.home = "59", e.peerPermissionRequest = "32", e.peerPermissionResponse = "33", e.peerListModification = "36", e))(S || {});/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var F = function () { return F = Object.assign || function (t) { for (var r, n = 1, i = arguments.length; n < i; n++) { r = arguments[n]; for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]) } return t }, F.apply(this, arguments) }; function Gr(e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) } var V = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, H = Object.keys, ae = Array.isArray; typeof Promise < "u" && !V.Promise && (V.Promise = Promise); function ue(e, t) { return typeof t != "object" || H(t).forEach(function (r) { e[r] = t[r] }), e } var Ot = Object.getPrototypeOf, ho = {}.hasOwnProperty; function ge(e, t) { return ho.call(e, t) } function pt(e, t) { typeof t == "function" && (t = t(Ot(e))), (typeof Reflect > "u" ? H : Reflect.ownKeys)(t).forEach(function (r) { Ae(e, r, t[r]) }) } var Fi = Object.defineProperty; function Ae(e, t, r, n) { Fi(e, t, ue(r && ge(r, "get") && typeof r.get == "function" ? { get: r.get, set: r.set, configurable: !0 } : { value: r, configurable: !0, writable: !0 }, n)) } function ht(e) { return { from: function (t) { return e.prototype = Object.create(t.prototype), Ae(e.prototype, "constructor", e), { extend: pt.bind(null, e.prototype) } } } } var mo = Object.getOwnPropertyDescriptor; function En(e, t) { var r = mo(e, t), n; return r || (n = Ot(e)) && En(n, t) } var vo = [].slice; function Pr(e, t, r) { return vo.call(e, t, r) } function Ni(e, t) { return t(e) } function St(e) { if (!e) throw new Error("Assertion Failed") } function Ki(e) { V.setImmediate ? setImmediate(e) : setTimeout(e, 0) } function Li(e, t) { return e.reduce(function (r, n, i) { var a = t(n, i); return a && (r[a[0]] = a[1]), r }, {}) } function yo(e, t, r) { try { e.apply(null, r) } catch (n) { t && t(n) } } function Oe(e, t) { if (ge(e, t)) return e[t]; if (!t) return e; if (typeof t != "string") { for (var r = [], n = 0, i = t.length; n < i; ++n) { var a = Oe(e, t[n]); r.push(a) } return r } var o = t.indexOf("."); if (o !== -1) { var u = e[t.substr(0, o)]; return u === void 0 ? void 0 : Oe(u, t.substr(o + 1)) } } function Ce(e, t, r) { if (!(!e || t === void 0) && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) { St(typeof r != "string" && "length" in r); for (var n = 0, i = t.length; n < i; ++n)Ce(e, t[n], r[n]) } else { var a = t.indexOf("."); if (a !== -1) { var o = t.substr(0, a), u = t.substr(a + 1); if (u === "") r === void 0 ? ae(e) && !isNaN(parseInt(o)) ? e.splice(o, 1) : delete e[o] : e[o] = r; else { var s = e[o]; (!s || !ge(e, o)) && (s = e[o] = {}), Ce(s, u, r) } } else r === void 0 ? ae(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r } } function go(e, t) { typeof t == "string" ? Ce(e, t, void 0) : "length" in t && [].map.call(t, function (r) { Ce(e, r, void 0) }) } function Ui(e) { var t = {}; for (var r in e) ge(e, r) && (t[r] = e[r]); return t } var bo = [].concat; function zi(e) { return bo.apply([], e) } var $i = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(zi([8, 16, 32, 64].map(function (e) { return ["Int", "Uint", "Float"].map(function (t) { return t + e + "Array" }) }))).filter(function (e) { return V[e] }), _o = $i.map(function (e) { return V[e] }); Li($i, function (e) { return [e, !0] }); var Ne = null; function Kt(e) { Ne = typeof WeakMap < "u" && new WeakMap; var t = Vr(e); return Ne = null, t } function Vr(e) { if (!e || typeof e != "object") return e; var t = Ne && Ne.get(e); if (t) return t; if (ae(e)) { t = [], Ne && Ne.set(e, t); for (var r = 0, n = e.length; r < n; ++r)t.push(Vr(e[r])) } else if (_o.indexOf(e.constructor) >= 0) t = e; else { var i = Ot(e); t = i === Object.prototype ? {} : Object.create(i), Ne && Ne.set(e, t); for (var a in e) ge(e, a) && (t[a] = Vr(e[a])) } return t } var Co = {}.toString; function qr(e) { return Co.call(e).slice(8, -1) } var Jr = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", So = typeof Jr == "symbol" ? function (e) { var t; return e != null && (t = e[Jr]) && t.apply(e) } : function () { return null }, at = {}; function xe(e) { var t, r, n, i; if (arguments.length === 1) { if (ae(e)) return e.slice(); if (this === at && typeof e == "string") return [e]; if (i = So(e)) { for (r = []; n = i.next(), !n.done;)r.push(n.value); return r } if (e == null) return [e]; if (t = e.length, typeof t == "number") { for (r = new Array(t); t--;)r[t] = e[t]; return r } return [e] } for (t = arguments.length, r = new Array(t); t--;)r[t] = arguments[t]; return r } var Rn = typeof Symbol < "u" ? function (e) { return e[Symbol.toStringTag] === "AsyncFunction" } : function () { return !1 }, Te = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href); function Gi(e, t) { Te = e, Vi = t } var Vi = function () { return !0 }, To = !new Error("").stack; function rt() { if (To) try { throw rt.arguments, new Error } catch (e) { return e } return new Error } function Hr(e, t) {
    var r = e.stack; return r ? (t = t || 0, r.indexOf(e.name) === 0 && (t += (e.name + e.message).split(`
`).length), r.split(`
`).slice(t).filter(Vi).map(function (n) {
        return `
`+ n
    }).join("")) : ""
} var ko = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"], qi = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], xn = ko.concat(qi), Po = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" }; function mt(e, t) { this._e = rt(), this.name = e, this.message = t } ht(mt).from(Error).extend({ stack: { get: function () { return this._stack || (this._stack = this.name + ": " + this.message + Hr(this._e, 2)) } }, toString: function () { return this.name + ": " + this.message } }); function Ji(e, t) {
    return e + ". Errors: " + Object.keys(t).map(function (r) { return t[r].toString() }).filter(function (r, n, i) { return i.indexOf(r) === n }).join(`
`)
} function hr(e, t, r, n) { this._e = rt(), this.failures = t, this.failedKeys = n, this.successCount = r, this.message = Ji(e, t) } ht(hr).from(mt); function Rt(e, t) { this._e = rt(), this.name = "BulkError", this.failures = Object.keys(t).map(function (r) { return t[r] }), this.failuresByPos = t, this.message = Ji(e, t) } ht(Rt).from(mt); var Dn = xn.reduce(function (e, t) { return e[t] = t + "Error", e }, {}), Eo = mt, j = xn.reduce(function (e, t) {
    var r = t + "Error"; function n(i, a) {
        this._e = rt(), this.name = r, i ? typeof i == "string" ? (this.message = "" + i + (a ? `
 `+ a : ""), this.inner = a || null) : typeof i == "object" && (this.message = i.name + " " + i.message, this.inner = i) : (this.message = Po[t] || r, this.inner = null)
    } return ht(n).from(Eo), e[t] = n, e
}, {}); j.Syntax = SyntaxError; j.Type = TypeError; j.Range = RangeError; var Qn = qi.reduce(function (e, t) { return e[t + "Error"] = j[t], e }, {}); function Ro(e, t) { if (!e || e instanceof mt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Qn[e.name]) return e; var r = new Qn[e.name](t || e.message, e); return "stack" in e && Ae(r, "stack", { get: function () { return this.inner.stack } }), r } var Er = xn.reduce(function (e, t) { return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = j[t]), e }, {}); Er.ModifyError = hr; Er.DexieError = mt; Er.BulkError = Rt; function $() { } function Lt(e) { return e } function xo(e, t) { return e == null || e === Lt ? t : function (r) { return t(e(r)) } } function et(e, t) { return function () { e.apply(this, arguments), t.apply(this, arguments) } } function Do(e, t) { return e === $ ? t : function () { var r = e.apply(this, arguments); r !== void 0 && (arguments[0] = r); var n = this.onsuccess, i = this.onerror; this.onsuccess = null, this.onerror = null; var a = t.apply(this, arguments); return n && (this.onsuccess = this.onsuccess ? et(n, this.onsuccess) : n), i && (this.onerror = this.onerror ? et(i, this.onerror) : i), a !== void 0 ? a : r } } function wo(e, t) { return e === $ ? t : function () { e.apply(this, arguments); var r = this.onsuccess, n = this.onerror; this.onsuccess = this.onerror = null, t.apply(this, arguments), r && (this.onsuccess = this.onsuccess ? et(r, this.onsuccess) : r), n && (this.onerror = this.onerror ? et(n, this.onerror) : n) } } function Oo(e, t) { return e === $ ? t : function (r) { var n = e.apply(this, arguments); ue(r, n); var i = this.onsuccess, a = this.onerror; this.onsuccess = null, this.onerror = null; var o = t.apply(this, arguments); return i && (this.onsuccess = this.onsuccess ? et(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? et(a, this.onerror) : a), n === void 0 ? o === void 0 ? void 0 : o : ue(n, o) } } function Ao(e, t) { return e === $ ? t : function () { return t.apply(this, arguments) === !1 ? !1 : e.apply(this, arguments) } } function wn(e, t) { return e === $ ? t : function () { var r = e.apply(this, arguments); if (r && typeof r.then == "function") { for (var n = this, i = arguments.length, a = new Array(i); i--;)a[i] = arguments[i]; return r.then(function () { return t.apply(n, a) }) } return t.apply(this, arguments) } } var At = {}, Io = 100, Mo = 20, Hi = 100, On = typeof Promise > "u" ? [] : function () { var e = Promise.resolve(); if (typeof crypto > "u" || !crypto.subtle) return [e, Ot(e), e]; var t = crypto.subtle.digest("SHA-512", new Uint8Array([0])); return [t, Ot(t), e] }(), Wr = On[0], mr = On[1], Qr = On[2], Wi = mr && mr.then, nr = Wr && Wr.constructor, An = !!Qr, Yr = !1, jo = Qr ? function () { Qr.then(Jt) } : V.setImmediate ? setImmediate.bind(null, Jt) : V.MutationObserver ? function () { var e = document.createElement("div"); new MutationObserver(function () { Jt(), e = null }).observe(e, { attributes: !0 }), e.setAttribute("i", "1") } : function () { setTimeout(Jt, 0) }, It = function (e, t) { Tt.push([e, t]), vr && (jo(), vr = !1) }, Xr = !0, vr = !0, Ye = [], ir = [], Zr = null, en = Lt, st = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Zn, pgp: !1, env: {}, finalize: function () { this.unhandleds.forEach(function (e) { try { Zn(e[0], e[1]) } catch { } }) } }, A = st, Tt = [], Xe = 0, ar = []; function x(e) { if (typeof this != "object") throw new TypeError("Promises must be constructed via new"); this._listeners = [], this.onuncatched = $, this._lib = !1; var t = this._PSD = A; if (Te && (this._stackHolder = rt(), this._prev = null, this._numPrev = 0), typeof e != "function") { if (e !== At) throw new TypeError("Not a function"); this._state = arguments[1], this._value = arguments[2], this._state === !1 && rn(this, this._value); return } this._state = null, this._value = null, ++t.ref, Yi(this, e) } var tn = { get: function () { var e = A, t = yr; function r(n, i) { var a = this, o = !e.global && (e !== A || t !== yr), u = o && !Ie(), s = new x(function (c, l) { In(a, new Qi(br(n, e, o, u), br(i, e, o, u), c, l, e)) }); return Te && ea(s, this), s } return r.prototype = At, r }, set: function (e) { Ae(this, "then", e && e.prototype === At ? tn : { get: function () { return e }, set: tn.set }) } }; pt(x.prototype, {
    then: tn, _then: function (e, t) { In(this, new Qi(null, null, e, t, A)) }, catch: function (e) { if (arguments.length === 1) return this.then(null, e); var t = arguments[0], r = arguments[1]; return typeof t == "function" ? this.then(null, function (n) { return n instanceof t ? r(n) : or(n) }) : this.then(null, function (n) { return n && n.name === t ? r(n) : or(n) }) }, finally: function (e) { return this.then(function (t) { return e(), t }, function (t) { return e(), or(t) }) }, stack: {
        get: function () {
            if (this._stack) return this._stack; try {
                Yr = !0; var e = Zi(this, [], Mo), t = e.join(`
From previous: `); return this._state !== null && (this._stack = t), t
            } finally { Yr = !1 }
        }
    }, timeout: function (e, t) { var r = this; return e < 1 / 0 ? new x(function (n, i) { var a = setTimeout(function () { return i(new j.Timeout(t)) }, e); r.then(n, i).finally(clearTimeout.bind(null, a)) }) : this }
}); typeof Symbol < "u" && Symbol.toStringTag && Ae(x.prototype, Symbol.toStringTag, "Dexie.Promise"); st.env = ta(); function Qi(e, t, r, n, i) { this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = r, this.reject = n, this.psd = i } pt(x, { all: function () { var e = xe.apply(null, arguments).map(gr); return new x(function (t, r) { e.length === 0 && t([]); var n = e.length; e.forEach(function (i, a) { return x.resolve(i).then(function (o) { e[a] = o, --n || t(e) }, r) }) }) }, resolve: function (e) { if (e instanceof x) return e; if (e && typeof e.then == "function") return new x(function (r, n) { e.then(r, n) }); var t = new x(At, !0, e); return ea(t, Zr), t }, reject: or, race: function () { var e = xe.apply(null, arguments).map(gr); return new x(function (t, r) { e.map(function (n) { return x.resolve(n).then(t, r) }) }) }, PSD: { get: function () { return A }, set: function (e) { return A = e } }, totalEchoes: { get: function () { return yr } }, newPSD: $e, usePSD: yt, scheduler: { get: function () { return It }, set: function (e) { It = e } }, rejectionMapper: { get: function () { return en }, set: function (e) { en = e } }, follow: function (e, t) { return new x(function (r, n) { return $e(function (i, a) { var o = A; o.unhandleds = [], o.onunhandled = a, o.finalize = et(function () { var u = this; Fo(function () { u.unhandleds.length === 0 ? i() : a(u.unhandleds[0]) }) }, o.finalize), e() }, t, r, n) }) } }); nr && (nr.allSettled && Ae(x, "allSettled", function () { var e = xe.apply(null, arguments).map(gr); return new x(function (t) { e.length === 0 && t([]); var r = e.length, n = new Array(r); e.forEach(function (i, a) { return x.resolve(i).then(function (o) { return n[a] = { status: "fulfilled", value: o } }, function (o) { return n[a] = { status: "rejected", reason: o } }).then(function () { return --r || t(n) }) }) }) }), nr.any && typeof AggregateError < "u" && Ae(x, "any", function () { var e = xe.apply(null, arguments).map(gr); return new x(function (t, r) { e.length === 0 && r(new AggregateError([])); var n = e.length, i = new Array(n); e.forEach(function (a, o) { return x.resolve(a).then(function (u) { return t(u) }, function (u) { i[o] = u, --n || r(new AggregateError(i)) }) }) }) })); function Yi(e, t) { try { t(function (r) { if (e._state === null) { if (r === e) throw new TypeError("A promise cannot be resolved with itself."); var n = e._lib && Ut(); r && typeof r.then == "function" ? Yi(e, function (i, a) { r instanceof x ? r._then(i, a) : r.then(i, a) }) : (e._state = !0, e._value = r, Xi(e)), n && zt() } }, rn.bind(null, e)) } catch (r) { rn(e, r) } } function rn(e, t) { if (ir.push(t), e._state === null) { var r = e._lib && Ut(); t = en(t), e._state = !1, e._value = t, Te && t !== null && typeof t == "object" && !t._promise && yo(function () { var n = En(t, "stack"); t._promise = e, Ae(t, "stack", { get: function () { return Yr ? n && (n.get ? n.get.apply(t) : n.value) : e.stack } }) }), No(e), Xi(e), r && zt() } } function Xi(e) { var t = e._listeners; e._listeners = []; for (var r = 0, n = t.length; r < n; ++r)In(e, t[r]); var i = e._PSD; --i.ref || i.finalize(), Xe === 0 && (++Xe, It(function () { --Xe === 0 && Mn() }, [])) } function In(e, t) { if (e._state === null) { e._listeners.push(t); return } var r = e._state ? t.onFulfilled : t.onRejected; if (r === null) return (e._state ? t.resolve : t.reject)(e._value); ++t.psd.ref, ++Xe, It(Bo, [r, e, t]) } function Bo(e, t, r) { try { Zr = t; var n, i = t._value; t._state ? n = e(i) : (ir.length && (ir = []), n = e(i), ir.indexOf(i) === -1 && Ko(t)), r.resolve(n) } catch (a) { r.reject(a) } finally { Zr = null, --Xe === 0 && Mn(), --r.psd.ref || r.psd.finalize() } } function Zi(e, t, r) { if (t.length === r) return t; var n = ""; if (e._state === !1) { var i = e._value, a, o; i != null ? (a = i.name || "Error", o = i.message || i, n = Hr(i, 0)) : (a = i, o = ""), t.push(a + (o ? ": " + o : "") + n) } return Te && (n = Hr(e._stackHolder, 2), n && t.indexOf(n) === -1 && t.push(n), e._prev && Zi(e._prev, t, r)), t } function ea(e, t) { var r = t ? t._numPrev + 1 : 0; r < Io && (e._prev = t, e._numPrev = r) } function Jt() { Ut() && zt() } function Ut() { var e = Xr; return Xr = !1, vr = !1, e } function zt() { var e, t, r; do for (; Tt.length > 0;)for (e = Tt, Tt = [], r = e.length, t = 0; t < r; ++t) { var n = e[t]; n[0].apply(null, n[1]) } while (Tt.length > 0); Xr = !0, vr = !0 } function Mn() { var e = Ye; Ye = [], e.forEach(function (n) { n._PSD.onunhandled.call(null, n._value, n) }); for (var t = ar.slice(0), r = t.length; r;)t[--r]() } function Fo(e) { function t() { e(), ar.splice(ar.indexOf(t), 1) } ar.push(t), ++Xe, It(function () { --Xe === 0 && Mn() }, []) } function No(e) { Ye.some(function (t) { return t._value === e._value }) || Ye.push(e) } function Ko(e) { for (var t = Ye.length; t;)if (Ye[--t]._value === e._value) { Ye.splice(t, 1); return } } function or(e) { return new x(At, !1, e) } function q(e, t) { var r = A; return function () { var n = Ut(), i = A; try { return Ge(r, !0), e.apply(this, arguments) } catch (a) { t && t(a) } finally { Ge(i, !1), n && zt() } } } var ie = { awaits: 0, echoes: 0, id: 0 }, Lo = 0, sr = [], wr = 0, yr = 0, Uo = 0; function $e(e, t, r, n) { var i = A, a = Object.create(i); a.parent = i, a.ref = 0, a.global = !1, a.id = ++Uo; var o = st.env; a.env = An ? { Promise: x, PromiseProp: { value: x, configurable: !0, writable: !0 }, all: x.all, race: x.race, allSettled: x.allSettled, any: x.any, resolve: x.resolve, reject: x.reject, nthen: Yn(o.nthen, a), gthen: Yn(o.gthen, a) } : {}, t && ue(a, t), ++i.ref, a.finalize = function () { --this.parent.ref || this.parent.finalize() }; var u = yt(a, e, r, n); return a.ref === 0 && a.finalize(), u } function vt() { return ie.id || (ie.id = ++Lo), ++ie.awaits, ie.echoes += Hi, ie.id } function Ie() { return ie.awaits ? (--ie.awaits === 0 && (ie.id = 0), ie.echoes = ie.awaits * Hi, !0) : !1 } ("" + Wi).indexOf("[native code]") === -1 && (vt = Ie = $); function gr(e) { return ie.echoes && e && e.constructor === nr ? (vt(), e.then(function (t) { return Ie(), t }, function (t) { return Ie(), W(t) })) : e } function zo(e) { ++yr, (!ie.echoes || --ie.echoes === 0) && (ie.echoes = ie.id = 0), sr.push(A), Ge(e, !0) } function $o() { var e = sr[sr.length - 1]; sr.pop(), Ge(e, !1) } function Ge(e, t) { var r = A; if ((t ? ie.echoes && (!wr++ || e !== A) : wr && (!--wr || e !== A)) && ra(t ? zo.bind(null, e) : $o), e !== A && (A = e, r === st && (st.env = ta()), An)) { var n = st.env.Promise, i = e.env; mr.then = i.nthen, n.prototype.then = i.gthen, (r.global || e.global) && (Object.defineProperty(V, "Promise", i.PromiseProp), n.all = i.all, n.race = i.race, n.resolve = i.resolve, n.reject = i.reject, i.allSettled && (n.allSettled = i.allSettled), i.any && (n.any = i.any)) } } function ta() { var e = V.Promise; return An ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(V, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject, nthen: mr.then, gthen: e.prototype.then } : {} } function yt(e, t, r, n, i) { var a = A; try { return Ge(e, !0), t(r, n, i) } finally { Ge(a, !1) } } function ra(e) { Wi.call(Wr, e) } function br(e, t, r, n) { return typeof e != "function" ? e : function () { var i = A; r && vt(), Ge(t, !0); try { return e.apply(this, arguments) } finally { Ge(i, !1), n && ra(Ie) } } } function Yn(e, t) { return function (r, n) { return e.call(this, br(r, t), br(n, t)) } } var Xn = "unhandledrejection"; function Zn(e, t) { var r; try { r = t.onuncatched(e) } catch { } if (r !== !1) try { var n, i = { promise: t, reason: e }; if (V.document && document.createEvent ? (n = document.createEvent("Event"), n.initEvent(Xn, !0, !0), ue(n, i)) : V.CustomEvent && (n = new CustomEvent(Xn, { detail: i }), ue(n, i)), n && V.dispatchEvent && (dispatchEvent(n), !V.PromiseRejectionEvent && V.onunhandledrejection)) try { V.onunhandledrejection(n) } catch { } Te && n && !n.defaultPrevented && console.warn("Unhandled rejection: " + (e.stack || e)) } catch { } } var W = x.reject; function nn(e, t, r, n) { if (!e.idbdb || !e._state.openComplete && !A.letThrough && !e._vip) { if (e._state.openComplete) return W(new j.DatabaseClosed(e._state.dbOpenError)); if (!e._state.isBeingOpened) { if (!e._options.autoOpen) return W(new j.DatabaseClosed); e.open().catch($) } return e._state.dbReadyPromise.then(function () { return nn(e, t, r, n) }) } else { var i = e._createTransaction(t, r, e._dbSchema); try { i.create(), e._state.PR1398_maxLoop = 3 } catch (a) { return a.name === Dn.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return nn(e, t, r, n) })) : W(a) } return i._promise(t, function (a, o) { return $e(function () { return A.trans = i, n(a, o, i) }) }).then(function (a) { return i._completion.then(function () { return a }) }) } } var ei = "3.2.2", We = String.fromCharCode(65535), an = -1 / 0, Pe = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", na = "String expected.", xt = [], Rr = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), Go = Rr, Vo = Rr, ia = function (e) { return !/(dexie\.js|dexie\.min\.js)/.test(e) }, xr = "__dbnames", Or = "readonly", Ar = "readwrite"; function tt(e, t) { return e ? t ? function () { return e.apply(this, arguments) && t.apply(this, arguments) } : e : t } var aa = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 }; function Ht(e) { return typeof e == "string" && !/\./.test(e) ? function (t) { return t[e] === void 0 && e in t && (t = Kt(t), delete t[e]), t } : function (t) { return t } } var qo = function () { function e() { } return e.prototype._trans = function (t, r, n) { var i = this._tx || A.trans, a = this.name; function o(s, c, l) { if (!l.schema[a]) throw new j.NotFound("Table " + a + " not part of transaction"); return r(l.idbtrans, l) } var u = Ut(); try { return i && i.db === this.db ? i === A.trans ? i._promise(t, o, n) : $e(function () { return i._promise(t, o, n) }, { trans: i, transless: A.transless || A }) : nn(this.db, t, [this.name], o) } finally { u && zt() } }, e.prototype.get = function (t, r) { var n = this; return t && t.constructor === Object ? this.where(t).first(r) : this._trans("readonly", function (i) { return n.core.get({ trans: i, key: t }).then(function (a) { return n.hook.reading.fire(a) }) }).then(r) }, e.prototype.where = function (t) { if (typeof t == "string") return new this.db.WhereClause(this, t); if (ae(t)) return new this.db.WhereClause(this, "[" + t.join("+") + "]"); var r = H(t); if (r.length === 1) return this.where(r[0]).equals(t[r[0]]); var n = this.schema.indexes.concat(this.schema.primKey).filter(function (l) { return l.compound && r.every(function (f) { return l.keyPath.indexOf(f) >= 0 }) && l.keyPath.every(function (f) { return r.indexOf(f) >= 0 }) })[0]; if (n && this.db._maxKey !== We) return this.where(n.name).equals(n.keyPath.map(function (l) { return t[l] })); !n && Te && console.warn("The query " + JSON.stringify(t) + " on " + this.name + " would benefit of a " + ("compound index [" + r.join("+") + "]")); var i = this.schema.idxByName, a = this.db._deps.indexedDB; function o(l, f) { try { return a.cmp(l, f) === 0 } catch { return !1 } } var u = r.reduce(function (l, f) { var p = l[0], m = l[1], d = i[f], h = t[f]; return [p || d, p || !d ? tt(m, d && d.multi ? function (b) { var v = Oe(b, f); return ae(v) && v.some(function (g) { return o(h, g) }) } : function (b) { return o(h, Oe(b, f)) }) : m] }, [null, null]), s = u[0], c = u[1]; return s ? this.where(s.name).equals(t[s.keyPath]).filter(c) : n ? this.filter(c) : this.where(r).equals("") }, e.prototype.filter = function (t) { return this.toCollection().and(t) }, e.prototype.count = function (t) { return this.toCollection().count(t) }, e.prototype.offset = function (t) { return this.toCollection().offset(t) }, e.prototype.limit = function (t) { return this.toCollection().limit(t) }, e.prototype.each = function (t) { return this.toCollection().each(t) }, e.prototype.toArray = function (t) { return this.toCollection().toArray(t) }, e.prototype.toCollection = function () { return new this.db.Collection(new this.db.WhereClause(this)) }, e.prototype.orderBy = function (t) { return new this.db.Collection(new this.db.WhereClause(this, ae(t) ? "[" + t.join("+") + "]" : t)) }, e.prototype.reverse = function () { return this.toCollection().reverse() }, e.prototype.mapToClass = function (t) { this.schema.mappedClass = t; var r = function (n) { if (!n) return n; var i = Object.create(t.prototype); for (var a in n) if (ge(n, a)) try { i[a] = n[a] } catch { } return i }; return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook("reading", r), t }, e.prototype.defineClass = function () { function t(r) { ue(this, r) } return this.mapToClass(t) }, e.prototype.add = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Ht(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "add", keys: r != null ? [r] : null, values: [u] }) }).then(function (s) { return s.numFailures ? x.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { Ce(t, o, s) } catch { } return s }) }, e.prototype.update = function (t, r) { if (typeof t == "object" && !ae(t)) { var n = Oe(t, this.schema.primKey.keyPath); if (n === void 0) return W(new j.InvalidArgument("Given object does not contain its primary key")); try { typeof r != "function" ? H(r).forEach(function (i) { Ce(t, i, r[i]) }) : r(t, { value: t, primKey: n }) } catch { } return this.where(":id").equals(n).modify(r) } else return this.where(":id").equals(t).modify(r) }, e.prototype.put = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Ht(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "put", values: [u], keys: r != null ? [r] : null }) }).then(function (s) { return s.numFailures ? x.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { Ce(t, o, s) } catch { } return s }) }, e.prototype.delete = function (t) { var r = this; return this._trans("readwrite", function (n) { return r.core.mutate({ trans: n, type: "delete", keys: [t] }) }).then(function (n) { return n.numFailures ? x.reject(n.failures[0]) : void 0 }) }, e.prototype.clear = function () { var t = this; return this._trans("readwrite", function (r) { return t.core.mutate({ trans: r, type: "deleteRange", range: aa }) }).then(function (r) { return r.numFailures ? x.reject(r.failures[0]) : void 0 }) }, e.prototype.bulkGet = function (t) { var r = this; return this._trans("readonly", function (n) { return r.core.getMany({ keys: t, trans: n }).then(function (i) { return i.map(function (a) { return r.hook.reading.fire(a) }) }) }) }, e.prototype.bulkAdd = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, l = s.keyPath; if (l && a) throw new j.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new j.InvalidArgument("Arguments objects and keys must have the same length"); var f = t.length, p = l && c ? t.map(Ht(l)) : t; return i.core.mutate({ trans: u, type: "add", keys: a, values: p, wantResults: o }).then(function (m) { var d = m.numFailures, h = m.results, b = m.lastResult, v = m.failures, g = o ? h : b; if (d === 0) return g; throw new Rt(i.name + ".bulkAdd(): " + d + " of " + f + " operations failed", v) }) }) }, e.prototype.bulkPut = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, l = s.keyPath; if (l && a) throw new j.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new j.InvalidArgument("Arguments objects and keys must have the same length"); var f = t.length, p = l && c ? t.map(Ht(l)) : t; return i.core.mutate({ trans: u, type: "put", keys: a, values: p, wantResults: o }).then(function (m) { var d = m.numFailures, h = m.results, b = m.lastResult, v = m.failures, g = o ? h : b; if (d === 0) return g; throw new Rt(i.name + ".bulkPut(): " + d + " of " + f + " operations failed", v) }) }) }, e.prototype.bulkDelete = function (t) { var r = this, n = t.length; return this._trans("readwrite", function (i) { return r.core.mutate({ trans: i, type: "delete", keys: t }) }).then(function (i) { var a = i.numFailures, o = i.lastResult, u = i.failures; if (a === 0) return o; throw new Rt(r.name + ".bulkDelete(): " + a + " of " + n + " operations failed", u) }) }, e }(); function $t(e) { var t = {}, r = function (u, s) { if (s) { for (var c = arguments.length, l = new Array(c - 1); --c;)l[c - 1] = arguments[c]; return t[u].subscribe.apply(null, l), e } else if (typeof u == "string") return t[u] }; r.addEventType = a; for (var n = 1, i = arguments.length; n < i; ++n)a(arguments[n]); return r; function a(u, s, c) { if (typeof u == "object") return o(u); s || (s = Ao), c || (c = $); var l = { subscribers: [], fire: c, subscribe: function (f) { l.subscribers.indexOf(f) === -1 && (l.subscribers.push(f), l.fire = s(l.fire, f)) }, unsubscribe: function (f) { l.subscribers = l.subscribers.filter(function (p) { return p !== f }), l.fire = l.subscribers.reduce(s, c) } }; return t[u] = r[u] = l, l } function o(u) { H(u).forEach(function (s) { var c = u[s]; if (ae(c)) a(s, u[s][0], u[s][1]); else if (c === "asap") var l = a(s, Lt, function () { for (var p = arguments.length, m = new Array(p); p--;)m[p] = arguments[p]; l.subscribers.forEach(function (d) { Ki(function () { d.apply(null, m) }) }) }); else throw new j.InvalidArgument("Invalid event config") }) } } function Gt(e, t) { return ht(t).from({ prototype: e }), t } function Jo(e) { return Gt(qo.prototype, function (r, n, i) { this.db = e, this._tx = i, this.name = r, this.schema = n, this.hook = e._allTables[r] ? e._allTables[r].hook : $t(null, { creating: [Do, $], reading: [xo, Lt], updating: [Oo, $], deleting: [wo, $] }) }) } function nt(e, t) { return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter) } function Ir(e, t) { e.filter = tt(e.filter, t) } function Mr(e, t, r) { var n = e.replayFilter; e.replayFilter = n ? function () { return tt(n(), t()) } : t, e.justLimit = r && !n } function Ho(e, t) { e.isMatch = tt(e.isMatch, t) } function cr(e, t) { if (e.isPrimKey) return t.primaryKey; var r = t.getIndexByKeyPath(e.index); if (!r) throw new j.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed"); return r } function ti(e, t, r) { var n = cr(e, t.schema); return t.openCursor({ trans: r, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: n, range: e.range } }) } function Wt(e, t, r, n) { var i = e.replayFilter ? tt(e.filter, e.replayFilter()) : e.filter; if (e.or) { var a = {}, o = function (u, s, c) { if (!i || i(s, c, function (p) { return s.stop(p) }, function (p) { return s.fail(p) })) { var l = s.primaryKey, f = "" + l; f === "[object ArrayBuffer]" && (f = "" + new Uint8Array(l)), ge(a, f) || (a[f] = !0, t(u, s, c)) } }; return Promise.all([e.or._iterate(o, r), ri(ti(e, n, r), e.algorithm, o, !e.keysOnly && e.valueMapper)]) } else return ri(ti(e, n, r), tt(e.algorithm, i), t, !e.keysOnly && e.valueMapper) } function ri(e, t, r, n) { var i = n ? function (o, u, s) { return r(n(o), u, s) } : r, a = q(i); return e.then(function (o) { if (o) return o.start(function () { var u = function () { return o.continue() }; (!t || t(o, function (s) { return u = s }, function (s) { o.stop(s), u = $ }, function (s) { o.fail(s), u = $ })) && a(o.value, o, function (s) { return u = s }), u() }) }) } function ce(e, t) { try { var r = ni(e), n = ni(t); if (r !== n) return r === "Array" ? 1 : n === "Array" ? -1 : r === "binary" ? 1 : n === "binary" ? -1 : r === "string" ? 1 : n === "string" ? -1 : r === "Date" ? 1 : n !== "Date" ? NaN : -1; switch (r) { case "number": case "Date": case "string": return e > t ? 1 : e < t ? -1 : 0; case "binary": return Qo(ii(e), ii(t)); case "Array": return Wo(e, t) } } catch { } return NaN } function Wo(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a) { var o = ce(e[a], t[a]); if (o !== 0) return o } return r === n ? 0 : r < n ? -1 : 1 } function Qo(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a)if (e[a] !== t[a]) return e[a] < t[a] ? -1 : 1; return r === n ? 0 : r < n ? -1 : 1 } function ni(e) { var t = typeof e; if (t !== "object") return t; if (ArrayBuffer.isView(e)) return "binary"; var r = qr(e); return r === "ArrayBuffer" ? "binary" : r } function ii(e) { return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e) } var Yo = function () { function e() { } return e.prototype._read = function (t, r) { var n = this._ctx; return n.error ? n.table._trans(null, W.bind(null, n.error)) : n.table._trans("readonly", t).then(r) }, e.prototype._write = function (t) { var r = this._ctx; return r.error ? r.table._trans(null, W.bind(null, r.error)) : r.table._trans("readwrite", t, "locked") }, e.prototype._addAlgorithm = function (t) { var r = this._ctx; r.algorithm = tt(r.algorithm, t) }, e.prototype._iterate = function (t, r) { return Wt(this._ctx, t, r, this._ctx.table.core) }, e.prototype.clone = function (t) { var r = Object.create(this.constructor.prototype), n = Object.create(this._ctx); return t && ue(n, t), r._ctx = n, r }, e.prototype.raw = function () { return this._ctx.valueMapper = null, this }, e.prototype.each = function (t) { var r = this._ctx; return this._read(function (n) { return Wt(r, t, n, r.table.core) }) }, e.prototype.count = function (t) { var r = this; return this._read(function (n) { var i = r._ctx, a = i.table.core; if (nt(i, !0)) return a.count({ trans: n, query: { index: cr(i, a.schema), range: i.range } }).then(function (u) { return Math.min(u, i.limit) }); var o = 0; return Wt(i, function () { return ++o, !1 }, n, a).then(function () { return o }) }).then(t) }, e.prototype.sortBy = function (t, r) { var n = t.split(".").reverse(), i = n[0], a = n.length - 1; function o(c, l) { return l ? o(c[n[l]], l - 1) : c[i] } var u = this._ctx.dir === "next" ? 1 : -1; function s(c, l) { var f = o(c, a), p = o(l, a); return f < p ? -u : f > p ? u : 0 } return this.toArray(function (c) { return c.sort(s) }).then(r) }, e.prototype.toArray = function (t) { var r = this; return this._read(function (n) { var i = r._ctx; if (i.dir === "next" && nt(i, !0) && i.limit > 0) { var a = i.valueMapper, o = cr(i, i.table.core.schema); return i.table.core.query({ trans: n, limit: i.limit, values: !0, query: { index: o, range: i.range } }).then(function (s) { var c = s.result; return a ? c.map(a) : c }) } else { var u = []; return Wt(i, function (s) { return u.push(s) }, n, i.table.core).then(function () { return u }) } }, t) }, e.prototype.offset = function (t) { var r = this._ctx; return t <= 0 ? this : (r.offset += t, nt(r) ? Mr(r, function () { var n = t; return function (i, a) { return n === 0 ? !0 : n === 1 ? (--n, !1) : (a(function () { i.advance(n), n = 0 }), !1) } }) : Mr(r, function () { var n = t; return function () { return --n < 0 } }), this) }, e.prototype.limit = function (t) { return this._ctx.limit = Math.min(this._ctx.limit, t), Mr(this._ctx, function () { var r = t; return function (n, i, a) { return --r <= 0 && i(a), r >= 0 } }, !0), this }, e.prototype.until = function (t, r) { return Ir(this._ctx, function (n, i, a) { return t(n.value) ? (i(a), r) : !0 }), this }, e.prototype.first = function (t) { return this.limit(1).toArray(function (r) { return r[0] }).then(t) }, e.prototype.last = function (t) { return this.reverse().first(t) }, e.prototype.filter = function (t) { return Ir(this._ctx, function (r) { return t(r.value) }), Ho(this._ctx, t), this }, e.prototype.and = function (t) { return this.filter(t) }, e.prototype.or = function (t) { return new this.db.WhereClause(this._ctx.table, t, this) }, e.prototype.reverse = function () { return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this }, e.prototype.desc = function () { return this.reverse() }, e.prototype.eachKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.key, i) }) }, e.prototype.eachUniqueKey = function (t) { return this._ctx.unique = "unique", this.eachKey(t) }, e.prototype.eachPrimaryKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.primaryKey, i) }) }, e.prototype.keys = function (t) { var r = this._ctx; r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.key) }).then(function () { return n }).then(t) }, e.prototype.primaryKeys = function (t) { var r = this._ctx; if (r.dir === "next" && nt(r, !0) && r.limit > 0) return this._read(function (i) { var a = cr(r, r.table.core.schema); return r.table.core.query({ trans: i, values: !1, limit: r.limit, query: { index: a, range: r.range } }) }).then(function (i) { var a = i.result; return a }).then(t); r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.primaryKey) }).then(function () { return n }).then(t) }, e.prototype.uniqueKeys = function (t) { return this._ctx.unique = "unique", this.keys(t) }, e.prototype.firstKey = function (t) { return this.limit(1).keys(function (r) { return r[0] }).then(t) }, e.prototype.lastKey = function (t) { return this.reverse().firstKey(t) }, e.prototype.distinct = function () { var t = this._ctx, r = t.index && t.table.schema.idxByName[t.index]; if (!r || !r.multi) return this; var n = {}; return Ir(this._ctx, function (i) { var a = i.primaryKey.toString(), o = ge(n, a); return n[a] = !0, !o }), this }, e.prototype.modify = function (t) { var r = this, n = this._ctx; return this._write(function (i) { var a; if (typeof t == "function") a = t; else { var o = H(t), u = o.length; a = function (v) { for (var g = !1, C = 0; C < u; ++C) { var _ = o[C], y = t[_]; Oe(v, _) !== y && (Ce(v, _, y), g = !0) } return g } } var s = n.table.core, c = s.schema.primaryKey, l = c.outbound, f = c.extractKey, p = r.db._options.modifyChunkSize || 200, m = [], d = 0, h = [], b = function (v, g) { var C = g.failures, _ = g.numFailures; d += v - _; for (var y = 0, T = H(C); y < T.length; y++) { var R = T[y]; m.push(C[R]) } }; return r.clone().primaryKeys().then(function (v) { var g = function (C) { var _ = Math.min(p, v.length - C); return s.getMany({ trans: i, keys: v.slice(C, C + _), cache: "immutable" }).then(function (y) { for (var T = [], R = [], k = l ? [] : null, I = [], P = 0; P < _; ++P) { var U = y[P], K = { value: Kt(U), primKey: v[C + P] }; a.call(K, K.value, K) !== !1 && (K.value == null ? I.push(v[C + P]) : !l && ce(f(U), f(K.value)) !== 0 ? (I.push(v[C + P]), T.push(K.value)) : (R.push(K.value), l && k.push(v[C + P]))) } var N = nt(n) && n.limit === 1 / 0 && (typeof t != "function" || t === jr) && { index: n.index, range: n.range }; return Promise.resolve(T.length > 0 && s.mutate({ trans: i, type: "add", values: T }).then(function (G) { for (var B in G.failures) I.splice(parseInt(B), 1); b(T.length, G) })).then(function () { return (R.length > 0 || N && typeof t == "object") && s.mutate({ trans: i, type: "put", keys: k, values: R, criteria: N, changeSpec: typeof t != "function" && t }).then(function (G) { return b(R.length, G) }) }).then(function () { return (I.length > 0 || N && t === jr) && s.mutate({ trans: i, type: "delete", keys: I, criteria: N }).then(function (G) { return b(I.length, G) }) }).then(function () { return v.length > C + _ && g(C + p) }) }) }; return g(0).then(function () { if (m.length > 0) throw new hr("Error modifying one or more objects", m, d, h); return v.length }) }) }) }, e.prototype.delete = function () { var t = this._ctx, r = t.range; return nt(t) && (t.isPrimKey && !Vo || r.type === 3) ? this._write(function (n) { var i = t.table.core.schema.primaryKey, a = r; return t.table.core.count({ trans: n, query: { index: i, range: a } }).then(function (o) { return t.table.core.mutate({ trans: n, type: "deleteRange", range: a }).then(function (u) { var s = u.failures; u.lastResult, u.results; var c = u.numFailures; if (c) throw new hr("Could not delete some values", Object.keys(s).map(function (l) { return s[l] }), o - c); return o - c }) }) }) : this.modify(jr) }, e }(), jr = function (e, t) { return t.value = null }; function Xo(e) { return Gt(Yo.prototype, function (r, n) { this.db = e; var i = aa, a = null; if (n) try { i = n() } catch (c) { a = c } var o = r._ctx, u = o.table, s = u.hook.reading.fire; this._ctx = { table: u, index: o.index, isPrimKey: !o.index || u.schema.primKey.keyPath && o.index === u.schema.primKey.name, range: i, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: a, or: o.or, valueMapper: s !== Lt ? s : null } }) } function Zo(e, t) { return e < t ? -1 : e === t ? 0 : 1 } function es(e, t) { return e > t ? -1 : e === t ? 0 : 1 } function ve(e, t, r) { var n = e instanceof sa ? new e.Collection(e) : e; return n._ctx.error = r ? new r(t) : new TypeError(t), n } function it(e) { return new e.Collection(e, function () { return oa("") }).limit(0) } function ts(e) { return e === "next" ? function (t) { return t.toUpperCase() } : function (t) { return t.toLowerCase() } } function rs(e) { return e === "next" ? function (t) { return t.toLowerCase() } : function (t) { return t.toUpperCase() } } function ns(e, t, r, n, i, a) { for (var o = Math.min(e.length, n.length), u = -1, s = 0; s < o; ++s) { var c = t[s]; if (c !== n[s]) return i(e[s], r[s]) < 0 ? e.substr(0, s) + r[s] + r.substr(s + 1) : i(e[s], n[s]) < 0 ? e.substr(0, s) + n[s] + r.substr(s + 1) : u >= 0 ? e.substr(0, u) + t[u] + r.substr(u + 1) : null; i(e[s], c) < 0 && (u = s) } return o < n.length && a === "next" ? e + r.substr(e.length) : o < e.length && a === "prev" ? e.substr(0, r.length) : u < 0 ? null : e.substr(0, u) + n[u] + r.substr(u + 1) } function Qt(e, t, r, n) { var i, a, o, u, s, c, l, f = r.length; if (!r.every(function (h) { return typeof h == "string" })) return ve(e, na); function p(h) { i = ts(h), a = rs(h), o = h === "next" ? Zo : es; var b = r.map(function (v) { return { lower: a(v), upper: i(v) } }).sort(function (v, g) { return o(v.lower, g.lower) }); u = b.map(function (v) { return v.upper }), s = b.map(function (v) { return v.lower }), c = h, l = h === "next" ? "" : n } p("next"); var m = new e.Collection(e, function () { return Fe(u[0], s[f - 1] + n) }); m._ondirectionchange = function (h) { p(h) }; var d = 0; return m._addAlgorithm(function (h, b, v) { var g = h.key; if (typeof g != "string") return !1; var C = a(g); if (t(C, s, d)) return !0; for (var _ = null, y = d; y < f; ++y) { var T = ns(g, C, u[y], s[y], o, c); T === null && _ === null ? d = y + 1 : (_ === null || o(_, T) > 0) && (_ = T) } return b(_ !== null ? function () { h.continue(_ + l) } : v), !1 }), m } function Fe(e, t, r, n) { return { type: 2, lower: e, upper: t, lowerOpen: r, upperOpen: n } } function oa(e) { return { type: 1, lower: e, upper: e } } var sa = function () { function e() { } return Object.defineProperty(e.prototype, "Collection", { get: function () { return this._ctx.table.db.Collection }, enumerable: !1, configurable: !0 }), e.prototype.between = function (t, r, n, i) { n = n !== !1, i = i === !0; try { return this._cmp(t, r) > 0 || this._cmp(t, r) === 0 && (n || i) && !(n && i) ? it(this) : new this.Collection(this, function () { return Fe(t, r, !n, !i) }) } catch { return ve(this, Pe) } }, e.prototype.equals = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return oa(t) }) }, e.prototype.above = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Fe(t, void 0, !0) }) }, e.prototype.aboveOrEqual = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Fe(t, void 0, !1) }) }, e.prototype.below = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Fe(void 0, t, !1, !0) }) }, e.prototype.belowOrEqual = function (t) { return t == null ? ve(this, Pe) : new this.Collection(this, function () { return Fe(void 0, t) }) }, e.prototype.startsWith = function (t) { return typeof t != "string" ? ve(this, na) : this.between(t, t + We, !0, !0) }, e.prototype.startsWithIgnoreCase = function (t) { return t === "" ? this.startsWith(t) : Qt(this, function (r, n) { return r.indexOf(n[0]) === 0 }, [t], We) }, e.prototype.equalsIgnoreCase = function (t) { return Qt(this, function (r, n) { return r === n[0] }, [t], "") }, e.prototype.anyOfIgnoreCase = function () { var t = xe.apply(at, arguments); return t.length === 0 ? it(this) : Qt(this, function (r, n) { return n.indexOf(r) !== -1 }, t, "") }, e.prototype.startsWithAnyOfIgnoreCase = function () { var t = xe.apply(at, arguments); return t.length === 0 ? it(this) : Qt(this, function (r, n) { return n.some(function (i) { return r.indexOf(i) === 0 }) }, t, We) }, e.prototype.anyOf = function () { var t = this, r = xe.apply(at, arguments), n = this._cmp; try { r.sort(n) } catch { return ve(this, Pe) } if (r.length === 0) return it(this); var i = new this.Collection(this, function () { return Fe(r[0], r[r.length - 1]) }); i._ondirectionchange = function (o) { n = o === "next" ? t._ascending : t._descending, r.sort(n) }; var a = 0; return i._addAlgorithm(function (o, u, s) { for (var c = o.key; n(c, r[a]) > 0;)if (++a, a === r.length) return u(s), !1; return n(c, r[a]) === 0 ? !0 : (u(function () { o.continue(r[a]) }), !1) }), i }, e.prototype.notEqual = function (t) { return this.inAnyRange([[an, t], [t, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 }) }, e.prototype.noneOf = function () { var t = xe.apply(at, arguments); if (t.length === 0) return new this.Collection(this); try { t.sort(this._ascending) } catch { return ve(this, Pe) } var r = t.reduce(function (n, i) { return n ? n.concat([[n[n.length - 1][1], i]]) : [[an, i]] }, null); return r.push([t[t.length - 1], this.db._maxKey]), this.inAnyRange(r, { includeLowers: !1, includeUppers: !1 }) }, e.prototype.inAnyRange = function (t, r) { var n = this, i = this._cmp, a = this._ascending, o = this._descending, u = this._min, s = this._max; if (t.length === 0) return it(this); if (!t.every(function (y) { return y[0] !== void 0 && y[1] !== void 0 && a(y[0], y[1]) <= 0 })) return ve(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", j.InvalidArgument); var c = !r || r.includeLowers !== !1, l = r && r.includeUppers === !0; function f(y, T) { for (var R = 0, k = y.length; R < k; ++R) { var I = y[R]; if (i(T[0], I[1]) < 0 && i(T[1], I[0]) > 0) { I[0] = u(I[0], T[0]), I[1] = s(I[1], T[1]); break } } return R === k && y.push(T), y } var p = a; function m(y, T) { return p(y[0], T[0]) } var d; try { d = t.reduce(f, []), d.sort(m) } catch { return ve(this, Pe) } var h = 0, b = l ? function (y) { return a(y, d[h][1]) > 0 } : function (y) { return a(y, d[h][1]) >= 0 }, v = c ? function (y) { return o(y, d[h][0]) > 0 } : function (y) { return o(y, d[h][0]) >= 0 }; function g(y) { return !b(y) && !v(y) } var C = b, _ = new this.Collection(this, function () { return Fe(d[0][0], d[d.length - 1][1], !c, !l) }); return _._ondirectionchange = function (y) { y === "next" ? (C = b, p = a) : (C = v, p = o), d.sort(m) }, _._addAlgorithm(function (y, T, R) { for (var k = y.key; C(k);)if (++h, h === d.length) return T(R), !1; return g(k) ? !0 : (n._cmp(k, d[h][1]) === 0 || n._cmp(k, d[h][0]) === 0 || T(function () { p === a ? y.continue(d[h][0]) : y.continue(d[h][1]) }), !1) }), _ }, e.prototype.startsWithAnyOf = function () { var t = xe.apply(at, arguments); return t.every(function (r) { return typeof r == "string" }) ? t.length === 0 ? it(this) : this.inAnyRange(t.map(function (r) { return [r, r + We] })) : ve(this, "startsWithAnyOf() only works with strings") }, e }(); function is(e) { return Gt(sa.prototype, function (r, n, i) { this.db = e, this._ctx = { table: r, index: n === ":id" ? null : n, or: i }; var a = e._deps.indexedDB; if (!a) throw new j.MissingAPI; this._cmp = this._ascending = a.cmp.bind(a), this._descending = function (o, u) { return a.cmp(u, o) }, this._max = function (o, u) { return a.cmp(o, u) > 0 ? o : u }, this._min = function (o, u) { return a.cmp(o, u) < 0 ? o : u }, this._IDBKeyRange = e._deps.IDBKeyRange }) } function Se(e) { return q(function (t) { return Mt(t), e(t.target.error), !1 }) } function Mt(e) { e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault() } var jt = "storagemutated", Le = "x-storagemutated-1", Ve = $t(null, jt), as = function () { function e() { } return e.prototype._lock = function () { return St(!A.global), ++this._reculock, this._reculock === 1 && !A.global && (A.lockOwnerFor = this), this }, e.prototype._unlock = function () { if (St(!A.global), --this._reculock === 0) for (A.global || (A.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) { var t = this._blockedFuncs.shift(); try { yt(t[1], t[0]) } catch { } } return this }, e.prototype._locked = function () { return this._reculock && A.lockOwnerFor !== this }, e.prototype.create = function (t) { var r = this; if (!this.mode) return this; var n = this.db.idbdb, i = this.db._state.dbOpenError; if (St(!this.idbtrans), !t && !n) switch (i && i.name) { case "DatabaseClosedError": throw new j.DatabaseClosed(i); case "MissingAPIError": throw new j.MissingAPI(i.message, i); default: throw new j.OpenFailed(i) }if (!this.active) throw new j.TransactionInactive; return St(this._completion._state === null), t = this.idbtrans = t || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })), t.onerror = q(function (a) { Mt(a), r._reject(t.error) }), t.onabort = q(function (a) { Mt(a), r.active && r._reject(new j.Abort(t.error)), r.active = !1, r.on("abort").fire(a) }), t.oncomplete = q(function () { r.active = !1, r._resolve(), "mutatedParts" in t && Ve.storagemutated.fire(t.mutatedParts) }), this }, e.prototype._promise = function (t, r, n) { var i = this; if (t === "readwrite" && this.mode !== "readwrite") return W(new j.ReadOnly("Transaction is readonly")); if (!this.active) return W(new j.TransactionInactive); if (this._locked()) return new x(function (o, u) { i._blockedFuncs.push([function () { i._promise(t, r, n).then(o, u) }, A]) }); if (n) return $e(function () { var o = new x(function (u, s) { i._lock(); var c = r(u, s, i); c && c.then && c.then(u, s) }); return o.finally(function () { return i._unlock() }), o._lib = !0, o }); var a = new x(function (o, u) { var s = r(o, u, i); s && s.then && s.then(o, u) }); return a._lib = !0, a }, e.prototype._root = function () { return this.parent ? this.parent._root() : this }, e.prototype.waitFor = function (t) { var r = this._root(), n = x.resolve(t); if (r._waitingFor) r._waitingFor = r._waitingFor.then(function () { return n }); else { r._waitingFor = n, r._waitingQueue = []; var i = r.idbtrans.objectStore(r.storeNames[0]); (function o() { for (++r._spinCount; r._waitingQueue.length;)r._waitingQueue.shift()(); r._waitingFor && (i.get(-1 / 0).onsuccess = o) })() } var a = r._waitingFor; return new x(function (o, u) { n.then(function (s) { return r._waitingQueue.push(q(o.bind(null, s))) }, function (s) { return r._waitingQueue.push(q(u.bind(null, s))) }).finally(function () { r._waitingFor === a && (r._waitingFor = null) }) }) }, e.prototype.abort = function () { this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new j.Abort)) }, e.prototype.table = function (t) { var r = this._memoizedTables || (this._memoizedTables = {}); if (ge(r, t)) return r[t]; var n = this.schema[t]; if (!n) throw new j.NotFound("Table " + t + " not part of transaction"); var i = new this.db.Table(t, n, this); return i.core = this.db.core.table(t), r[t] = i, i }, e }(); function os(e) { return Gt(as.prototype, function (r, n, i, a, o) { var u = this; this.db = e, this.mode = r, this.storeNames = n, this.schema = i, this.chromeTransactionDurability = a, this.idbtrans = null, this.on = $t(this, "complete", "error", "abort"), this.parent = o || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new x(function (s, c) { u._resolve = s, u._reject = c }), this._completion.then(function () { u.active = !1, u.on.complete.fire() }, function (s) { var c = u.active; return u.active = !1, u.on.error.fire(s), u.parent ? u.parent._reject(s) : c && u.idbtrans && u.idbtrans.abort(), W(s) }) }) } function on(e, t, r, n, i, a, o) { return { name: e, keyPath: t, unique: r, multi: n, auto: i, compound: a, src: (r && !o ? "&" : "") + (n ? "*" : "") + (i ? "++" : "") + ca(t) } } function ca(e) { return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "" } function ua(e, t, r) { return { name: e, primKey: t, indexes: r, mappedClass: null, idxByName: Li(r, function (n) { return [n.name, n] }) } } function ss(e) { return e.length === 1 ? e[0] : e } var Bt = function (e) { try { return e.only([[]]), Bt = function () { return [[]] }, [[]] } catch { return Bt = function () { return We }, We } }; function sn(e) { return e == null ? function () { } : typeof e == "string" ? cs(e) : function (t) { return Oe(t, e) } } function cs(e) { var t = e.split("."); return t.length === 1 ? function (r) { return r[e] } : function (r) { return Oe(r, e) } } function ai(e) { return [].slice.call(e) } var us = 0; function Dt(e) { return e == null ? ":id" : typeof e == "string" ? e : "[" + e.join("+") + "]" } function ls(e, t, r) { function n(f, p) { var m = ai(f.objectStoreNames); return { schema: { name: f.name, tables: m.map(function (d) { return p.objectStore(d) }).map(function (d) { var h = d.keyPath, b = d.autoIncrement, v = ae(h), g = h == null, C = {}, _ = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g, compound: v, keyPath: h, autoIncrement: b, unique: !0, extractKey: sn(h) }, indexes: ai(d.indexNames).map(function (y) { return d.index(y) }).map(function (y) { var T = y.name, R = y.unique, k = y.multiEntry, I = y.keyPath, P = ae(I), U = { name: T, compound: P, keyPath: I, unique: R, multiEntry: k, extractKey: sn(I) }; return C[Dt(I)] = U, U }), getIndexByKeyPath: function (y) { return C[Dt(y)] } }; return C[":id"] = _.primaryKey, h != null && (C[Dt(h)] = _.primaryKey), _ }) }, hasGetAll: m.length > 0 && "getAll" in p.objectStore(m[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) } } function i(f) { if (f.type === 3) return null; if (f.type === 4) throw new Error("Cannot convert never type to IDBKeyRange"); var p = f.lower, m = f.upper, d = f.lowerOpen, h = f.upperOpen, b = p === void 0 ? m === void 0 ? null : t.upperBound(m, !!h) : m === void 0 ? t.lowerBound(p, !!d) : t.bound(p, m, !!d, !!h); return b } function a(f) { var p = f.name; function m(b) { var v = b.trans, g = b.type, C = b.keys, _ = b.values, y = b.range; return new Promise(function (T, R) { T = q(T); var k = v.objectStore(p), I = k.keyPath == null, P = g === "put" || g === "add"; if (!P && g !== "delete" && g !== "deleteRange") throw new Error("Invalid operation type: " + g); var U = (C || _ || { length: 1 }).length; if (C && _ && C.length !== _.length) throw new Error("Given keys array must have same length as given values array."); if (U === 0) return T({ numFailures: 0, failures: {}, results: [], lastResult: void 0 }); var K, N = [], G = [], B = 0, re = function (me) { ++B, Mt(me) }; if (g === "deleteRange") { if (y.type === 4) return T({ numFailures: B, failures: G, results: [], lastResult: void 0 }); y.type === 3 ? N.push(K = k.clear()) : N.push(K = k.delete(i(y))) } else { var X = P ? I ? [_, C] : [_, null] : [C, null], Q = X[0], he = X[1]; if (P) for (var se = 0; se < U; ++se)N.push(K = he && he[se] !== void 0 ? k[g](Q[se], he[se]) : k[g](Q[se])), K.onerror = re; else for (var se = 0; se < U; ++se)N.push(K = k[g](Q[se])), K.onerror = re } var be = function (me) { var Me = me.target.result; N.forEach(function (Y, je) { return Y.error != null && (G[je] = Y.error) }), T({ numFailures: B, failures: G, results: g === "delete" ? C : N.map(function (Y) { return Y.result }), lastResult: Me }) }; K.onerror = function (me) { re(me), be(me) }, K.onsuccess = be }) } function d(b) { var v = b.trans, g = b.values, C = b.query, _ = b.reverse, y = b.unique; return new Promise(function (T, R) { T = q(T); var k = C.index, I = C.range, P = v.objectStore(p), U = k.isPrimaryKey ? P : P.index(k.name), K = _ ? y ? "prevunique" : "prev" : y ? "nextunique" : "next", N = g || !("openKeyCursor" in U) ? U.openCursor(i(I), K) : U.openKeyCursor(i(I), K); N.onerror = Se(R), N.onsuccess = q(function (G) { var B = N.result; if (!B) { T(null); return } B.___id = ++us, B.done = !1; var re = B.continue.bind(B), X = B.continuePrimaryKey; X && (X = X.bind(B)); var Q = B.advance.bind(B), he = function () { throw new Error("Cursor not started") }, se = function () { throw new Error("Cursor not stopped") }; B.trans = v, B.stop = B.continue = B.continuePrimaryKey = B.advance = he, B.fail = q(R), B.next = function () { var be = this, me = 1; return this.start(function () { return me-- ? be.continue() : be.stop() }).then(function () { return be }) }, B.start = function (be) { var me = new Promise(function (Y, je) { Y = q(Y), N.onerror = Se(je), B.fail = je, B.stop = function (Be) { B.stop = B.continue = B.continuePrimaryKey = B.advance = se, Y(Be) } }), Me = function () { if (N.result) try { be() } catch (Y) { B.fail(Y) } else B.done = !0, B.start = function () { throw new Error("Cursor behind last entry") }, B.stop() }; return N.onsuccess = q(function (Y) { N.onsuccess = Me, Me() }), B.continue = re, B.continuePrimaryKey = X, B.advance = Q, Me(), me }, T(B) }, R) }) } function h(b) { return function (v) { return new Promise(function (g, C) { g = q(g); var _ = v.trans, y = v.values, T = v.limit, R = v.query, k = T === 1 / 0 ? void 0 : T, I = R.index, P = R.range, U = _.objectStore(p), K = I.isPrimaryKey ? U : U.index(I.name), N = i(P); if (T === 0) return g({ result: [] }); if (b) { var G = y ? K.getAll(N, k) : K.getAllKeys(N, k); G.onsuccess = function (Q) { return g({ result: Q.target.result }) }, G.onerror = Se(C) } else { var B = 0, re = y || !("openKeyCursor" in K) ? K.openCursor(N) : K.openKeyCursor(N), X = []; re.onsuccess = function (Q) { var he = re.result; if (!he) return g({ result: X }); if (X.push(y ? he.value : he.primaryKey), ++B === T) return g({ result: X }); he.continue() }, re.onerror = Se(C) } }) } } return { name: p, schema: f, mutate: m, getMany: function (b) { var v = b.trans, g = b.keys; return new Promise(function (C, _) { C = q(C); for (var y = v.objectStore(p), T = g.length, R = new Array(T), k = 0, I = 0, P, U = function (B) { var re = B.target; (R[re._pos] = re.result) != null, ++I === k && C(R) }, K = Se(_), N = 0; N < T; ++N) { var G = g[N]; G != null && (P = y.get(g[N]), P._pos = N, P.onsuccess = U, P.onerror = K, ++k) } k === 0 && C(R) }) }, get: function (b) { var v = b.trans, g = b.key; return new Promise(function (C, _) { C = q(C); var y = v.objectStore(p), T = y.get(g); T.onsuccess = function (R) { return C(R.target.result) }, T.onerror = Se(_) }) }, query: h(s), openCursor: d, count: function (b) { var v = b.query, g = b.trans, C = v.index, _ = v.range; return new Promise(function (y, T) { var R = g.objectStore(p), k = C.isPrimaryKey ? R : R.index(C.name), I = i(_), P = I ? k.count(I) : k.count(); P.onsuccess = q(function (U) { return y(U.target.result) }), P.onerror = Se(T) }) } } } var o = n(e, r), u = o.schema, s = o.hasGetAll, c = u.tables.map(function (f) { return a(f) }), l = {}; return c.forEach(function (f) { return l[f.name] = f }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function (f) { var p = l[f]; if (!p) throw new Error("Table '" + f + "' not found"); return l[f] }, MIN_KEY: -1 / 0, MAX_KEY: Bt(t), schema: u } } function fs(e, t) { return t.reduce(function (r, n) { var i = n.create; return F(F({}, r), i(r)) }, e) } function ps(e, t, r, n) { var i = r.IDBKeyRange; r.indexedDB; var a = fs(ls(t, i, n), e.dbcore); return { dbcore: a } } function jn(e, t) { var r = e._novip, n = t.db, i = ps(r._middlewares, n, r._deps, t); r.core = i.dbcore, r.tables.forEach(function (a) { var o = a.name; r.core.schema.tables.some(function (u) { return u.name === o }) && (a.core = r.core.table(o), r[o] instanceof r.Table && (r[o].core = a.core)) }) } function _r(e, t, r, n) { var i = e._novip; r.forEach(function (a) { var o = n[a]; t.forEach(function (u) { var s = En(u, a); (!s || "value" in s && s.value === void 0) && (u === i.Transaction.prototype || u instanceof i.Transaction ? Ae(u, a, { get: function () { return this.table(a) }, set: function (c) { Fi(this, a, { value: c, writable: !0, configurable: !0, enumerable: !0 }) } }) : u[a] = new i.Table(a, o)) }) }) } function cn(e, t) { var r = e._novip; t.forEach(function (n) { for (var i in n) n[i] instanceof r.Table && delete n[i] }) } function ds(e, t) { return e._cfg.version - t._cfg.version } function hs(e, t, r, n) { var i = e._dbSchema, a = e._createTransaction("readwrite", e._storeNames, i); a.create(r), a._completion.catch(n); var o = a._reject.bind(a), u = A.transless || A; $e(function () { A.trans = a, A.transless = u, t === 0 ? (H(i).forEach(function (s) { Bn(r, s, i[s].primKey, i[s].indexes) }), jn(e, r), x.follow(function () { return e.on.populate.fire(a) }).catch(o)) : ms(e, t, a, r).catch(o) }) } function ms(e, t, r, n) { var i = e._novip, a = [], o = i._versions, u = i._dbSchema = Fn(i, i.idbdb, n), s = !1, c = o.filter(function (f) { return f._cfg.version >= t }); c.forEach(function (f) { a.push(function () { var p = u, m = f._cfg.dbschema; ln(i, p, n), ln(i, m, n), u = i._dbSchema = m; var d = la(p, m); d.add.forEach(function (_) { Bn(n, _[0], _[1].primKey, _[1].indexes) }), d.change.forEach(function (_) { if (_.recreate) throw new j.Upgrade("Not yet support for changing primary key"); var y = n.objectStore(_.name); _.add.forEach(function (T) { return un(y, T) }), _.change.forEach(function (T) { y.deleteIndex(T.name), un(y, T) }), _.del.forEach(function (T) { return y.deleteIndex(T) }) }); var h = f._cfg.contentUpgrade; if (h && f._cfg.version > t) { jn(i, n), r._memoizedTables = {}, s = !0; var b = Ui(m); d.del.forEach(function (_) { b[_] = p[_] }), cn(i, [i.Transaction.prototype]), _r(i, [i.Transaction.prototype], H(b), b), r.schema = b; var v = Rn(h); v && vt(); var g, C = x.follow(function () { if (g = h(r), g && v) { var _ = Ie.bind(null, null); g.then(_, _) } }); return g && typeof g.then == "function" ? x.resolve(g) : C.then(function () { return g }) } }), a.push(function (p) { if (!s || !Go) { var m = f._cfg.dbschema; ys(m, p) } cn(i, [i.Transaction.prototype]), _r(i, [i.Transaction.prototype], i._storeNames, i._dbSchema), r.schema = i._dbSchema }) }); function l() { return a.length ? x.resolve(a.shift()(r.idbtrans)).then(l) : x.resolve() } return l().then(function () { vs(u, n) }) } function la(e, t) { var r = { del: [], add: [], change: [] }, n; for (n in e) t[n] || r.del.push(n); for (n in t) { var i = e[n], a = t[n]; if (!i) r.add.push([n, a]); else { var o = { name: n, def: a, recreate: !1, del: [], add: [], change: [] }; if ("" + (i.primKey.keyPath || "") != "" + (a.primKey.keyPath || "") || i.primKey.auto !== a.primKey.auto && !Rr) o.recreate = !0, r.change.push(o); else { var u = i.idxByName, s = a.idxByName, c = void 0; for (c in u) s[c] || o.del.push(c); for (c in s) { var l = u[c], f = s[c]; l ? l.src !== f.src && o.change.push(f) : o.add.push(f) } (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && r.change.push(o) } } } return r } function Bn(e, t, r, n) { var i = e.db.createObjectStore(t, r.keyPath ? { keyPath: r.keyPath, autoIncrement: r.auto } : { autoIncrement: r.auto }); return n.forEach(function (a) { return un(i, a) }), i } function vs(e, t) { H(e).forEach(function (r) { t.db.objectStoreNames.contains(r) || Bn(t, r, e[r].primKey, e[r].indexes) }) } function ys(e, t) { [].slice.call(t.db.objectStoreNames).forEach(function (r) { return e[r] == null && t.db.deleteObjectStore(r) }) } function un(e, t) { e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi }) } function Fn(e, t, r) { var n = {}, i = Pr(t.objectStoreNames, 0); return i.forEach(function (a) { for (var o = r.objectStore(a), u = o.keyPath, s = on(ca(u), u || "", !1, !1, !!o.autoIncrement, u && typeof u != "string", !0), c = [], l = 0; l < o.indexNames.length; ++l) { var f = o.index(o.indexNames[l]); u = f.keyPath; var p = on(f.name, u, !!f.unique, !!f.multiEntry, !1, u && typeof u != "string", !1); c.push(p) } n[a] = ua(a, s, c) }), n } function gs(e, t, r) { var n = e._novip; n.verno = t.version / 10; var i = n._dbSchema = Fn(n, t, r); n._storeNames = Pr(t.objectStoreNames, 0), _r(n, [n._allTables], H(i), i) } function bs(e, t) { var r = Fn(e, e.idbdb, t), n = la(r, e._dbSchema); return !(n.add.length || n.change.some(function (i) { return i.add.length || i.change.length })) } function ln(e, t, r) { for (var n = e._novip, i = r.db.objectStoreNames, a = 0; a < i.length; ++a) { var o = i[a], u = r.objectStore(o); n._hasGetAll = "getAll" in u; for (var s = 0; s < u.indexNames.length; ++s) { var c = u.indexNames[s], l = u.index(c).keyPath, f = typeof l == "string" ? l : "[" + Pr(l).join("+") + "]"; if (t[o]) { var p = t[o].idxByName[f]; p && (p.name = c, delete t[o].idxByName[f], t[o].idxByName[c] = p) } } } typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && V.WorkerGlobalScope && V instanceof V.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1) } function _s(e) { return e.split(",").map(function (t, r) { t = t.trim(); var n = t.replace(/([&*]|\+\+)/g, ""), i = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split("+") : n; return on(n, i || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), ae(i), r === 0) }) } var Cs = function () { function e() { } return e.prototype._parseStoresSpec = function (t, r) { H(t).forEach(function (n) { if (t[n] !== null) { var i = _s(t[n]), a = i.shift(); if (a.multi) throw new j.Schema("Primary key cannot be multi-valued"); i.forEach(function (o) { if (o.auto) throw new j.Schema("Only primary key can be marked as autoIncrement (++)"); if (!o.keyPath) throw new j.Schema("Index must have a name and cannot be an empty string") }), r[n] = ua(n, a, i) } }) }, e.prototype.stores = function (t) { var r = this.db; this._cfg.storesSource = this._cfg.storesSource ? ue(this._cfg.storesSource, t) : t; var n = r._versions, i = {}, a = {}; return n.forEach(function (o) { ue(i, o._cfg.storesSource), a = o._cfg.dbschema = {}, o._parseStoresSpec(i, a) }), r._dbSchema = a, cn(r, [r._allTables, r, r.Transaction.prototype]), _r(r, [r._allTables, r, r.Transaction.prototype, this._cfg.tables], H(a), a), r._storeNames = H(a), this }, e.prototype.upgrade = function (t) { return this._cfg.contentUpgrade = wn(this._cfg.contentUpgrade || $, t), this }, e }(); function Ss(e) { return Gt(Cs.prototype, function (r) { this.db = e, this._cfg = { version: r, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null } }) } function Nn(e, t) { var r = e._dbNamesDB; return r || (r = e._dbNamesDB = new zn(xr, { addons: [], indexedDB: e, IDBKeyRange: t }), r.version(1).stores({ dbnames: "name" })), r.table("dbnames") } function Kn(e) { return e && typeof e.databases == "function" } function Ts(e) { var t = e.indexedDB, r = e.IDBKeyRange; return Kn(t) ? Promise.resolve(t.databases()).then(function (n) { return n.map(function (i) { return i.name }).filter(function (i) { return i !== xr }) }) : Nn(t, r).toCollection().primaryKeys() } function ks(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !Kn(r) && t !== xr && Nn(r, n).put({ name: t }).catch($) } function Ps(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !Kn(r) && t !== xr && Nn(r, n).delete(t).catch($) } function fn(e) { return $e(function () { return A.letThrough = !0, e() }) } function Es() { var e = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent); if (!e || !indexedDB.databases) return Promise.resolve(); var t; return new Promise(function (r) { var n = function () { return indexedDB.databases().finally(r) }; t = setInterval(n, 100), n() }).finally(function () { return clearInterval(t) }) } function Rs(e) { var t = e._state, r = e._deps.indexedDB; if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function () { return t.dbOpenError ? W(t.dbOpenError) : e }); Te && (t.openCanceller._stackHolder = rt()), t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1; var n = t.openCanceller; function i() { if (t.openCanceller !== n) throw new j.DatabaseClosed("db.open() was cancelled") } var a = t.dbReadyResolve, o = null, u = !1; return x.race([n, (typeof navigator > "u" ? x.resolve() : Es()).then(function () { return new x(function (s, c) { if (i(), !r) throw new j.MissingAPI; var l = e.name, f = t.autoSchema ? r.open(l) : r.open(l, Math.round(e.verno * 10)); if (!f) throw new j.MissingAPI; f.onerror = Se(c), f.onblocked = q(e._fireOnBlocked), f.onupgradeneeded = q(function (p) { if (o = f.transaction, t.autoSchema && !e._options.allowEmptyDB) { f.onerror = Mt, o.abort(), f.result.close(); var m = r.deleteDatabase(l); m.onsuccess = m.onerror = q(function () { c(new j.NoSuchDatabase("Database " + l + " doesnt exist")) }) } else { o.onerror = Se(c); var d = p.oldVersion > Math.pow(2, 62) ? 0 : p.oldVersion; u = d < 1, e._novip.idbdb = f.result, hs(e, d / 10, o, c) } }, c), f.onsuccess = q(function () { o = null; var p = e._novip.idbdb = f.result, m = Pr(p.objectStoreNames); if (m.length > 0) try { var d = p.transaction(ss(m), "readonly"); t.autoSchema ? gs(e, p, d) : (ln(e, e._dbSchema, d), bs(e, d) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), jn(e, d) } catch { } xt.push(e), p.onversionchange = q(function (h) { t.vcFired = !0, e.on("versionchange").fire(h) }), p.onclose = q(function (h) { e.on("close").fire(h) }), u && ks(e._deps, l), s() }, c) }) })]).then(function () { return i(), t.onReadyBeingFired = [], x.resolve(fn(function () { return e.on.ready.fire(e.vip) })).then(function s() { if (t.onReadyBeingFired.length > 0) { var c = t.onReadyBeingFired.reduce(wn, $); return t.onReadyBeingFired = [], x.resolve(fn(function () { return c(e.vip) })).then(s) } }) }).finally(function () { t.onReadyBeingFired = null, t.isBeingOpened = !1 }).then(function () { return e }).catch(function (s) { t.dbOpenError = s; try { o && o.abort() } catch { } return n === t.openCanceller && e._close(), W(s) }).finally(function () { t.openComplete = !0, a() }) } function pn(e) { var t = function (o) { return e.next(o) }, r = function (o) { return e.throw(o) }, n = a(t), i = a(r); function a(o) { return function (u) { var s = o(u), c = s.value; return s.done ? c : !c || typeof c.then != "function" ? ae(c) ? Promise.all(c).then(n, i) : n(c) : c.then(n, i) } } return a(t)() } function xs(e, t, r) { var n = arguments.length; if (n < 2) throw new j.InvalidArgument("Too few arguments"); for (var i = new Array(n - 1); --n;)i[n - 1] = arguments[n]; r = i.pop(); var a = zi(i); return [e, a, r] } function fa(e, t, r, n, i) { return x.resolve().then(function () { var a = A.transless || A, o = e._createTransaction(t, r, e._dbSchema, n), u = { trans: o, transless: a }; if (n) o.idbtrans = n.idbtrans; else try { o.create(), e._state.PR1398_maxLoop = 3 } catch (f) { return f.name === Dn.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return fa(e, t, r, null, i) })) : W(f) } var s = Rn(i); s && vt(); var c, l = x.follow(function () { if (c = i.call(o, o), c) if (s) { var f = Ie.bind(null, null); c.then(f, f) } else typeof c.next == "function" && typeof c.throw == "function" && (c = pn(c)) }, u); return (c && typeof c.then == "function" ? x.resolve(c).then(function (f) { return o.active ? f : W(new j.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")) }) : l.then(function () { return c })).then(function (f) { return n && o._resolve(), o._completion.then(function () { return f }) }).catch(function (f) { return o._reject(f), W(f) }) }) } function Yt(e, t, r) { for (var n = ae(e) ? e.slice() : [e], i = 0; i < r; ++i)n.push(t); return n } function Ds(e) { return F(F({}, e), { table: function (t) { var r = e.table(t), n = r.schema, i = {}, a = []; function o(h, b, v) { var g = Dt(h), C = i[g] = i[g] || [], _ = h == null ? 0 : typeof h == "string" ? 1 : h.length, y = b > 0, T = F(F({}, v), { isVirtual: y, keyTail: b, keyLength: _, extractKey: sn(h), unique: !y && v.unique }); if (C.push(T), T.isPrimaryKey || a.push(T), _ > 1) { var R = _ === 2 ? h[0] : h.slice(0, _ - 1); o(R, b + 1, v) } return C.sort(function (k, I) { return k.keyTail - I.keyTail }), T } var u = o(n.primaryKey.keyPath, 0, n.primaryKey); i[":id"] = [u]; for (var s = 0, c = n.indexes; s < c.length; s++) { var l = c[s]; o(l.keyPath, 0, l) } function f(h) { var b = i[Dt(h)]; return b && b[0] } function p(h, b) { return { type: h.type === 1 ? 2 : h.type, lower: Yt(h.lower, h.lowerOpen ? e.MAX_KEY : e.MIN_KEY, b), lowerOpen: !0, upper: Yt(h.upper, h.upperOpen ? e.MIN_KEY : e.MAX_KEY, b), upperOpen: !0 } } function m(h) { var b = h.query.index; return b.isVirtual ? F(F({}, h), { query: { index: b, range: p(h.query.range, b.keyTail) } }) : h } var d = F(F({}, r), { schema: F(F({}, n), { primaryKey: u, indexes: a, getIndexByKeyPath: f }), count: function (h) { return r.count(m(h)) }, query: function (h) { return r.query(m(h)) }, openCursor: function (h) { var b = h.query.index, v = b.keyTail, g = b.isVirtual, C = b.keyLength; if (!g) return r.openCursor(h); function _(y) { function T(k) { k != null ? y.continue(Yt(k, h.reverse ? e.MAX_KEY : e.MIN_KEY, v)) : h.unique ? y.continue(y.key.slice(0, C).concat(h.reverse ? e.MIN_KEY : e.MAX_KEY, v)) : y.continue() } var R = Object.create(y, { continue: { value: T }, continuePrimaryKey: { value: function (k, I) { y.continuePrimaryKey(Yt(k, e.MAX_KEY, v), I) } }, primaryKey: { get: function () { return y.primaryKey } }, key: { get: function () { var k = y.key; return C === 1 ? k[0] : k.slice(0, C) } }, value: { get: function () { return y.value } } }); return R } return r.openCursor(m(h)).then(function (y) { return y && _(y) }) } }); return d } }) } var ws = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: Ds }; function Ln(e, t, r, n) { return r = r || {}, n = n || "", H(e).forEach(function (i) { if (!ge(t, i)) r[n + i] = void 0; else { var a = e[i], o = t[i]; if (typeof a == "object" && typeof o == "object" && a && o) { var u = qr(a), s = qr(o); u !== s ? r[n + i] = t[i] : u === "Object" ? Ln(a, o, r, n + i + ".") : a !== o && (r[n + i] = t[i]) } else a !== o && (r[n + i] = t[i]) } }), H(t).forEach(function (i) { ge(e, i) || (r[n + i] = t[i]) }), r } function Os(e, t) { return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey) } var As = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function (e) { return F(F({}, e), { table: function (t) { var r = e.table(t), n = r.schema.primaryKey, i = F(F({}, r), { mutate: function (a) { var o = A.trans, u = o.table(t).hook, s = u.deleting, c = u.creating, l = u.updating; switch (a.type) { case "add": if (c.fire === $) break; return o._promise("readwrite", function () { return f(a) }, !0); case "put": if (c.fire === $ && l.fire === $) break; return o._promise("readwrite", function () { return f(a) }, !0); case "delete": if (s.fire === $) break; return o._promise("readwrite", function () { return f(a) }, !0); case "deleteRange": if (s.fire === $) break; return o._promise("readwrite", function () { return p(a) }, !0) }return r.mutate(a); function f(d) { var h = A.trans, b = d.keys || Os(n, d); if (!b) throw new Error("Keys missing"); return d = d.type === "add" || d.type === "put" ? F(F({}, d), { keys: b }) : F({}, d), d.type !== "delete" && (d.values = Gr([], d.values, !0)), d.keys && (d.keys = Gr([], d.keys, !0)), Is(r, d, b).then(function (v) { var g = b.map(function (C, _) { var y = v[_], T = { onerror: null, onsuccess: null }; if (d.type === "delete") s.fire.call(T, C, y, h); else if (d.type === "add" || y === void 0) { var R = c.fire.call(T, C, d.values[_], h); C == null && R != null && (C = R, d.keys[_] = C, n.outbound || Ce(d.values[_], n.keyPath, C)) } else { var k = Ln(y, d.values[_]), I = l.fire.call(T, k, C, y, h); if (I) { var P = d.values[_]; Object.keys(I).forEach(function (U) { ge(P, U) ? P[U] = I[U] : Ce(P, U, I[U]) }) } } return T }); return r.mutate(d).then(function (C) { for (var _ = C.failures, y = C.results, T = C.numFailures, R = C.lastResult, k = 0; k < b.length; ++k) { var I = y ? y[k] : b[k], P = g[k]; I == null ? P.onerror && P.onerror(_[k]) : P.onsuccess && P.onsuccess(d.type === "put" && v[k] ? d.values[k] : I) } return { failures: _, results: y, numFailures: T, lastResult: R } }).catch(function (C) { return g.forEach(function (_) { return _.onerror && _.onerror(C) }), Promise.reject(C) }) }) } function p(d) { return m(d.trans, d.range, 1e4) } function m(d, h, b) { return r.query({ trans: d, values: !1, query: { index: n, range: h }, limit: b }).then(function (v) { var g = v.result; return f({ type: "delete", keys: g, trans: d }).then(function (C) { return C.numFailures > 0 ? Promise.reject(C.failures[0]) : g.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : m(d, F(F({}, h), { lower: g[g.length - 1], lowerOpen: !0 }), b) }) }) } } }); return i } }) } }; function Is(e, t, r) { return t.type === "add" ? Promise.resolve([]) : e.getMany({ trans: t.trans, keys: r, cache: "immutable" }) } function pa(e, t, r) { try { if (!t || t.keys.length < e.length) return null; for (var n = [], i = 0, a = 0; i < t.keys.length && a < e.length; ++i)ce(t.keys[i], e[a]) === 0 && (n.push(r ? Kt(t.values[i]) : t.values[i]), ++a); return n.length === e.length ? n : null } catch { return null } } var Ms = { stack: "dbcore", level: -1, create: function (e) { return { table: function (t) { var r = e.table(t); return F(F({}, r), { getMany: function (n) { if (!n.cache) return r.getMany(n); var i = pa(n.keys, n.trans._cache, n.cache === "clone"); return i ? x.resolve(i) : r.getMany(n).then(function (a) { return n.trans._cache = { keys: n.keys, values: n.cache === "clone" ? Kt(a) : a }, a }) }, mutate: function (n) { return n.type !== "add" && (n.trans._cache = null), r.mutate(n) } }) } } } }, Br; function Un(e) { return !("from" in e) } var Re = function (e, t) { if (this) ue(this, arguments.length ? { d: 1, from: e, to: arguments.length > 1 ? t : e } : { d: 0 }); else { var r = new Re; return e && "d" in e && ue(r, e), r } }; pt(Re.prototype, (Br = { add: function (e) { return Cr(this, e), this }, addKey: function (e) { return Ft(this, e, e), this }, addKeys: function (e) { var t = this; return e.forEach(function (r) { return Ft(t, r, r) }), this } }, Br[Jr] = function () { return dn(this) }, Br)); function Ft(e, t, r) { var n = ce(t, r); if (!isNaN(n)) { if (n > 0) throw RangeError(); if (Un(e)) return ue(e, { from: t, to: r, d: 1 }); var i = e.l, a = e.r; if (ce(r, e.from) < 0) return i ? Ft(i, t, r) : e.l = { from: t, to: r, d: 1, l: null, r: null }, oi(e); if (ce(t, e.to) > 0) return a ? Ft(a, t, r) : e.r = { from: t, to: r, d: 1, l: null, r: null }, oi(e); ce(t, e.from) < 0 && (e.from = t, e.l = null, e.d = a ? a.d + 1 : 1), ce(r, e.to) > 0 && (e.to = r, e.r = null, e.d = e.l ? e.l.d + 1 : 1); var o = !e.r; i && !e.l && Cr(e, i), a && o && Cr(e, a) } } function Cr(e, t) { function r(n, i) { var a = i.from, o = i.to, u = i.l, s = i.r; Ft(n, a, o), u && r(n, u), s && r(n, s) } Un(t) || r(e, t) } function js(e, t) { var r = dn(t), n = r.next(); if (n.done) return !1; for (var i = n.value, a = dn(e), o = a.next(i.from), u = o.value; !n.done && !o.done;) { if (ce(u.from, i.to) <= 0 && ce(u.to, i.from) >= 0) return !0; ce(i.from, u.from) < 0 ? i = (n = r.next(u.from)).value : u = (o = a.next(i.from)).value } return !1 } function dn(e) { var t = Un(e) ? null : { s: 0, n: e }; return { next: function (r) { for (var n = arguments.length > 0; t;)switch (t.s) { case 0: if (t.s = 1, n) for (; t.n.l && ce(r, t.n.from) < 0;)t = { up: t, n: t.n.l, s: 1 }; else for (; t.n.l;)t = { up: t, n: t.n.l, s: 1 }; case 1: if (t.s = 2, !n || ce(r, t.n.to) <= 0) return { value: t.n, done: !1 }; case 2: if (t.n.r) { t.s = 3, t = { up: t, n: t.n.r, s: 0 }; continue } case 3: t = t.up }return { done: !0 } } } } function oi(e) { var t, r, n = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((r = e.l) === null || r === void 0 ? void 0 : r.d) || 0), i = n > 1 ? "r" : n < -1 ? "l" : ""; if (i) { var a = i === "r" ? "l" : "r", o = F({}, e), u = e[i]; e.from = u.from, e.to = u.to, e[i] = u[i], o[i] = u[a], e[a] = o, o.d = si(o) } e.d = si(e) } function si(e) { var t = e.r, r = e.l; return (t ? r ? Math.max(t.d, r.d) : t.d : r ? r.d : 0) + 1 } var Bs = { stack: "dbcore", level: 0, create: function (e) { var t = e.schema.name, r = new Re(e.MIN_KEY, e.MAX_KEY); return F(F({}, e), { table: function (n) { var i = e.table(n), a = i.schema, o = a.primaryKey, u = o.extractKey, s = o.outbound, c = F(F({}, i), { mutate: function (p) { var m = p.trans, d = m.mutatedParts || (m.mutatedParts = {}), h = function (R) { var k = "idb://" + t + "/" + n + "/" + R; return d[k] || (d[k] = new Re) }, b = h(""), v = h(":dels"), g = p.type, C = p.type === "deleteRange" ? [p.range] : p.type === "delete" ? [p.keys] : p.values.length < 50 ? [[], p.values] : [], _ = C[0], y = C[1], T = p.trans._cache; return i.mutate(p).then(function (R) { if (ae(_)) { g !== "delete" && (_ = R.results), b.addKeys(_); var k = pa(_, T); !k && g !== "add" && v.addKeys(_), (k || y) && Fs(h, a, k, y) } else if (_) { var I = { from: _.lower, to: _.upper }; v.add(I), b.add(I) } else b.add(r), v.add(r), a.indexes.forEach(function (P) { return h(P.name).add(r) }); return R }) } }), l = function (p) { var m, d, h = p.query, b = h.index, v = h.range; return [b, new Re((m = v.lower) !== null && m !== void 0 ? m : e.MIN_KEY, (d = v.upper) !== null && d !== void 0 ? d : e.MAX_KEY)] }, f = { get: function (p) { return [o, new Re(p.key)] }, getMany: function (p) { return [o, new Re().addKeys(p.keys)] }, count: l, query: l, openCursor: l }; return H(f).forEach(function (p) { c[p] = function (m) { var d = A.subscr; if (d) { var h = function (T) { var R = "idb://" + t + "/" + n + "/" + T; return d[R] || (d[R] = new Re) }, b = h(""), v = h(":dels"), g = f[p](m), C = g[0], _ = g[1]; if (h(C.name || "").add(_), !C.isPrimaryKey) if (p === "count") v.add(r); else { var y = p === "query" && s && m.values && i.query(F(F({}, m), { values: !1 })); return i[p].apply(this, arguments).then(function (T) { if (p === "query") { if (s && m.values) return y.then(function (P) { var U = P.result; return b.addKeys(U), T }); var R = m.values ? T.result.map(u) : T.result; m.values ? b.addKeys(R) : v.addKeys(R) } else if (p === "openCursor") { var k = T, I = m.values; return k && Object.create(k, { key: { get: function () { return v.addKey(k.primaryKey), k.key } }, primaryKey: { get: function () { var P = k.primaryKey; return v.addKey(P), P } }, value: { get: function () { return I && b.addKey(k.primaryKey), k.value } } }) } return T }) } } return i[p].apply(this, arguments) } }), c } }) } }; function Fs(e, t, r, n) { function i(a) { var o = e(a.name || ""); function u(c) { return c != null ? a.extractKey(c) : null } var s = function (c) { return a.multiEntry && ae(c) ? c.forEach(function (l) { return o.addKey(l) }) : o.addKey(c) }; (r || n).forEach(function (c, l) { var f = r && u(r[l]), p = n && u(n[l]); ce(f, p) !== 0 && (f != null && s(f), p != null && s(p)) }) } t.indexes.forEach(i) } var zn = function () { function e(t, r) { var n = this; this._middlewares = {}, this.verno = 0; var i = e.dependencies; this._options = r = F({ addons: e.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange }, r), this._deps = { indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange }; var a = r.addons; this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this; var o = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: $, dbReadyPromise: null, cancelOpen: $, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 }; o.dbReadyPromise = new x(function (u) { o.dbReadyResolve = u }), o.openCanceller = new x(function (u, s) { o.cancelOpen = s }), this._state = o, this.name = t, this.on = $t(this, "populate", "blocked", "versionchange", "close", { ready: [wn, $] }), this.on.ready.subscribe = Ni(this.on.ready.subscribe, function (u) { return function (s, c) { e.vip(function () { var l = n._state; if (l.openComplete) l.dbOpenError || x.resolve().then(s), c && u(s); else if (l.onReadyBeingFired) l.onReadyBeingFired.push(s), c && u(s); else { u(s); var f = n; c || u(function p() { f.on.ready.unsubscribe(s), f.on.ready.unsubscribe(p) }) } }) } }), this.Collection = Xo(this), this.Table = Jo(this), this.Transaction = os(this), this.Version = Ss(this), this.WhereClause = is(this), this.on("versionchange", function (u) { u.newVersion > 0 ? console.warn("Another connection wants to upgrade database '" + n.name + "'. Closing db now to resume the upgrade.") : console.warn("Another connection wants to delete database '" + n.name + "'. Closing db now to resume the delete request."), n.close() }), this.on("blocked", function (u) { !u.newVersion || u.newVersion < u.oldVersion ? console.warn("Dexie.delete('" + n.name + "') was blocked") : console.warn("Upgrade '" + n.name + "' blocked by other connection holding version " + u.oldVersion / 10) }), this._maxKey = Bt(r.IDBKeyRange), this._createTransaction = function (u, s, c, l) { return new n.Transaction(u, s, c, n._options.chromeTransactionDurability, l) }, this._fireOnBlocked = function (u) { n.on("blocked").fire(u), xt.filter(function (s) { return s.name === n.name && s !== n && !s._state.vcFired }).map(function (s) { return s.on("versionchange").fire(u) }) }, this.use(ws), this.use(As), this.use(Bs), this.use(Ms), this.vip = Object.create(this, { _vip: { value: !0 } }), a.forEach(function (u) { return u(n) }) } return e.prototype.version = function (t) { if (isNaN(t) || t < .1) throw new j.Type("Given version is not a positive number"); if (t = Math.round(t * 10) / 10, this.idbdb || this._state.isBeingOpened) throw new j.Schema("Cannot add version when database is open"); this.verno = Math.max(this.verno, t); var r = this._versions, n = r.filter(function (i) { return i._cfg.version === t })[0]; return n || (n = new this.Version(t), r.push(n), r.sort(ds), n.stores({}), this._state.autoSchema = !1, n) }, e.prototype._whenReady = function (t) { var r = this; return this.idbdb && (this._state.openComplete || A.letThrough || this._vip) ? t() : new x(function (n, i) { if (r._state.openComplete) return i(new j.DatabaseClosed(r._state.dbOpenError)); if (!r._state.isBeingOpened) { if (!r._options.autoOpen) { i(new j.DatabaseClosed); return } r.open().catch($) } r._state.dbReadyPromise.then(n, i) }).then(t) }, e.prototype.use = function (t) { var r = t.stack, n = t.create, i = t.level, a = t.name; a && this.unuse({ stack: r, name: a }); var o = this._middlewares[r] || (this._middlewares[r] = []); return o.push({ stack: r, create: n, level: i == null ? 10 : i, name: a }), o.sort(function (u, s) { return u.level - s.level }), this }, e.prototype.unuse = function (t) { var r = t.stack, n = t.name, i = t.create; return r && this._middlewares[r] && (this._middlewares[r] = this._middlewares[r].filter(function (a) { return i ? a.create !== i : n ? a.name !== n : !1 })), this }, e.prototype.open = function () { return Rs(this) }, e.prototype._close = function () { var t = this._state, r = xt.indexOf(this); if (r >= 0 && xt.splice(r, 1), this.idbdb) { try { this.idbdb.close() } catch { } this._novip.idbdb = null } t.dbReadyPromise = new x(function (n) { t.dbReadyResolve = n }), t.openCanceller = new x(function (n, i) { t.cancelOpen = i }) }, e.prototype.close = function () { this._close(); var t = this._state; this._options.autoOpen = !1, t.dbOpenError = new j.DatabaseClosed, t.isBeingOpened && t.cancelOpen(t.dbOpenError) }, e.prototype.delete = function () { var t = this, r = arguments.length > 0, n = this._state; return new x(function (i, a) { var o = function () { t.close(); var u = t._deps.indexedDB.deleteDatabase(t.name); u.onsuccess = q(function () { Ps(t._deps, t.name), i() }), u.onerror = Se(a), u.onblocked = t._fireOnBlocked }; if (r) throw new j.InvalidArgument("Arguments not allowed in db.delete()"); n.isBeingOpened ? n.dbReadyPromise.then(o) : o() }) }, e.prototype.backendDB = function () { return this.idbdb }, e.prototype.isOpen = function () { return this.idbdb !== null }, e.prototype.hasBeenClosed = function () { var t = this._state.dbOpenError; return t && t.name === "DatabaseClosed" }, e.prototype.hasFailed = function () { return this._state.dbOpenError !== null }, e.prototype.dynamicallyOpened = function () { return this._state.autoSchema }, Object.defineProperty(e.prototype, "tables", { get: function () { var t = this; return H(this._allTables).map(function (r) { return t._allTables[r] }) }, enumerable: !1, configurable: !0 }), e.prototype.transaction = function () { var t = xs.apply(this, arguments); return this._transaction.apply(this, t) }, e.prototype._transaction = function (t, r, n) { var i = this, a = A.trans; (!a || a.db !== this || t.indexOf("!") !== -1) && (a = null); var o = t.indexOf("?") !== -1; t = t.replace("!", "").replace("?", ""); var u, s; try { if (s = r.map(function (l) { var f = l instanceof i.Table ? l.name : l; if (typeof f != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed"); return f }), t == "r" || t === Or) u = Or; else if (t == "rw" || t == Ar) u = Ar; else throw new j.InvalidArgument("Invalid transaction mode: " + t); if (a) { if (a.mode === Or && u === Ar) if (o) a = null; else throw new j.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY"); a && s.forEach(function (l) { if (a && a.storeNames.indexOf(l) === -1) if (o) a = null; else throw new j.SubTransaction("Table " + l + " not included in parent transaction.") }), o && a && !a.active && (a = null) } } catch (l) { return a ? a._promise(null, function (f, p) { p(l) }) : W(l) } var c = fa.bind(null, this, u, s, a, n); return a ? a._promise(u, c, "lock") : A.trans ? yt(A.transless, function () { return i._whenReady(c) }) : this._whenReady(c) }, e.prototype.table = function (t) { if (!ge(this._allTables, t)) throw new j.InvalidTable("Table " + t + " does not exist"); return this._allTables[t] }, e }(), Ns = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ks = function () { function e(t) { this._subscribe = t } return e.prototype.subscribe = function (t, r, n) { return this._subscribe(!t || typeof t == "function" ? { next: t, error: r, complete: n } : t) }, e.prototype[Ns] = function () { return this }, e }(); function da(e, t) { return H(t).forEach(function (r) { var n = e[r] || (e[r] = new Re); Cr(n, t[r]) }), e } function Ls(e) { return new Ks(function (t) { var r = Rn(e); function n(m) { r && vt(); var d = function () { return $e(e, { subscr: m, trans: null }) }, h = A.trans ? yt(A.transless, d) : d(); return r && h.then(Ie, Ie), h } var i = !1, a = {}, o = {}, u = { get closed() { return i }, unsubscribe: function () { i = !0, Ve.storagemutated.unsubscribe(f) } }; t.start && t.start(u); var s = !1, c = !1; function l() { return H(o).some(function (m) { return a[m] && js(a[m], o[m]) }) } var f = function (m) { da(a, m), l() && p() }, p = function () { if (!(s || i)) { a = {}; var m = {}, d = n(m); c || (Ve(jt, f), c = !0), s = !0, Promise.resolve(d).then(function (h) { s = !1, !i && (l() ? p() : (a = {}, o = m, t.next && t.next(h))) }, function (h) { s = !1, t.error && t.error(h), u.unsubscribe() }) } }; return p(), u }) } var hn; try { hn = { indexedDB: V.indexedDB || V.mozIndexedDB || V.webkitIndexedDB || V.msIndexedDB, IDBKeyRange: V.IDBKeyRange || V.webkitIDBKeyRange } } catch { hn = { indexedDB: null, IDBKeyRange: null } } var He = zn; pt(He, F(F({}, Er), { delete: function (e) { var t = new He(e, { addons: [] }); return t.delete() }, exists: function (e) { return new He(e, { addons: [] }).open().then(function (t) { return t.close(), !0 }).catch("NoSuchDatabaseError", function () { return !1 }) }, getDatabaseNames: function (e) { try { return Ts(He.dependencies).then(e) } catch { return W(new j.MissingAPI) } }, defineClass: function () { function e(t) { ue(this, t) } return e }, ignoreTransaction: function (e) { return A.trans ? yt(A.transless, e) : e() }, vip: fn, async: function (e) { return function () { try { var t = pn(e.apply(this, arguments)); return !t || typeof t.then != "function" ? x.resolve(t) : t } catch (r) { return W(r) } } }, spawn: function (e, t, r) { try { var n = pn(e.apply(r, t || [])); return !n || typeof n.then != "function" ? x.resolve(n) : n } catch (i) { return W(i) } }, currentTransaction: { get: function () { return A.trans || null } }, waitFor: function (e, t) { var r = x.resolve(typeof e == "function" ? He.ignoreTransaction(e) : e).timeout(t || 6e4); return A.trans ? A.trans.waitFor(r) : r }, Promise: x, debug: { get: function () { return Te }, set: function (e) { Gi(e, e === "dexie" ? function () { return !0 } : ia) } }, derive: ht, extend: ue, props: pt, override: Ni, Events: $t, on: Ve, liveQuery: Ls, extendObservabilitySet: da, getByKeyPath: Oe, setByKeyPath: Ce, delByKeyPath: go, shallowClone: Ui, deepClone: Kt, getObjectDiff: Ln, cmp: ce, asap: Ki, minKey: an, addons: [], connections: xt, errnames: Dn, dependencies: hn, semVer: ei, version: ei.split(".").map(function (e) { return parseInt(e) }).reduce(function (e, t, r) { return e + t / Math.pow(10, r * 2) }) })); He.maxKey = Bt(He.dependencies.IDBKeyRange); typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ve(jt, function (e) { if (!De) { var t; Rr ? (t = document.createEvent("CustomEvent"), t.initCustomEvent(Le, !0, !0, e)) : t = new CustomEvent(Le, { detail: e }), De = !0, dispatchEvent(t), De = !1 } }), addEventListener(Le, function (e) { var t = e.detail; De || Sr(t) })); function Sr(e) { var t = De; try { De = !0, Ve.storagemutated.fire(e) } finally { De = t } } var De = !1; if (typeof BroadcastChannel < "u") { var ci = new BroadcastChannel(Le); Ve(jt, function (e) { De || ci.postMessage(e) }), ci.onmessage = function (e) { e.data && Sr(e.data) } } else if (typeof self < "u" && typeof navigator < "u") { Ve(jt, function (e) { try { De || (typeof localStorage < "u" && localStorage.setItem(Le, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && Gr([], self.clients.matchAll({ includeUncontrolled: !0 }), !0).forEach(function (t) { return t.postMessage({ type: Le, changedParts: e }) })) } catch { } }), typeof addEventListener < "u" && addEventListener("storage", function (e) { if (e.key === Le) { var t = JSON.parse(e.newValue); t && Sr(t.changedParts) } }); var ui = self.document && navigator.serviceWorker; ui && ui.addEventListener("message", Us) } function Us(e) { var t = e.data; t && t.type === Le && Sr(t.changedParts) } x.rejectionMapper = Ro; Gi(Te, ia); var ha = (e => (e.available = "available", e.loaded = "loaded", e.depleted = "depleted", e))(ha || {}); class ma { constructor(t, r, n, i, a, o, u, s, c, l, f, p, m, d) { E(this, "id"); E(this, "brand"); E(this, "material"); E(this, "color"); E(this, "cost"); E(this, "currency"); E(this, "status"); E(this, "weightTotal"); E(this, "weightPrinted"); E(this, "density"); E(this, "diameter"); E(this, "dateBought"); E(this, "nozzleTemperature"); E(this, "bedTemperature"); E(this, "filamentDepletedCutoff"); this.id = t, this.brand = r, this.material = n, this.color = i, this.cost = a, this.currency = o, this.status = "loaded", this.weightTotal = u, this.weightPrinted = s, this.diameter = l, this.density = c, this.dateBought = f, this.nozzleTemperature = p, this.bedTemperature = m, this.filamentDepletedCutoff = d, this.weightTotal - this.weightPrinted < this.filamentDepletedCutoff && (this.status = "depleted") } get name() { return `${this.brand} ${this.material}` } get percentRemaining() { return Math.round((this.weightTotal - this.weightPrinted) / this.weightTotal * 100) } get percentPrinted() { return Math.round(this.weightPrinted / this.weightTotal * 100) } get weightRemaining() { return this.weightTotal - this.weightPrinted } get costPrinted() { return this.cost - this.percentRemaining * this.cost } get costRemaining() { return this.percentRemaining * this.cost } save(t) { O.filaments.update(this.id, t) } add() { O.filaments.add(this) } remove() { O.filaments.delete(this.id) } toString() { return `${this.brand} ${this.material} status: ${this.status}` } } class va { constructor(t, r, n, i, a, o) { E(this, "id"); E(this, "fileName"); E(this, "parentDir"); E(this, "isWorkSpaceFile"); E(this, "type"); E(this, "uploaderName"); E(this, "fileContent"); this.id = t, this.fileName = r, this.parentDir = n, this.isWorkSpaceFile = i, this.uploaderName = a, this.type = o } save(t) { O.nanofactoryFiles.update(this.id, t) } add() { O.nanofactoryFiles.add(this) } remove() { O.nanofactoryFiles.delete(this.id) } } class ya { constructor(t) { E(this, "id"); E(this, "peerID"); E(this, "apiKey"); E(this, "masterPeerID"); this.id = t } async save(t) { await O.networking.update(this.id, t) } async add() { await O.networking.add(this) } remove() { O.networking.delete(this.id) } } var dt = (e => (e.AVAILABLE = "available", e.WHITELISTED = "whitelisted", e.BLACKLISTED = "blacklisted", e))(dt || {}); class ga { constructor() { E(this, "id"); E(this, "whitelisted"); E(this, "blacklisted"); E(this, "available"); this.id = "1", this.whitelisted = new Set([]), this.blacklisted = new Set([]), this.available = new Set([]) } async save(t) { await O.nanofactoryPeers.update(this.id, t) } async add() { await O.nanofactoryPeers.add(this) } remove() { O.nanofactoryPeers.delete(this.id) } async addToList(t, r) { this[t].add(r), t === "whitelisted" && this.available.add(r), await O.nanofactoryPeers.put(this, this.id) } async removeFromList(t, r) { console.log("remove from list called"), console.log(this[t].size), this[t].delete(r), console.log(this[t].size), t === "whitelisted" && this.available.delete(r), await O.nanofactoryPeers.put(this, this.id) } } var Qe = (e => (e.operational = "Operational", e.offline = "Offline", e.printing = "Printing", e.error = "Error", e.paused = "Paused", e))(Qe || {}), Ze = (e => (e.printerOffline = "Printer is offline", e.printerError = "Printer is in error state", e.printerPaused = "User has paused the queue", e.noFilament = "No filament is loaded", e.depltedFilament = "Filament is depleted", e.filamentMismatch = "Assigned filament does not match the one loaded", e.printPaused = "Current print has been paused", e.printCompletion = "Print has been completed", e.printCancelled = "Print has been cancelled", e.printFailed = "Print has failed", e.noJob = "Printer has not been assigned a job", e.queueNotPaused = "", e))(Ze || {}); class ba { constructor(t) { E(this, "id"); E(this, "name"); E(this, "color"); E(this, "model"); E(this, "volume"); E(this, "heatedBed"); E(this, "heatedChamber"); E(this, "axes"); E(this, "extruder"); E(this, "state"); E(this, "bedLevellingGraph"); E(this, "position"); E(this, "connectionOptions"); E(this, "temperatureHistory"); E(this, "filamentID"); E(this, "isQueuePaused"); E(this, "queuePausedReason"); E(this, "nanofactoryInstallDate"); this.id = t, this.name = "", this.model = "", this.volume = { formFactor: "rectangular", centerOrigin: "center", width: 0, depth: 0, height: 0 }, this.heatedBed = !0, this.heatedChamber = !1, this.nanofactoryInstallDate = new Date, this.state = { status: "Offline" }, this.connectionOptions = { ports: [], baudrates: [], printerProfiles: [], portPreference: "auto", baudratePreference: "auto", printerProfilePreference: "_default", autoconnect: !1 }, this.temperatureHistory = [], this.axes = { x: { inverted: !1, speed: 0 }, y: { inverted: !1, speed: 0 }, z: { inverted: !1, speed: 0 }, e: { inverted: !1, speed: 0 } }, this.extruder = { count: 1, offsets: [] }, this.position = { x: 0, y: 0, z: 0, e: 0, relative: !1, speed: 0 }, this.filamentID = "", this.isQueuePaused = !0, this.queuePausedReason = "Printer has not been assigned a job" } async save(t) { await O.printer.update(this.id, t) } async add() { await O.printer.add(this) } remove() { O.printer.delete(this.id) } toString() { return `${this.model} ${this.name} status: ${this.state.status}` } } var ct = (e => (e.TOPRINT = "To Print", e.PRINTING = "Printing", e.DONE = "Done", e.FAILED = "Failed", e.CANCELLED = "Cancelled", e))(ct || {}); class mn { constructor(t, r, n, i, a, o, u, s, c, l) { E(this, "id"); E(this, "printerID"); E(this, "jobName"); E(this, "status"); E(this, "assignerName"); E(this, "estimatedPrintTime"); E(this, "lastPrintTime"); E(this, "estimatedFilamentUsage"); E(this, "actualFilamentUsage"); E(this, "progress"); E(this, "createdDate"); E(this, "startTime"); E(this, "endTime"); E(this, "queuePosition"); E(this, "file"); E(this, "filamentID"); this.id = t, this.printerID = r, this.jobName = n, this.status = "To Print", this.assignerName = i, this.estimatedPrintTime = a != null ? a : 0, this.estimatedFilamentUsage = o != null ? o : { length: 0, volume: 0 }, this.actualFilamentUsage = { length: 0, volume: 0 }, this.createdDate = u != null ? u : new Date().toISOString(), this.progress = { completion: 0, filePosition: 0, printTime: 0, printTimeLeft: 0 }, this.queuePosition = s, this.file = c, this.filamentID = l } async calculatePosition() { let t = 0, r = await O.printQueue.reverse().sortBy("queuePosition"); r.length > 0 && (t = r[0].queuePosition), this.queuePosition = t + 1 } async add(t) { t === "printQueue" ? (await this.calculatePosition(), O.printQueue.add(this)) : (console.log("Add to jobs history called"), O.jobsHistory.add(this)) } remove(t) { t === "printQueue" ? O.printQueue.delete(this.id) : O.jobsHistory.delete(this.id) } async save(t, r) { t === "printQueue" ? await O.printQueue.update(this.id, r) : O.jobsHistory.update(this.id, r) } async getEstimatedFilamentWeight() { let t = await O.filaments.get(this.filamentID); return t ? t.density * this.estimatedFilamentUsage.volume : 0 } async getUsedFilamentWeight() { let t = await O.filaments.get(this.filamentID); return t ? t.density * this.actualFilamentUsage.volume : 0 } toString() { return `${this.jobName}` } } class _a { constructor(t, r, n, i) { E(this, "id"); E(this, "name"); E(this, "printerID"); E(this, "script"); E(this, "filamentAction"); E(this, "execute"); this.id = t, this.name = r, this.printerID = L.peerID, this.script = n, this.filamentAction = i, this.execute = !1 } save(t) { O.actions.update(this.id, t) } add() { O.actions.add(this) } remove() { O.actions.delete(this.id) } toString() { return `${this.name}` } } class zs extends zn { constructor() { super("NanofactoryDatabase"); E(this, "printer"); E(this, "networking"); E(this, "printQueue"); E(this, "filaments"); E(this, "nanofactoryFiles"); E(this, "nanofactoryPeers"); E(this, "jobsHistory"); E(this, "actions"); this.version(1.3).stores({ printer: "id", networking: "id, peerID, apiKey", printQueue: "id,filamentID, queuePosition", filaments: "id", nanofactoryFiles: "id, filename", nanofactoryPeers: "id, available, whitelisted, blacklisted", jobsHistory: "id, status, createdDate, filamentID", actions: "id, name" }), this.version(1.2).stores({ printer: "id", networking: "id, peerID, apiKey", printQueue: "id,filamentID, queuePosition", filaments: "id", nanofactoryFiles: "id, filename", nanofactoryPeers: "id, available, whitelisted, blacklisted", jobsHistory: "id, status, createdDate, filamentID" }), this.version(1.1).stores({ printer: "id", networking: "id, peerID, apiKey", printQueue: "id,filamentID", filaments: "id", nanofactoryFiles: "id, filename", nanofactoryPeers: "id, available, whitelisted, blacklisted" }), this.version(1).stores({ printer: "id", networking: "id, peerID, apiKey", printQueue: "id,filamentID", filaments: "id", nanofactoryFiles: "id, filename" }), this.printer.mapToClass(ba), this.networking.mapToClass(ya), this.printQueue.mapToClass(mn), this.filaments.mapToClass(ma), this.nanofactoryFiles.mapToClass(va), this.nanofactoryPeers.mapToClass(ga), this.jobsHistory.mapToClass(mn), this.actions.mapToClass(_a) } } let O; async function $s() { O = new zs, O.open() } let Xt; function Vt(e, t, r) {
    const n = { label: r, metadata: e, serialization: "json", reliable: !0 }; Xt = de.connect(e, n), Xt.on("open", function () { Xt.send(JSON.stringify(t)), console.log("Sent:", t) }), Xt.on("error", async function (i) {
        console.error("Could not send data: ", t, `
 Error: `, i), (await O.nanofactoryPeers.toArray())[0].removeFromList(dt.AVAILABLE, e)
    })
} async function Ue(e, t) { (await O.nanofactoryPeers.toArray())[0].available.forEach(n => { Vt(n, e, t) }) } let ye = ""; async function Gs(e, t, r, n, i) { switch (r) { case S.jobCreated: let a = new va(n.file.id, n.file.fileName, n.file.parentDir, n.file.isWorkspaceFile, n.file.uploaderName, n.file.type); a.fileContent = new Blob([i], { type: "text/plain;charset=utf-8" }); let o = new mn(n.id, n.printerID, n.jobName, n.assignerName, n.estimatedPrintTime, n.estimatedFilamentUsage, n.createdDate, n.queuePosition, a, n.filamentID); a.add(), o.add("printQueue"), await OctoPrint.files.upload("local", new File([a.fileContent], n.jobName + ".gcode")), (await O.printer.toArray())[0].state.status === Qe.operational && li(); break; case S.currentJobUpdatesRequest: Vs(t); break; case S.currentJobUpdatesStop: ut[t].close(); break; case S.jobCancelled: let u = await O.printQueue.get(e.id); u && (ye == u.id ? OctoPrint.job.cancel() : (u.status = ct.CANCELLED, u.add("jobsHistory"), u.remove("printQueue"))); break; case S.jobDeleted: let s = await O.printQueue.get(e.id); s && s.remove("printQueue"); break; case S.jobRankChange: let c = await O.printQueue.get(e.id); c && (c.queuePosition = e.queuePosition, c.save("printQueue", { queuePosition: c.queuePosition })); break; case S.jobPause: OctoPrint.job.pause(); break; case S.jobResume: ye.length > 0 ? OctoPrint.job.resume() : li(); break; case S.jobFilamentModified: let l = await O.printQueue.get(e.id); l && (l.filamentID = e.filamentID, l.save("printQueue", { filamentID: l.filamentID }), Ue({ data: { id: l.id, filamentID: l.filamentID } }, S.jobFilamentModified)); break } } async function li() { let e = (await O.printQueue.orderBy("queuePosition").toArray())[0]; w.filamentID === e.filamentID ? (ye = e.id, e.startTime = new Date().toISOString(), e.status = ct.PRINTING, e.save("printQueue", { startTime: e.startTime, status: e.status }), OctoPrint.files.select("local", e.jobName + ".gcode", !0), w.isQueuePaused = !1, w.queuePausedReason = Ze.queueNotPaused, w.save({ isQueuePaused: w.isQueuePaused, queuePausedReason: w.queuePausedReason })) : (Ue({ data: Ze.filamentMismatch }, S.queuePaused), w.queuePausedReason = Ze.filamentMismatch, w.save({ queuePausedReason: w.queuePausedReason })) } function Vs(e) { const t = { label: S.currentJobUpdatesResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("jobProgress connection is open " + e), ut[e] = r }), r.on("close", function () { delete ut[e] }), r.on("error", function () { delete ut[e] }) } function qs() { ye = "" } async function Js() { try { let t = await fetch("http://localhost:5000/api/printer?history=true&limit=" + 50, { method: "GET", headers: { "X-API-KEY": L.apiKey } }); return t.ok ? await t.json() : { state: { text: "Offline" } } } catch { return { state: { text: "Offline" } } } } async function Hs(e, t, r, n) { switch (r) { case S.connectPrinter: Zs(e.port, e.baudrate, e.autoconnect, e.save); break; case S.disconnectPrinter: OctoPrint.connection.disconnect(); break; case S.executeCustomGcode: vn([e.data]); break; case S.temperatureStreamRequest: Xs(t); break; case S.temperatureStreamStop: lt[t].close(); break; case S.filamentExtrude: OctoPrint.printer.extrude(e.data); break; case S.home: OctoPrint.printer.home(e.axes); break; case S.terminalRequest: ec(t); break; case S.terminalStop: ft[t].close(); break; case S.targetBed: OctoPrint.printer.setBedTargetTemperature(e.data); break; case S.targetTool: OctoPrint.printer.setToolTargetTemperatures({ tool0: e.data }); break; case S.positionChanged: tc(e); break; case S.positionChangedRequest: rc(t); break; case S.positionChangedStop: ze[t].close(); break; case S.emergencyStop: vn(["M112"]); break } } function vn(e) { e.forEach(async t => { await OctoPrint.control.sendGcode(t) }) } async function Ws() { let e = await OctoPrint.printerprofiles.get("_default"); e.id = de.id, delete e.default, delete e.current, delete e.resource, e.position = { x: 0, y: 0, z: 0, e: 0, relative: !1, speed: 0 }, await w.save(e) } async function Qs() { w.connectionOptions = (await OctoPrint.connection.getSettings()).options, await w.save({ connectionOptions: w.connectionOptions }) } async function Ys() { let e = await Js(), t = Ca(e.state.text); t !== w.state.status && Ue({ status: t }, S.printerStateChanged), w.state.status = t, "temperature" in e && (w.temperatureHistory = e.temperature.history), await w.save({ state: w.state, temperatureHistory: w.temperatureHistory }) } function Ca(e) { return e.includes("Operational") ? Qe.operational : e.includes("Printing") ? Qe.printing : e.includes("Paused") ? Qe.paused : Qe.offline } function Xs(e) { const t = { label: S.temperatureStreamResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("temperatureStream connection is open " + e), lt[e] = r }), r.on("close", function () { delete lt[e] }), r.on("error", function () { delete lt[e] }) } async function Zs(e, t, r, n) { let i = { save: n, autoconnect: r }; e.toLowerCase().includes("auto") || (i.port = e), t.toLowerCase().includes("auto") || (i.baudrate = parseInt(t)), OctoPrint.connection.connect(i) } function ec(e) { const t = { label: S.terminalResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("terminalConnection is open " + e), ft[e] = r }), r.on("close", function () { delete ft[e] }), r.on("error", function () { delete ft[e] }) } function tc(e) { console.log(e); let t = { x: e.x, y: e.y, z: e.z, absolute: !e.relative }; OctoPrint.printer.jog(t) } function rc(e) { const t = { label: S.positionChangedResponse, metadata: e, serialization: "json", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("positionChangedConnection is open " + e), ze[e] = r }), r.on("close", function () { delete ze[e] }), r.on("error", function () { delete ze[e] }) } const nc = ".*G90.*", ic = ".*G91.*", ac = ".*M82.*", oc = ".*M83.*", fi = "E-?d+.?d+", Fr = "X[-0-9]+", Nr = "Y[-0-9]+", Kr = "Z[0-9]+", sc = "Recv: X:[0-9]+.[0-9]{2} Y:[0-9]+.[0-9]{2} Z:[0-9]+.[0-9]{2} E:0.00 Count X:[0-9]+ Y:[0-9]+ Z:[0-9]+", cc = "X:[-0-9]+.[-0-9]+", uc = "Y:[-0-9]+.[-0-9]+", lc = "Z:[-0-9]+.[-0-9]+"; let Lr = !1, Ur = !1, pi = !1, bt = !0; function fc(e) { let t = !1; e.forEach(r => { if (r.includes("G28 X0 Y0") && (Lr = !0, Ur = !0), (r.includes("G28 Z0") || r.replace("Send:", "").trim() === "G28") && (Lr = !0, Ur = !0, pi = !0), (Lr || Ur || pi) && r.match(sc)) { w.position.x = parseFloat(r.match(cc)[0].substring(2)), w.position.y = parseFloat(r.match(uc)[0].substring(2)), w.position.z = parseFloat(r.match(lc)[0].substring(2)), w.save({ position: w.position }); for (let n in ze) ze[n].send(JSON.stringify(w.position)) } if (r.match(nc) ? bt = !0 : r.match(ic) && (bt = !1), r.match(ac) || r.match(oc), (r.includes("G0") || r.includes("G1")) && (r.match(Fr) && (w.position.x = bt ? parseFloat(r.match(Fr)[0].substring(1)) : w.position.x + parseFloat(r.match(Fr)[0].substring(1)), t = !0), r.match(Nr) && (w.position.y = bt ? parseFloat(r.match(Nr)[0].substring(1)) : w.position.y + parseFloat(r.match(Nr)[0].substring(1)), t = !0), r.match(Kr) && (w.position.z = bt ? parseFloat(r.match(Kr)[0].substring(1)) : w.position.z + parseFloat(r.match(Kr)[0].substring(1)), t = !0), r.match(fi) && parseFloat(r.match(fi)[0].substring(1)), t)) { w.save({ position: w.position }); for (let n in ze) ze[n].send(JSON.stringify(w.position)) } }) } async function pc(e) { const t = { label: S.cameraStreamResponse, metadata: e, serialization: "binary", reliable: !0 }; let r = de.connect(e, t); r.on("open", function () { console.log("cameraStream connection is open " + e), dr[e] = r }), r.on("close", function () { delete dr[e] }), r.on("error", function () { delete dr[e] }) } var ot = (e => (e.CONNECTED = "connected", e.CURRENT = "current", e.HISTORY = "history", e.REAUTHREQUIRED = "reauthRequired", e.EVENT = "event", e))(ot || {}), Ke = (e => (e.PRINTERSTATECHANGED = "PrinterStateChanged", e.PRINTSTARTED = "PrintStarted", e.PRINTDONE = "PrintDone", e.PRINTFAILED = "PrintFailed", e.PRINTCANCELLED = "PrintCancelled", e))(Ke || {}); async function dc(e, t, r, n) { switch (r) { case S.filamentAssigned: if (w.state.status === Qe.operational) { let a = new ma(e.id, e.brand, e.material, e.color, e.cost, e.currency, e.weightTotal, e.weightPrinted, e.density, e.diameter, new Date(e.dateBought), e.nozzleTemperature, e.bedTemperature, e.filamentDepletedCutoff); a.status = ha.loaded, a.add(), Ue(a, S.filamentAssigned), w.filamentID = a.id, w.save({ filamentID: w.filamentID }) } break; case S.filamentRemoved: w.filamentID = "", w.save({ filamentID: w.filamentID }), O.filaments.clear(); break; case S.filamentModified: let i = await O.filaments.get(e.id); i && i.save(e); break } } async function hc(e, t, r, n, i) { switch (r) { case S.actionCreated: case S.actionModified: let a = new File([new Blob([i], { type: "text/plain;charset=utf-8" })], n.name + ".gcode"), o = await O.actions.get(n.id); o ? (o.name = n.name, o.script = a, o.filamentAction = n.filamentAction, o.save(o)) : new _a(n.id, n.name, a, n.filamentAction).add(); break; case S.actionExecuted: let u = (await O.actions.where("name").equals(e.name).toArray())[0]; if (u) { let c = await u.script.text(); vn(c.split(/\r?\n/)) } break; case S.actionDeleted: (await O.actions.where("name").equals(e.name).toArray())[0].remove(); break } } async function mc(e, t, r, n) { let i = (await O.nanofactoryPeers.toArray())[0]; switch (r) { case S.peerPermissionResponse: t === L.masterPeerID && (e.accept ? (i.addToList(dt.WHITELISTED, e.peerID), yn(e.peerID)) : i.addToList(dt.BLACKLISTED, e.peerID)); break; case S.peerListModification: t === L.masterPeerID && (e.action === "add" ? i.addToList(e.peerType, e.peerID) : e.action === "delete" && i.removeFromList(e.peerType, e.peerID), Vt(L.masterPeerID, e, S.peerListModification)); break } } const vc = [S.jobCreated, S.actionCreated, S.actionModified]; async function yc(e, t, r, n) { let i = (await O.nanofactoryPeers.toArray())[0], a = ""; if (vc.includes(r) ? a = new TextDecoder("utf-8").decode(e) : e = JSON.parse(e), n = JSON.parse(n), i.whitelisted.has(t)) switch (r) { case S.syncAllRequest: yn(t); break; case S.connectPrinter: case S.disconnectPrinter: case S.executeCustomGcode: case S.temperatureStreamRequest: case S.temperatureStreamStop: case S.filamentExtrude: case S.home: case S.terminalRequest: case S.terminalStop: case S.targetBed: case S.targetTool: case S.positionChanged: case S.positionChangedRequest: case S.positionChangedStop: case S.emergencyStop: Hs(e, t, r); break; case S.jobCreated: case S.currentJobUpdatesRequest: case S.currentJobUpdatesStop: case S.jobCancelled: case S.jobDeleted: case S.jobRankChange: case S.jobPause: case S.jobResume: case S.jobFilamentModified: Gs(e, t, r, n, a); break; case S.filamentAssigned: case S.filamentRemoved: case S.filamentModified: dc(e, t, r); break; case S.actionCreated: case S.actionExecuted: case S.actionModified: case S.actionDeleted: hc(e, t, r, n, a); break; case S.peerPermissionResponse: case S.peerListModification: mc(e, t, r); break; case S.handshakeRequest: gc(t); break; case S.cameraStreamRequest: pc(t); break; case S.cameraStreamStop: dr[t].close(); break; default: console.log("Unhandled label: " + r); break } else i.blacklisted.has(t) ? console.log("Request from blacklisted peer: " + t + ". Label: " + r) : r === S.syncAllRequest && (L.masterPeerID.length > 0 ? Vt(L.masterPeerID, e, S.peerPermissionRequest) : (L.masterPeerID = t, L.save({ masterPeerID: L.masterPeerID }), fetch(so + "plugin/NanoFactory/save_master_peer_id?master_peer_id=" + L.masterPeerID, { method: "POST", headers: { "X-API-KEY": L.apiKey } }), yn(t))) } async function yn(e) { let t = (await O.nanofactoryPeers.toArray())[0], r = { printer_profile: (await O.printer.toArray())[0], current_job: { id: ye }, print_queue: await O.printQueue.toArray(), jobs_history: await O.jobsHistory.toArray(), current_filament: await O.filaments.get(w.filamentID), scripts: await O.actions.toArray(), is_master: e === L.masterPeerID, whitelisted: [""], blacklisted: [""] }; r.is_master && (r.whitelisted = Array.from(t.whitelisted), r.blacklisted = Array.from(t.blacklisted)), Vt(e, r, S.syncAllResponse), t.addToList(dt.AVAILABLE, e) } async function gc(e) { Vt(e, { status: (await O.printer.toArray())[0].state.status }, S.handshakeResponse) } async function bc(e) { var t, r; switch (e.event) { case ot.CONNECTED: case ot.REAUTHREQUIRED: OctoPrint.browser.passiveLogin().done(function (n) { OctoPrint.socket.sendAuth(n.name, n.session) }); break; case ot.HISTORY: console.log(e); break; case ot.CURRENT: if (ye && "job" in e.data && console.log(e), ye && "progress" in e.data) { let n = { data: { id: ye, progress: { completion: parseFloat(e.data.progress.completion).toFixed(1) }, estimatedFilamentUsage: (r = (t = e.data.job.filament) == null ? void 0 : t.tool0) != null ? r : { length: 0, volume: 0 }, actualFilamentUsage: { length: 0, volume: 0 } } }; if (n.data.progress.completion) for (let i in ut) ut[i].send(JSON.stringify(n)) } if ("temps" in e.data && e.data.temps.length > 0) { for (let n in lt) lt[n].send(JSON.stringify({ data: e.data.temps })); for (e.data.temps.forEach(n => { w.temperatureHistory.push(n) }); w.temperatureHistory.length > 50;)w.temperatureHistory.shift(); w.save({ temperatureHistory: w.temperatureHistory }) } if ("logs" in e.data) { for (let n in ft) ft[n].send(JSON.stringify(e.data.logs)); fc(e.data.logs) } break; case ot.EVENT: console.log(e), _c(e); break; default: console.log("Unhandled socketEventType: ", e) } } async function _c(e) { switch (e.data.type) { case Ke.PRINTERSTATECHANGED: w.state.status = Ca(e.data.payload.state_string), w.save({ state: w.state }), Ue(w.state, S.printerStateChanged); break; case Ke.PRINTSTARTED: ye && Ue({ data: { id: ye, startTime: new Date().toISOString() } }, S.jobPrinting); break; case Ke.PRINTDONE: case Ke.PRINTFAILED: case Ke.PRINTFAILED: if (ye) { let t = Cc(e.data.type), r = await O.printQueue.get(ye); r && (r.endTime = new Date().toISOString(), r.status = t.printJobStatus, await r.save("printQueue", { endTime: r.endTime, status: r.status }), r.add("jobsHistory"), r.remove("printQueue")), Ue({ data: { id: ye, endTime: r == null ? void 0 : r.endTime } }, t.connectionLabel), Ue({ data: t.queuePausedReason }, S.queuePaused), qs(), w.isQueuePaused = !0, w.queuePausedReason = t.queuePausedReason, w.save({ isQueuePaused: w.isQueuePaused, queuePausedReason: w.queuePausedReason }) } break } } function Cc(e) { console.log(e); let t = { queuePausedReason: "", connectionLabel: "", printJobStatus: "" }; return e === Ke.PRINTDONE ? (t.queuePausedReason = Ze.printCompletion, t.connectionLabel = S.jobDone, t.printJobStatus = ct.DONE) : e === Ke.PRINTCANCELLED ? (t.queuePausedReason = Ze.printCancelled, t.connectionLabel = S.jobCancelled, t.printJobStatus = ct.CANCELLED) : (t.queuePausedReason = Ze.printFailed, t.connectionLabel = S.jobFailed, t.printJobStatus = ct.FAILED), console.log(t), t } var $n = { exports: {} }; (function (e) { var t = {}; t.useBlobBuilder = function () { try { return new Blob([]), !1 } catch { return !0 } }(), t.useArrayBufferView = !t.useBlobBuilder && function () { try { return new Blob([new Uint8Array([])]).size === 0 } catch { return !0 } }(), e.exports.binaryFeatures = t; var r = e.exports.BlobBuilder; typeof window < "u" && (r = e.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder); function n() { this._pieces = [], this._parts = [] } n.prototype.append = function (i) { typeof i == "number" ? this._pieces.push(i) : (this.flush(), this._parts.push(i)) }, n.prototype.flush = function () { if (this._pieces.length > 0) { var i = new Uint8Array(this._pieces); t.useArrayBufferView || (i = i.buffer), this._parts.push(i), this._pieces = [] } }, n.prototype.getBuffer = function () { if (this.flush(), t.useBlobBuilder) { for (var i = new r, a = 0, o = this._parts.length; a < o; a++)i.append(this._parts[a]); return i.getBlob() } else return new Blob(this._parts) }, e.exports.BufferBuilder = n })($n); var Sc = $n.exports.BufferBuilder, di = $n.exports.binaryFeatures, Tc = { unpack: function (e) { var t = new ee(e); return t.unpack() }, pack: function (e) { var t = new te; t.pack(e); var r = t.getBuffer(); return r } }, hi = Tc; function ee(e) { this.index = 0, this.dataBuffer = e, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength } ee.prototype.unpack = function () { var e = this.unpack_uint8(); if (e < 128) return e; if ((e ^ 224) < 32) return (e ^ 224) - 32; var t; if ((t = e ^ 160) <= 15) return this.unpack_raw(t); if ((t = e ^ 176) <= 15) return this.unpack_string(t); if ((t = e ^ 144) <= 15) return this.unpack_array(t); if ((t = e ^ 128) <= 15) return this.unpack_map(t); switch (e) { case 192: return null; case 193: return; case 194: return !1; case 195: return !0; case 202: return this.unpack_float(); case 203: return this.unpack_double(); case 204: return this.unpack_uint8(); case 205: return this.unpack_uint16(); case 206: return this.unpack_uint32(); case 207: return this.unpack_uint64(); case 208: return this.unpack_int8(); case 209: return this.unpack_int16(); case 210: return this.unpack_int32(); case 211: return this.unpack_int64(); case 212: return; case 213: return; case 214: return; case 215: return; case 216: return t = this.unpack_uint16(), this.unpack_string(t); case 217: return t = this.unpack_uint32(), this.unpack_string(t); case 218: return t = this.unpack_uint16(), this.unpack_raw(t); case 219: return t = this.unpack_uint32(), this.unpack_raw(t); case 220: return t = this.unpack_uint16(), this.unpack_array(t); case 221: return t = this.unpack_uint32(), this.unpack_array(t); case 222: return t = this.unpack_uint16(), this.unpack_map(t); case 223: return t = this.unpack_uint32(), this.unpack_map(t) } }; ee.prototype.unpack_uint8 = function () { var e = this.dataView[this.index] & 255; return this.index++, e }; ee.prototype.unpack_uint16 = function () { var e = this.read(2), t = (e[0] & 255) * 256 + (e[1] & 255); return this.index += 2, t }; ee.prototype.unpack_uint32 = function () { var e = this.read(4), t = ((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]; return this.index += 4, t }; ee.prototype.unpack_uint64 = function () { var e = this.read(8), t = ((((((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]) * 256 + e[4]) * 256 + e[5]) * 256 + e[6]) * 256 + e[7]; return this.index += 8, t }; ee.prototype.unpack_int8 = function () { var e = this.unpack_uint8(); return e < 128 ? e : e - (1 << 8) }; ee.prototype.unpack_int16 = function () { var e = this.unpack_uint16(); return e < 32768 ? e : e - (1 << 16) }; ee.prototype.unpack_int32 = function () { var e = this.unpack_uint32(); return e < Math.pow(2, 31) ? e : e - Math.pow(2, 32) }; ee.prototype.unpack_int64 = function () { var e = this.unpack_uint64(); return e < Math.pow(2, 63) ? e : e - Math.pow(2, 64) }; ee.prototype.unpack_raw = function (e) { if (this.length < this.index + e) throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + e + " " + this.length); var t = this.dataBuffer.slice(this.index, this.index + e); return this.index += e, t }; ee.prototype.unpack_string = function (e) { for (var t = this.read(e), r = 0, n = "", i, a; r < e;)i = t[r], i < 128 ? (n += String.fromCharCode(i), r++) : (i ^ 192) < 32 ? (a = (i ^ 192) << 6 | t[r + 1] & 63, n += String.fromCharCode(a), r += 2) : (a = (i & 15) << 12 | (t[r + 1] & 63) << 6 | t[r + 2] & 63, n += String.fromCharCode(a), r += 3); return this.index += e, n }; ee.prototype.unpack_array = function (e) { for (var t = new Array(e), r = 0; r < e; r++)t[r] = this.unpack(); return t }; ee.prototype.unpack_map = function (e) { for (var t = {}, r = 0; r < e; r++) { var n = this.unpack(), i = this.unpack(); t[n] = i } return t }; ee.prototype.unpack_float = function () { var e = this.unpack_uint32(), t = e >> 31, r = (e >> 23 & 255) - 127, n = e & 8388607 | 8388608; return (t === 0 ? 1 : -1) * n * Math.pow(2, r - 23) }; ee.prototype.unpack_double = function () { var e = this.unpack_uint32(), t = this.unpack_uint32(), r = e >> 31, n = (e >> 20 & 2047) - 1023, i = e & 1048575 | 1048576, a = i * Math.pow(2, n - 20) + t * Math.pow(2, n - 52); return (r === 0 ? 1 : -1) * a }; ee.prototype.read = function (e) { var t = this.index; if (t + e <= this.length) return this.dataView.subarray(t, t + e); throw new Error("BinaryPackFailure: read index out of range") }; function te() { this.bufferBuilder = new Sc } te.prototype.getBuffer = function () { return this.bufferBuilder.getBuffer() }; te.prototype.pack = function (e) { var t = typeof e; if (t === "string") this.pack_string(e); else if (t === "number") Math.floor(e) === e ? this.pack_integer(e) : this.pack_double(e); else if (t === "boolean") e === !0 ? this.bufferBuilder.append(195) : e === !1 && this.bufferBuilder.append(194); else if (t === "undefined") this.bufferBuilder.append(192); else if (t === "object") if (e === null) this.bufferBuilder.append(192); else { var r = e.constructor; if (r == Array) this.pack_array(e); else if (r == Blob || r == File || e instanceof Blob || e instanceof File) this.pack_bin(e); else if (r == ArrayBuffer) di.useArrayBufferView ? this.pack_bin(new Uint8Array(e)) : this.pack_bin(e); else if ("BYTES_PER_ELEMENT" in e) di.useArrayBufferView ? this.pack_bin(new Uint8Array(e.buffer)) : this.pack_bin(e.buffer); else if (r == Object || r.toString().startsWith("class")) this.pack_object(e); else if (r == Date) this.pack_string(e.toString()); else if (typeof e.toBinaryPack == "function") this.bufferBuilder.append(e.toBinaryPack()); else throw new Error('Type "' + r.toString() + '" not yet supported') } else throw new Error('Type "' + t + '" not yet supported'); this.bufferBuilder.flush() }; te.prototype.pack_bin = function (e) { var t = e.length || e.byteLength || e.size; if (t <= 15) this.pack_uint8(160 + t); else if (t <= 65535) this.bufferBuilder.append(218), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(219), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; te.prototype.pack_string = function (e) { var t = Pc(e); if (t <= 15) this.pack_uint8(176 + t); else if (t <= 65535) this.bufferBuilder.append(216), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(217), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; te.prototype.pack_array = function (e) { var t = e.length; if (t <= 15) this.pack_uint8(144 + t); else if (t <= 65535) this.bufferBuilder.append(220), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(221), this.pack_uint32(t); else throw new Error("Invalid length"); for (var r = 0; r < t; r++)this.pack(e[r]) }; te.prototype.pack_integer = function (e) { if (e >= -32 && e <= 127) this.bufferBuilder.append(e & 255); else if (e >= 0 && e <= 255) this.bufferBuilder.append(204), this.pack_uint8(e); else if (e >= -128 && e <= 127) this.bufferBuilder.append(208), this.pack_int8(e); else if (e >= 0 && e <= 65535) this.bufferBuilder.append(205), this.pack_uint16(e); else if (e >= -32768 && e <= 32767) this.bufferBuilder.append(209), this.pack_int16(e); else if (e >= 0 && e <= 4294967295) this.bufferBuilder.append(206), this.pack_uint32(e); else if (e >= -2147483648 && e <= 2147483647) this.bufferBuilder.append(210), this.pack_int32(e); else if (e >= -9223372036854776e3 && e <= 9223372036854776e3) this.bufferBuilder.append(211), this.pack_int64(e); else if (e >= 0 && e <= 18446744073709552e3) this.bufferBuilder.append(207), this.pack_uint64(e); else throw new Error("Invalid integer") }; te.prototype.pack_double = function (e) { var t = 0; e < 0 && (t = 1, e = -e); var r = Math.floor(Math.log(e) / Math.LN2), n = e / Math.pow(2, r) - 1, i = Math.floor(n * Math.pow(2, 52)), a = Math.pow(2, 32), o = t << 31 | r + 1023 << 20 | i / a & 1048575, u = i % a; this.bufferBuilder.append(203), this.pack_int32(o), this.pack_int32(u) }; te.prototype.pack_object = function (e) { var t = Object.keys(e), r = t.length; if (r <= 15) this.pack_uint8(128 + r); else if (r <= 65535) this.bufferBuilder.append(222), this.pack_uint16(r); else if (r <= 4294967295) this.bufferBuilder.append(223), this.pack_uint32(r); else throw new Error("Invalid length"); for (var n in e) e.hasOwnProperty(n) && (this.pack(n), this.pack(e[n])) }; te.prototype.pack_uint8 = function (e) { this.bufferBuilder.append(e) }; te.prototype.pack_uint16 = function (e) { this.bufferBuilder.append(e >> 8), this.bufferBuilder.append(e & 255) }; te.prototype.pack_uint32 = function (e) { var t = e & 4294967295; this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255) }; te.prototype.pack_uint64 = function (e) { var t = e / Math.pow(2, 32), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; te.prototype.pack_int8 = function (e) { this.bufferBuilder.append(e & 255) }; te.prototype.pack_int16 = function (e) { this.bufferBuilder.append((e & 65280) >> 8), this.bufferBuilder.append(e & 255) }; te.prototype.pack_int32 = function (e) { this.bufferBuilder.append(e >>> 24 & 255), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255) }; te.prototype.pack_int64 = function (e) { var t = Math.floor(e / Math.pow(2, 32)), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; function kc(e) { var t = e.charCodeAt(0); return t <= 2047 ? "00" : t <= 65535 ? "000" : t <= 2097151 ? "0000" : t <= 67108863 ? "00000" : "000000" } function Pc(e) { return e.length > 600 ? new Blob([e]).size : e.replace(/[^\u0000-\u007F]/g, kc).length } let Sa = !0, Ta = !0; function kt(e, t, r) { const n = e.match(t); return n && n.length >= r && parseInt(n[r], 10) } function gt(e, t, r) { if (!e.RTCPeerConnection) return; const n = e.RTCPeerConnection.prototype, i = n.addEventListener; n.addEventListener = function (o, u) { if (o !== t) return i.apply(this, arguments); const s = c => { const l = r(c); l && (u.handleEvent ? u.handleEvent(l) : u(l)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(u, s), i.apply(this, [o, s]) }; const a = n.removeEventListener; n.removeEventListener = function (o, u) { if (o !== t || !this._eventMap || !this._eventMap[t]) return a.apply(this, arguments); if (!this._eventMap[t].has(u)) return a.apply(this, arguments); const s = this._eventMap[t].get(u); return this._eventMap[t].delete(u), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, a.apply(this, [o, s]) }, Object.defineProperty(n, "on" + t, { get() { return this["_on" + t] }, set(o) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), o && this.addEventListener(t, this["_on" + t] = o) }, enumerable: !0, configurable: !0 }) } function Ec(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Sa = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function Rc(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Ta = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function Gn() { if (typeof window == "object") { if (Sa) return; typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments) } } function Dr(e, t) { !Ta || console.warn(e + " is deprecated, please use " + t + " instead.") } function xc(e) { const t = { browser: null, version: null }; if (typeof e > "u" || !e.navigator) return t.browser = "Not a browser.", t; const { navigator: r } = e; if (r.mozGetUserMedia) t.browser = "firefox", t.version = kt(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || e.isSecureContext === !1 && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = kt(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (r.mediaDevices && r.userAgent.match(/Edge\/(\d+).(\d+)$/)) t.browser = "edge", t.version = kt(r.userAgent, /Edge\/(\d+).(\d+)$/, 2); else if (e.RTCPeerConnection && r.userAgent.match(/AppleWebKit\/(\d+)\./)) t.browser = "safari", t.version = kt(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype; else return t.browser = "Not a supported browser.", t; return t } function mi(e) { return Object.prototype.toString.call(e) === "[object Object]" } function ka(e) { return mi(e) ? Object.keys(e).reduce(function (t, r) { const n = mi(e[r]), i = n ? ka(e[r]) : e[r], a = n && !Object.keys(i).length; return i === void 0 || a ? t : Object.assign(t, { [r]: i }) }, {}) : e } function gn(e, t, r) { !t || r.has(t.id) || (r.set(t.id, t), Object.keys(t).forEach(n => { n.endsWith("Id") ? gn(e, e.get(t[n]), r) : n.endsWith("Ids") && t[n].forEach(i => { gn(e, e.get(i), r) }) })) } function vi(e, t, r) { const n = r ? "outbound-rtp" : "inbound-rtp", i = new Map; if (t === null) return i; const a = []; return e.forEach(o => { o.type === "track" && o.trackIdentifier === t.id && a.push(o) }), a.forEach(o => { e.forEach(u => { u.type === n && u.trackId === o.id && gn(e, u, i) }) }), i } const yi = Gn; function Pa(e, t) { const r = e && e.navigator; if (!r.mediaDevices) return; const n = function (u) { if (typeof u != "object" || u.mandatory || u.optional) return u; const s = {}; return Object.keys(u).forEach(c => { if (c === "require" || c === "advanced" || c === "mediaSource") return; const l = typeof u[c] == "object" ? u[c] : { ideal: u[c] }; l.exact !== void 0 && typeof l.exact == "number" && (l.min = l.max = l.exact); const f = function (p, m) { return p ? p + m.charAt(0).toUpperCase() + m.slice(1) : m === "deviceId" ? "sourceId" : m }; if (l.ideal !== void 0) { s.optional = s.optional || []; let p = {}; typeof l.ideal == "number" ? (p[f("min", c)] = l.ideal, s.optional.push(p), p = {}, p[f("max", c)] = l.ideal, s.optional.push(p)) : (p[f("", c)] = l.ideal, s.optional.push(p)) } l.exact !== void 0 && typeof l.exact != "number" ? (s.mandatory = s.mandatory || {}, s.mandatory[f("", c)] = l.exact) : ["min", "max"].forEach(p => { l[p] !== void 0 && (s.mandatory = s.mandatory || {}, s.mandatory[f(p, c)] = l[p]) }) }), u.advanced && (s.optional = (s.optional || []).concat(u.advanced)), s }, i = function (u, s) { if (t.version >= 61) return s(u); if (u = JSON.parse(JSON.stringify(u)), u && typeof u.audio == "object") { const c = function (l, f, p) { f in l && !(p in l) && (l[p] = l[f], delete l[f]) }; u = JSON.parse(JSON.stringify(u)), c(u.audio, "autoGainControl", "googAutoGainControl"), c(u.audio, "noiseSuppression", "googNoiseSuppression"), u.audio = n(u.audio) } if (u && typeof u.video == "object") { let c = u.video.facingMode; c = c && (typeof c == "object" ? c : { ideal: c }); const l = t.version < 66; if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && !(r.mediaDevices.getSupportedConstraints && r.mediaDevices.getSupportedConstraints().facingMode && !l)) { delete u.video.facingMode; let f; if (c.exact === "environment" || c.ideal === "environment" ? f = ["back", "rear"] : (c.exact === "user" || c.ideal === "user") && (f = ["front"]), f) return r.mediaDevices.enumerateDevices().then(p => { p = p.filter(d => d.kind === "videoinput"); let m = p.find(d => f.some(h => d.label.toLowerCase().includes(h))); return !m && p.length && f.includes("back") && (m = p[p.length - 1]), m && (u.video.deviceId = c.exact ? { exact: m.deviceId } : { ideal: m.deviceId }), u.video = n(u.video), yi("chrome: " + JSON.stringify(u)), s(u) }) } u.video = n(u.video) } return yi("chrome: " + JSON.stringify(u)), s(u) }, a = function (u) { return t.version >= 64 ? u : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[u.name] || u.name, message: u.message, constraint: u.constraint || u.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }, o = function (u, s, c) { i(u, l => { r.webkitGetUserMedia(l, s, f => { c && c(a(f)) }) }) }; if (r.getUserMedia = o.bind(r), r.mediaDevices.getUserMedia) { const u = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = function (s) { return i(s, c => u(c).then(l => { if (c.audio && !l.getAudioTracks().length || c.video && !l.getVideoTracks().length) throw l.getTracks().forEach(f => { f.stop() }), new DOMException("", "NotFoundError"); return l }, l => Promise.reject(a(l)))) } } } function Dc(e, t) { if (!(e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices) && !!e.navigator.mediaDevices) { if (typeof t != "function") { console.error("shimGetDisplayMedia: getSourceId argument is not a function"); return } e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then(i => { const a = n.video && n.video.width, o = n.video && n.video.height, u = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: i, maxFrameRate: u || 3 } }, a && (n.video.mandatory.maxWidth = a), o && (n.video.mandatory.maxHeight = o), e.navigator.mediaDevices.getUserMedia(n) }) } } } function Ea(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function Ra(e) { if (typeof e == "object" && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(r) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = r) }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = n => { n.stream.addEventListener("addtrack", i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.track.id) : a = { track: i.track }; const o = new Event("track"); o.track = i.track, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }), n.stream.getTracks().forEach(i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.id) : a = { track: i }; const o = new Event("track"); o.track = i, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else gt(e, "track", t => (t.transceiver || Object.defineProperty(t, "transceiver", { value: { receiver: t.receiver } }), t)) } function xa(e) { if (typeof e == "object" && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { const t = function (i, a) { return { track: a, get dtmf() { return this._dtmf === void 0 && (a.kind === "audio" ? this._dtmf = i.createDTMFSender(a) : this._dtmf = null), this._dtmf }, _pc: i } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const i = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (u, s) { let c = i.apply(this, arguments); return c || (c = t(this, u), this._senders.push(c)), c }; const a = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (u) { a.apply(this, arguments); const s = this._senders.indexOf(u); s !== -1 && this._senders.splice(s, 1) } } const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (a) { this._senders = this._senders || [], r.apply(this, [a]), a.getTracks().forEach(o => { this._senders.push(t(this, o)) }) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (a) { this._senders = this._senders || [], n.apply(this, [a]), a.getTracks().forEach(o => { const u = this._senders.find(s => s.track === o); u && this._senders.splice(this._senders.indexOf(u), 1) }) } } else if (typeof e == "object" && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function Da(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [n, i, a] = arguments; if (arguments.length > 0 && typeof n == "function") return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof n != "function")) return t.apply(this, []); const o = function (s) { const c = {}; return s.result().forEach(f => { const p = { id: f.id, timestamp: f.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[f.type] || f.type }; f.names().forEach(m => { p[m] = f.stat(m) }), c[p.id] = p }), c }, u = function (s) { return new Map(Object.keys(s).map(c => [c, s[c]])) }; if (arguments.length >= 2) { const s = function (c) { i(u(o(c))) }; return t.apply(this, [s, n]) } return new Promise((s, c) => { t.apply(this, [function (l) { s(u(o(l))) }, c]) }).then(i, a) } } function wa(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!("getStats" in e.RTCRtpSender.prototype)) { const r = e.RTCPeerConnection.prototype.getSenders; r && (e.RTCPeerConnection.prototype.getSenders = function () { const a = r.apply(this, []); return a.forEach(o => o._pc = this), a }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const a = n.apply(this, arguments); return a._pc = this, a }), e.RTCRtpSender.prototype.getStats = function () { const a = this; return this._pc.getStats().then(o => vi(o, a.track, !0)) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { const r = e.RTCPeerConnection.prototype.getReceivers; r && (e.RTCPeerConnection.prototype.getReceivers = function () { const i = r.apply(this, []); return i.forEach(a => a._pc = this), i }), gt(e, "track", n => (n.receiver._pc = n.srcElement, n)), e.RTCRtpReceiver.prototype.getStats = function () { const i = this; return this._pc.getStats().then(a => vi(a, i.track, !1)) } } if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const n = arguments[0]; let i, a, o; return this.getSenders().forEach(u => { u.track === n && (i ? o = !0 : i = u) }), this.getReceivers().forEach(u => (u.track === n && (a ? o = !0 : a = u), u.track === n)), o || i && a ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : i ? i.getStats() : a ? a.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) } } function Oa(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(o => this._shimmedLocalStreams[o][0]) }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (o, u) { if (!u) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const s = t.apply(this, arguments); return this._shimmedLocalStreams[u.id] ? this._shimmedLocalStreams[u.id].indexOf(s) === -1 && this._shimmedLocalStreams[u.id].push(s) : this._shimmedLocalStreams[u.id] = [u, s], s }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (o) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o.getTracks().forEach(c => { if (this.getSenders().find(f => f.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError") }); const u = this.getSenders(); r.apply(this, arguments); const s = this.getSenders().filter(c => u.indexOf(c) === -1); this._shimmedLocalStreams[o.id] = [o].concat(s) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[o.id], n.apply(this, arguments) }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o && Object.keys(this._shimmedLocalStreams).forEach(u => { const s = this._shimmedLocalStreams[u].indexOf(o); s !== -1 && this._shimmedLocalStreams[u].splice(s, 1), this._shimmedLocalStreams[u].length === 1 && delete this._shimmedLocalStreams[u] }), i.apply(this, arguments) } } function Aa(e, t) { if (!e.RTCPeerConnection) return; if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return Oa(e); const r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const l = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, l.map(f => this._reverseStreams[f.id]) }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (l) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, l.getTracks().forEach(f => { if (this.getSenders().find(m => m.track === f)) throw new DOMException("Track already exists.", "InvalidAccessError") }), !this._reverseStreams[l.id]) { const f = new e.MediaStream(l.getTracks()); this._streams[l.id] = f, this._reverseStreams[f.id] = l, l = f } n.apply(this, [l]) }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (l) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[l.id] || l]), delete this._reverseStreams[this._streams[l.id] ? this._streams[l.id].id : l.id], delete this._streams[l.id] }, e.RTCPeerConnection.prototype.addTrack = function (l, f) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const p = [].slice.call(arguments, 1); if (p.length !== 1 || !p[0].getTracks().find(h => h === l)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find(h => h.track === l)) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const d = this._streams[f.id]; if (d) d.addTrack(l), Promise.resolve().then(() => { this.dispatchEvent(new Event("negotiationneeded")) }); else { const h = new e.MediaStream([l]); this._streams[f.id] = h, this._reverseStreams[h.id] = f, this.addStream(h) } return this.getSenders().find(h => h.track === l) }; function a(c, l) { let f = l.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const m = c._reverseStreams[p], d = c._streams[m.id]; f = f.replace(new RegExp(d.id, "g"), m.id) }), new RTCSessionDescription({ type: l.type, sdp: f }) } function o(c, l) { let f = l.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const m = c._reverseStreams[p], d = c._streams[m.id]; f = f.replace(new RegExp(m.id, "g"), d.id) }), new RTCSessionDescription({ type: l.type, sdp: f }) } ["createOffer", "createAnswer"].forEach(function (c) { const l = e.RTCPeerConnection.prototype[c], f = { [c]() { const p = arguments; return arguments.length && typeof arguments[0] == "function" ? l.apply(this, [d => { const h = a(this, d); p[0].apply(null, [h]) }, d => { p[1] && p[1].apply(null, d) }, arguments[2]]) : l.apply(this, arguments).then(d => a(this, d)) } }; e.RTCPeerConnection.prototype[c] = f[c] }); const u = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return !arguments.length || !arguments[0].type ? u.apply(this, arguments) : (arguments[0] = o(this, arguments[0]), u.apply(this, arguments)) }; const s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { const c = s.get.apply(this); return c.type === "" ? c : a(this, c) } }), e.RTCPeerConnection.prototype.removeTrack = function (l) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!l._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (!(l._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; let p; Object.keys(this._streams).forEach(m => { this._streams[m].getTracks().find(h => l.track === h) && (p = this._streams[m]) }), p && (p.getTracks().length === 1 ? this.removeStream(this._reverseStreams[p.id]) : p.removeTrack(l.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function bn(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), !!e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (r) { const n = e.RTCPeerConnection.prototype[r], i = { [r]() { return arguments[0] = new (r === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[r] = i[r] }) } function Ia(e, t) { gt(e, "negotiationneeded", r => { const n = r.target; if (!((t.version < 72 || n.getConfiguration && n.getConfiguration().sdpSemantics === "plan-b") && n.signalingState !== "stable")) return r }) } const gi = Object.freeze(Object.defineProperty({ __proto__: null, shimMediaStream: Ea, shimOnTrack: Ra, shimGetSendersWithDtmf: xa, shimGetStats: Da, shimSenderReceiverGetStats: wa, shimAddTrackRemoveTrackWithNative: Oa, shimAddTrackRemoveTrack: Aa, shimPeerConnection: bn, fixNegotiationNeeded: Ia, shimGetUserMedia: Pa, shimGetDisplayMedia: Dc }, Symbol.toStringTag, { value: "Module" })); function wc(e, t) { let r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(n => { if (n && (n.urls || n.url)) { let i = n.urls || n.url; n.url && !n.urls && Dr("RTCIceServer.url", "RTCIceServer.urls"); const a = typeof i == "string"; return a && (i = [i]), i = i.filter(o => { if (o.indexOf("stun:") === 0) return !1; const u = o.startsWith("turn") && !o.startsWith("turn:[") && o.includes("transport=udp"); return u && !r ? (r = !0, !0) : u && !r }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } var Vn = { exports: {} }; (function (e) {
    var t = {}; t.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10) }, t.localCName = t.generateIdentifier(), t.splitLines = function (r) {
        return r.trim().split(`
`).map(function (n) { return n.trim() })
    }, t.splitSections = function (r) {
        var n = r.split(`
m=`); return n.map(function (i, a) {
            return (a > 0 ? "m=" + i : i).trim() + `\r
`})
    }, t.getDescription = function (r) { var n = t.splitSections(r); return n && n[0] }, t.getMediaSections = function (r) { var n = t.splitSections(r); return n.shift(), n }, t.matchPrefix = function (r, n) { return t.splitLines(r).filter(function (i) { return i.indexOf(n) === 0 }) }, t.parseCandidate = function (r) { var n; r.indexOf("a=candidate:") === 0 ? n = r.substring(12).split(" ") : n = r.substring(10).split(" "); for (var i = { foundation: n[0], component: parseInt(n[1], 10), protocol: n[2].toLowerCase(), priority: parseInt(n[3], 10), ip: n[4], address: n[4], port: parseInt(n[5], 10), type: n[7] }, a = 8; a < n.length; a += 2)switch (n[a]) { case "raddr": i.relatedAddress = n[a + 1]; break; case "rport": i.relatedPort = parseInt(n[a + 1], 10); break; case "tcptype": i.tcpType = n[a + 1]; break; case "ufrag": i.ufrag = n[a + 1], i.usernameFragment = n[a + 1]; break; default: i[n[a]] = n[a + 1]; break }return i }, t.writeCandidate = function (r) { var n = []; n.push(r.foundation), n.push(r.component), n.push(r.protocol.toUpperCase()), n.push(r.priority), n.push(r.address || r.ip), n.push(r.port); var i = r.type; return n.push("typ"), n.push(i), i !== "host" && r.relatedAddress && r.relatedPort && (n.push("raddr"), n.push(r.relatedAddress), n.push("rport"), n.push(r.relatedPort)), r.tcpType && r.protocol.toLowerCase() === "tcp" && (n.push("tcptype"), n.push(r.tcpType)), (r.usernameFragment || r.ufrag) && (n.push("ufrag"), n.push(r.usernameFragment || r.ufrag)), "candidate:" + n.join(" ") }, t.parseIceOptions = function (r) { return r.substr(14).split(" ") }, t.parseRtpMap = function (r) { var n = r.substr(9).split(" "), i = { payloadType: parseInt(n.shift(), 10) }; return n = n[0].split("/"), i.name = n[0], i.clockRate = parseInt(n[1], 10), i.channels = n.length === 3 ? parseInt(n[2], 10) : 1, i.numChannels = i.channels, i }, t.writeRtpMap = function (r) {
        var n = r.payloadType; r.preferredPayloadType !== void 0 && (n = r.preferredPayloadType); var i = r.channels || r.numChannels || 1; return "a=rtpmap:" + n + " " + r.name + "/" + r.clockRate + (i !== 1 ? "/" + i : "") + `\r
`}, t.parseExtmap = function (r) { var n = r.substr(9).split(" "); return { id: parseInt(n[0], 10), direction: n[0].indexOf("/") > 0 ? n[0].split("/")[1] : "sendrecv", uri: n[1] } }, t.writeExtmap = function (r) {
            return "a=extmap:" + (r.id || r.preferredId) + (r.direction && r.direction !== "sendrecv" ? "/" + r.direction : "") + " " + r.uri + `\r
`}, t.parseFmtp = function (r) { for (var n = {}, i, a = r.substr(r.indexOf(" ") + 1).split(";"), o = 0; o < a.length; o++)i = a[o].trim().split("="), n[i[0].trim()] = i[1]; return n }, t.writeFmtp = function (r) {
            var n = "", i = r.payloadType; if (r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.parameters && Object.keys(r.parameters).length) {
                var a = []; Object.keys(r.parameters).forEach(function (o) { r.parameters[o] ? a.push(o + "=" + r.parameters[o]) : a.push(o) }), n += "a=fmtp:" + i + " " + a.join(";") + `\r
`} return n
        }, t.parseRtcpFb = function (r) { var n = r.substr(r.indexOf(" ") + 1).split(" "); return { type: n.shift(), parameter: n.join(" ") } }, t.writeRtcpFb = function (r) {
            var n = "", i = r.payloadType; return r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.rtcpFeedback && r.rtcpFeedback.length && r.rtcpFeedback.forEach(function (a) {
                n += "a=rtcp-fb:" + i + " " + a.type + (a.parameter && a.parameter.length ? " " + a.parameter : "") + `\r
`}), n
        }, t.parseSsrcMedia = function (r) { var n = r.indexOf(" "), i = { ssrc: parseInt(r.substr(7, n - 7), 10) }, a = r.indexOf(":", n); return a > -1 ? (i.attribute = r.substr(n + 1, a - n - 1), i.value = r.substr(a + 1)) : i.attribute = r.substr(n + 1), i }, t.parseSsrcGroup = function (r) { var n = r.substr(13).split(" "); return { semantics: n.shift(), ssrcs: n.map(function (i) { return parseInt(i, 10) }) } }, t.getMid = function (r) { var n = t.matchPrefix(r, "a=mid:")[0]; if (n) return n.substr(6) }, t.parseFingerprint = function (r) { var n = r.substr(14).split(" "); return { algorithm: n[0].toLowerCase(), value: n[1] } }, t.getDtlsParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=fingerprint:"); return { role: "auto", fingerprints: i.map(t.parseFingerprint) } }, t.writeDtlsParameters = function (r, n) {
            var i = "a=setup:" + n + `\r
`; return r.fingerprints.forEach(function (a) {
                i += "a=fingerprint:" + a.algorithm + " " + a.value + `\r
`}), i
        }, t.parseCryptoLine = function (r) { var n = r.substr(9).split(" "); return { tag: parseInt(n[0], 10), cryptoSuite: n[1], keyParams: n[2], sessionParams: n.slice(3) } }, t.writeCryptoLine = function (r) {
            return "a=crypto:" + r.tag + " " + r.cryptoSuite + " " + (typeof r.keyParams == "object" ? t.writeCryptoKeyParams(r.keyParams) : r.keyParams) + (r.sessionParams ? " " + r.sessionParams.join(" ") : "") + `\r
`}, t.parseCryptoKeyParams = function (r) { if (r.indexOf("inline:") !== 0) return null; var n = r.substr(7).split("|"); return { keyMethod: "inline", keySalt: n[0], lifeTime: n[1], mkiValue: n[2] ? n[2].split(":")[0] : void 0, mkiLength: n[2] ? n[2].split(":")[1] : void 0 } }, t.writeCryptoKeyParams = function (r) { return r.keyMethod + ":" + r.keySalt + (r.lifeTime ? "|" + r.lifeTime : "") + (r.mkiValue && r.mkiLength ? "|" + r.mkiValue + ":" + r.mkiLength : "") }, t.getCryptoParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=crypto:"); return i.map(t.parseCryptoLine) }, t.getIceParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=ice-ufrag:")[0], a = t.matchPrefix(r + n, "a=ice-pwd:")[0]; return i && a ? { usernameFragment: i.substr(12), password: a.substr(10) } : null }, t.writeIceParameters = function (r) {
            return "a=ice-ufrag:" + r.usernameFragment + `\r
a=ice-pwd:`+ r.password + `\r
`}, t.parseRtpParameters = function (r) { for (var n = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i = t.splitLines(r), a = i[0].split(" "), o = 3; o < a.length; o++) { var u = a[o], s = t.matchPrefix(r, "a=rtpmap:" + u + " ")[0]; if (s) { var c = t.parseRtpMap(s), l = t.matchPrefix(r, "a=fmtp:" + u + " "); switch (c.parameters = l.length ? t.parseFmtp(l[0]) : {}, c.rtcpFeedback = t.matchPrefix(r, "a=rtcp-fb:" + u + " ").map(t.parseRtcpFb), n.codecs.push(c), c.name.toUpperCase()) { case "RED": case "ULPFEC": n.fecMechanisms.push(c.name.toUpperCase()); break } } } return t.matchPrefix(r, "a=extmap:").forEach(function (f) { n.headerExtensions.push(t.parseExtmap(f)) }), n }, t.writeRtpDescription = function (r, n) {
            var i = ""; i += "m=" + r + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map(function (o) { return o.preferredPayloadType !== void 0 ? o.preferredPayloadType : o.payloadType }).join(" ") + `\r
`, i += `c=IN IP4 0.0.0.0\r
`, i += `a=rtcp:9 IN IP4 0.0.0.0\r
`, n.codecs.forEach(function (o) { i += t.writeRtpMap(o), i += t.writeFmtp(o), i += t.writeRtcpFb(o) }); var a = 0; return n.codecs.forEach(function (o) { o.maxptime > a && (a = o.maxptime) }), a > 0 && (i += "a=maxptime:" + a + `\r
`), i += `a=rtcp-mux\r
`, n.headerExtensions && n.headerExtensions.forEach(function (o) { i += t.writeExtmap(o) }), i
        }, t.parseRtpEncodingParameters = function (r) { var n = [], i = t.parseRtpParameters(r), a = i.fecMechanisms.indexOf("RED") !== -1, o = i.fecMechanisms.indexOf("ULPFEC") !== -1, u = t.matchPrefix(r, "a=ssrc:").map(function (p) { return t.parseSsrcMedia(p) }).filter(function (p) { return p.attribute === "cname" }), s = u.length > 0 && u[0].ssrc, c, l = t.matchPrefix(r, "a=ssrc-group:FID").map(function (p) { var m = p.substr(17).split(" "); return m.map(function (d) { return parseInt(d, 10) }) }); l.length > 0 && l[0].length > 1 && l[0][0] === s && (c = l[0][1]), i.codecs.forEach(function (p) { if (p.name.toUpperCase() === "RTX" && p.parameters.apt) { var m = { ssrc: s, codecPayloadType: parseInt(p.parameters.apt, 10) }; s && c && (m.rtx = { ssrc: c }), n.push(m), a && (m = JSON.parse(JSON.stringify(m)), m.fec = { ssrc: s, mechanism: o ? "red+ulpfec" : "red" }, n.push(m)) } }), n.length === 0 && s && n.push({ ssrc: s }); var f = t.matchPrefix(r, "b="); return f.length && (f[0].indexOf("b=TIAS:") === 0 ? f = parseInt(f[0].substr(7), 10) : f[0].indexOf("b=AS:") === 0 ? f = parseInt(f[0].substr(5), 10) * 1e3 * .95 - 50 * 40 * 8 : f = void 0, n.forEach(function (p) { p.maxBitrate = f })), n }, t.parseRtcpParameters = function (r) { var n = {}, i = t.matchPrefix(r, "a=ssrc:").map(function (u) { return t.parseSsrcMedia(u) }).filter(function (u) { return u.attribute === "cname" })[0]; i && (n.cname = i.value, n.ssrc = i.ssrc); var a = t.matchPrefix(r, "a=rtcp-rsize"); n.reducedSize = a.length > 0, n.compound = a.length === 0; var o = t.matchPrefix(r, "a=rtcp-mux"); return n.mux = o.length > 0, n }, t.parseMsid = function (r) { var n, i = t.matchPrefix(r, "a=msid:"); if (i.length === 1) return n = i[0].substr(7).split(" "), { stream: n[0], track: n[1] }; var a = t.matchPrefix(r, "a=ssrc:").map(function (o) { return t.parseSsrcMedia(o) }).filter(function (o) { return o.attribute === "msid" }); if (a.length > 0) return n = a[0].value.split(" "), { stream: n[0], track: n[1] } }, t.parseSctpDescription = function (r) { var n = t.parseMLine(r), i = t.matchPrefix(r, "a=max-message-size:"), a; i.length > 0 && (a = parseInt(i[0].substr(19), 10)), isNaN(a) && (a = 65536); var o = t.matchPrefix(r, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: n.fmt, maxMessageSize: a }; var u = t.matchPrefix(r, "a=sctpmap:"); if (u.length > 0) { var s = t.matchPrefix(r, "a=sctpmap:")[0].substr(10).split(" "); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: a } } }, t.writeSctpDescription = function (r, n) {
            var i = []; return r.protocol !== "DTLS/SCTP" ? i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + n.port + `\r
`] : i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + n.port + " " + n.protocol + ` 65535\r
`], n.maxMessageSize !== void 0 && i.push("a=max-message-size:" + n.maxMessageSize + `\r
`), i.join("")
        }, t.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, t.writeSessionBoilerplate = function (r, n, i) {
            var a, o = n !== void 0 ? n : 2; r ? a = r : a = t.generateSessionId(); var u = i || "thisisadapterortc"; return `v=0\r
o=`+ u + " " + a + " " + o + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`}, t.writeMediaSection = function (r, n, i, a) {
            var o = t.writeRtpDescription(r.kind, n); if (o += t.writeIceParameters(r.iceGatherer.getLocalParameters()), o += t.writeDtlsParameters(r.dtlsTransport.getLocalParameters(), i === "offer" ? "actpass" : "active"), o += "a=mid:" + r.mid + `\r
`, r.direction ? o += "a=" + r.direction + `\r
`: r.rtpSender && r.rtpReceiver ? o += `a=sendrecv\r
`: r.rtpSender ? o += `a=sendonly\r
`: r.rtpReceiver ? o += `a=recvonly\r
`: o += `a=inactive\r
`, r.rtpSender) {
                var u = "msid:" + a.id + " " + r.rtpSender.track.id + `\r
`; o += "a=" + u, o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " " + u, r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " " + u, o += "a=ssrc-group:FID " + r.sendEncodingParameters[0].ssrc + " " + r.sendEncodingParameters[0].rtx.ssrc + `\r
`)
            } return o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " cname:" + t.localCName + `\r
`, r.rtpSender && r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " cname:" + t.localCName + `\r
`), o
        }, t.getDirection = function (r, n) { for (var i = t.splitLines(r), a = 0; a < i.length; a++)switch (i[a]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return i[a].substr(2) }return n ? t.getDirection(n) : "sendrecv" }, t.getKind = function (r) { var n = t.splitLines(r), i = n[0].split(" "); return i[0].substr(2) }, t.isRejected = function (r) { return r.split(" ", 2)[1] === "0" }, t.parseMLine = function (r) { var n = t.splitLines(r), i = n[0].substr(2).split(" "); return { kind: i[0], port: parseInt(i[1], 10), protocol: i[2], fmt: i.slice(3).join(" ") } }, t.parseOLine = function (r) { var n = t.matchPrefix(r, "o=")[0], i = n.substr(2).split(" "); return { username: i[0], sessionId: i[1], sessionVersion: parseInt(i[2], 10), netType: i[3], addressType: i[4], address: i[5] } }, t.isValidSDP = function (r) { if (typeof r != "string" || r.length === 0) return !1; for (var n = t.splitLines(r), i = 0; i < n.length; i++)if (n[i].length < 2 || n[i].charAt(1) !== "=") return !1; return !0 }, e.exports = t
})(Vn); const ur = Vn.exports; var M = Vn.exports; function Oc(e) { return { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type } function bi(e, t, r, n, i) {
    var a = M.writeRtpDescription(e.kind, t); if (a += M.writeIceParameters(e.iceGatherer.getLocalParameters()), a += M.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === "offer" ? "actpass" : i || "active"), a += "a=mid:" + e.mid + `\r
`, e.rtpSender && e.rtpReceiver ? a += `a=sendrecv\r
`: e.rtpSender ? a += `a=sendonly\r
`: e.rtpReceiver ? a += `a=recvonly\r
`: a += `a=inactive\r
`, e.rtpSender) {
        var o = e.rtpSender._initialTrackId || e.rtpSender.track.id; e.rtpSender._initialTrackId = o; var u = "msid:" + (n ? n.id : "-") + " " + o + `\r
`; a += "a=" + u, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + u, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + u, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + `\r
`)
    } return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + M.localCName + `\r
`, e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + M.localCName + `\r
`), a
} function Ac(e, t) { var r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(function (n) { if (n && (n.urls || n.url)) { var i = n.urls || n.url; n.url && !n.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead."); var a = typeof i == "string"; return a && (i = [i]), i = i.filter(function (o) { var u = o.indexOf("turn:") === 0 && o.indexOf("transport=udp") !== -1 && o.indexOf("turn:[") === -1 && !r; return u ? (r = !0, !0) : o.indexOf("stun:") === 0 && t >= 14393 && o.indexOf("?transport=udp") === -1 }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } function Zt(e, t) { var r = { codecs: [], headerExtensions: [], fecMechanisms: [] }, n = function (a, o) { a = parseInt(a, 10); for (var u = 0; u < o.length; u++)if (o[u].payloadType === a || o[u].preferredPayloadType === a) return o[u] }, i = function (a, o, u, s) { var c = n(a.parameters.apt, u), l = n(o.parameters.apt, s); return c && l && c.name.toLowerCase() === l.name.toLowerCase() }; return e.codecs.forEach(function (a) { for (var o = 0; o < t.codecs.length; o++) { var u = t.codecs[o]; if (a.name.toLowerCase() === u.name.toLowerCase() && a.clockRate === u.clockRate) { if (a.name.toLowerCase() === "rtx" && a.parameters && u.parameters.apt && !i(a, u, e.codecs, t.codecs)) continue; u = JSON.parse(JSON.stringify(u)), u.numChannels = Math.min(a.numChannels, u.numChannels), r.codecs.push(u), u.rtcpFeedback = u.rtcpFeedback.filter(function (s) { for (var c = 0; c < a.rtcpFeedback.length; c++)if (a.rtcpFeedback[c].type === s.type && a.rtcpFeedback[c].parameter === s.parameter) return !0; return !1 }); break } } }), e.headerExtensions.forEach(function (a) { for (var o = 0; o < t.headerExtensions.length; o++) { var u = t.headerExtensions[o]; if (a.uri === u.uri) { r.headerExtensions.push(u); break } } }), r } function _i(e, t, r) { return { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t][e].indexOf(r) !== -1 } function zr(e, t) { var r = e.getRemoteCandidates().find(function (n) { return t.foundation === n.foundation && t.ip === n.ip && t.port === n.port && t.priority === n.priority && t.protocol === n.protocol && t.type === n.type }); return r || e.addRemoteCandidate(t), !r } function ne(e, t) { var r = new Error(t); return r.name = e, r.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e], r } var Ic = function (e, t) {
    function r(s, c) { c.addTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", { track: s })) } function n(s, c) { c.removeTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", { track: s })) } function i(s, c, l, f) { var p = new Event("track"); p.track = c, p.receiver = l, p.transceiver = { receiver: l }, p.streams = f, e.setTimeout(function () { s._dispatchEvent("track", p) }) } var a = function (s) { var c = this, l = document.createDocumentFragment(); if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (p) { c[p] = l[p].bind(l) }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", s = JSON.parse(JSON.stringify(s || {})), this.usingBundle = s.bundlePolicy === "max-bundle", s.rtcpMuxPolicy === "negotiate") throw ne("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported"); switch (s.rtcpMuxPolicy || (s.rtcpMuxPolicy = "require"), s.iceTransportPolicy) { case "all": case "relay": break; default: s.iceTransportPolicy = "all"; break }switch (s.bundlePolicy) { case "balanced": case "max-compat": case "max-bundle": break; default: s.bundlePolicy = "balanced"; break }if (s.iceServers = Ac(s.iceServers || [], t), this._iceGatherers = [], s.iceCandidatePoolSize) for (var f = s.iceCandidatePoolSize; f > 0; f--)this._iceGatherers.push(new e.RTCIceGatherer({ iceServers: s.iceServers, gatherPolicy: s.iceTransportPolicy })); else s.iceCandidatePoolSize = 0; this._config = s, this.transceivers = [], this._sdpSessionId = M.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1 }; Object.defineProperty(a.prototype, "localDescription", { configurable: !0, get: function () { return this._localDescription } }), Object.defineProperty(a.prototype, "remoteDescription", { configurable: !0, get: function () { return this._remoteDescription } }), a.prototype.onicecandidate = null, a.prototype.onaddstream = null, a.prototype.ontrack = null, a.prototype.onremovestream = null, a.prototype.onsignalingstatechange = null, a.prototype.oniceconnectionstatechange = null, a.prototype.onconnectionstatechange = null, a.prototype.onicegatheringstatechange = null, a.prototype.onnegotiationneeded = null, a.prototype.ondatachannel = null, a.prototype._dispatchEvent = function (s, c) { this._isClosed || (this.dispatchEvent(c), typeof this["on" + s] == "function" && this["on" + s](c)) }, a.prototype._emitGatheringStateChange = function () { var s = new Event("icegatheringstatechange"); this._dispatchEvent("icegatheringstatechange", s) }, a.prototype.getConfiguration = function () { return this._config }, a.prototype.getLocalStreams = function () { return this.localStreams }, a.prototype.getRemoteStreams = function () { return this.remoteStreams }, a.prototype._createTransceiver = function (s, c) { var l = this.transceivers.length > 0, f = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: s, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: !0 }; if (this.usingBundle && l) f.iceTransport = this.transceivers[0].iceTransport, f.dtlsTransport = this.transceivers[0].dtlsTransport; else { var p = this._createIceAndDtlsTransports(); f.iceTransport = p.iceTransport, f.dtlsTransport = p.dtlsTransport } return c || this.transceivers.push(f), f }, a.prototype.addTrack = function (s, c) { if (this._isClosed) throw ne("InvalidStateError", "Attempted to call addTrack on a closed peerconnection."); var l = this.transceivers.find(function (m) { return m.track === s }); if (l) throw ne("InvalidAccessError", "Track already exists."); for (var f, p = 0; p < this.transceivers.length; p++)!this.transceivers[p].track && this.transceivers[p].kind === s.kind && (f = this.transceivers[p]); return f || (f = this._createTransceiver(s.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(c) === -1 && this.localStreams.push(c), f.track = s, f.stream = c, f.rtpSender = new e.RTCRtpSender(s, f.dtlsTransport), f.rtpSender }, a.prototype.addStream = function (s) { var c = this; if (t >= 15025) s.getTracks().forEach(function (f) { c.addTrack(f, s) }); else { var l = s.clone(); s.getTracks().forEach(function (f, p) { var m = l.getTracks()[p]; f.addEventListener("enabled", function (d) { m.enabled = d.enabled }) }), l.getTracks().forEach(function (f) { c.addTrack(f, l) }) } }, a.prototype.removeTrack = function (s) { if (this._isClosed) throw ne("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection."); if (!(s instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender."); var c = this.transceivers.find(function (p) { return p.rtpSender === s }); if (!c) throw ne("InvalidAccessError", "Sender was not created by this connection."); var l = c.stream; c.rtpSender.stop(), c.rtpSender = null, c.track = null, c.stream = null; var f = this.transceivers.map(function (p) { return p.stream }); f.indexOf(l) === -1 && this.localStreams.indexOf(l) > -1 && this.localStreams.splice(this.localStreams.indexOf(l), 1), this._maybeFireNegotiationNeeded() }, a.prototype.removeStream = function (s) { var c = this; s.getTracks().forEach(function (l) { var f = c.getSenders().find(function (p) { return p.track === l }); f && c.removeTrack(f) }) }, a.prototype.getSenders = function () { return this.transceivers.filter(function (s) { return !!s.rtpSender }).map(function (s) { return s.rtpSender }) }, a.prototype.getReceivers = function () { return this.transceivers.filter(function (s) { return !!s.rtpReceiver }).map(function (s) { return s.rtpReceiver }) }, a.prototype._createIceGatherer = function (s, c) { var l = this; if (c && s > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var f = new e.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(f, "state", { value: "new", writable: !0 }), this.transceivers[s].bufferedCandidateEvents = [], this.transceivers[s].bufferCandidates = function (p) { var m = !p.candidate || Object.keys(p.candidate).length === 0; f.state = m ? "completed" : "gathering", l.transceivers[s].bufferedCandidateEvents !== null && l.transceivers[s].bufferedCandidateEvents.push(p) }, f.addEventListener("localcandidate", this.transceivers[s].bufferCandidates), f }, a.prototype._gather = function (s, c) {
        var l = this, f = this.transceivers[c].iceGatherer; if (!f.onlocalcandidate) {
            var p = this.transceivers[c].bufferedCandidateEvents; this.transceivers[c].bufferedCandidateEvents = null, f.removeEventListener("localcandidate", this.transceivers[c].bufferCandidates), f.onlocalcandidate = function (m) {
                if (!(l.usingBundle && c > 0)) {
                    var d = new Event("icecandidate"); d.candidate = { sdpMid: s, sdpMLineIndex: c }; var h = m.candidate, b = !h || Object.keys(h).length === 0; if (b) (f.state === "new" || f.state === "gathering") && (f.state = "completed"); else { f.state === "new" && (f.state = "gathering"), h.component = 1, h.ufrag = f.getLocalParameters().usernameFragment; var v = M.writeCandidate(h); d.candidate = Object.assign(d.candidate, M.parseCandidate(v)), d.candidate.candidate = v, d.candidate.toJSON = function () { return { candidate: d.candidate.candidate, sdpMid: d.candidate.sdpMid, sdpMLineIndex: d.candidate.sdpMLineIndex, usernameFragment: d.candidate.usernameFragment } } } var g = M.getMediaSections(l._localDescription.sdp); b ? g[d.candidate.sdpMLineIndex] += `a=end-of-candidates\r
`: g[d.candidate.sdpMLineIndex] += "a=" + d.candidate.candidate + `\r
`, l._localDescription.sdp = M.getDescription(l._localDescription.sdp) + g.join(""); var C = l.transceivers.every(function (_) { return _.iceGatherer && _.iceGatherer.state === "completed" }); l.iceGatheringState !== "gathering" && (l.iceGatheringState = "gathering", l._emitGatheringStateChange()), b || l._dispatchEvent("icecandidate", d), C && (l._dispatchEvent("icecandidate", new Event("icecandidate")), l.iceGatheringState = "complete", l._emitGatheringStateChange())
                }
            }, e.setTimeout(function () { p.forEach(function (m) { f.onlocalcandidate(m) }) }, 0)
        }
    }, a.prototype._createIceAndDtlsTransports = function () { var s = this, c = new e.RTCIceTransport(null); c.onicestatechange = function () { s._updateIceConnectionState(), s._updateConnectionState() }; var l = new e.RTCDtlsTransport(c); return l.ondtlsstatechange = function () { s._updateConnectionState() }, l.onerror = function () { Object.defineProperty(l, "state", { value: "failed", writable: !0 }), s._updateConnectionState() }, { iceTransport: c, dtlsTransport: l } }, a.prototype._disposeIceAndDtlsTransports = function (s) { var c = this.transceivers[s].iceGatherer; c && (delete c.onlocalcandidate, delete this.transceivers[s].iceGatherer); var l = this.transceivers[s].iceTransport; l && (delete l.onicestatechange, delete this.transceivers[s].iceTransport); var f = this.transceivers[s].dtlsTransport; f && (delete f.ondtlsstatechange, delete f.onerror, delete this.transceivers[s].dtlsTransport) }, a.prototype._transceive = function (s, c, l) { var f = Zt(s.localCapabilities, s.remoteCapabilities); c && s.rtpSender && (f.encodings = s.sendEncodingParameters, f.rtcp = { cname: M.localCName, compound: s.rtcpParameters.compound }, s.recvEncodingParameters.length && (f.rtcp.ssrc = s.recvEncodingParameters[0].ssrc), s.rtpSender.send(f)), l && s.rtpReceiver && f.codecs.length > 0 && (s.kind === "video" && s.recvEncodingParameters && t < 15019 && s.recvEncodingParameters.forEach(function (p) { delete p.rtx }), s.recvEncodingParameters.length ? f.encodings = s.recvEncodingParameters : f.encodings = [{}], f.rtcp = { compound: s.rtcpParameters.compound }, s.rtcpParameters.cname && (f.rtcp.cname = s.rtcpParameters.cname), s.sendEncodingParameters.length && (f.rtcp.ssrc = s.sendEncodingParameters[0].ssrc), s.rtpReceiver.receive(f)) }, a.prototype.setLocalDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(ne("TypeError", 'Unsupported type "' + s.type + '"')); if (!_i("setLocalDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(ne("InvalidStateError", "Can not set local " + s.type + " in state " + c.signalingState)); var l, f; if (s.type === "offer") l = M.splitSections(s.sdp), f = l.shift(), l.forEach(function (m, d) { var h = M.parseRtpParameters(m); c.transceivers[d].localCapabilities = h }), c.transceivers.forEach(function (m, d) { c._gather(m.mid, d) }); else if (s.type === "answer") { l = M.splitSections(c._remoteDescription.sdp), f = l.shift(); var p = M.matchPrefix(f, "a=ice-lite").length > 0; l.forEach(function (m, d) { var h = c.transceivers[d], b = h.iceGatherer, v = h.iceTransport, g = h.dtlsTransport, C = h.localCapabilities, _ = h.remoteCapabilities, y = M.isRejected(m) && M.matchPrefix(m, "a=bundle-only").length === 0; if (!y && !h.rejected) { var T = M.getIceParameters(m, f), R = M.getDtlsParameters(m, f); p && (R.role = "server"), (!c.usingBundle || d === 0) && (c._gather(h.mid, d), v.state === "new" && v.start(b, T, p ? "controlling" : "controlled"), g.state === "new" && g.start(R)); var k = Zt(C, _); c._transceive(h, k.codecs.length > 0, !1) } }) } return c._localDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-local-offer") : c._updateSignalingState("stable"), Promise.resolve() }, a.prototype.setRemoteDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(ne("TypeError", 'Unsupported type "' + s.type + '"')); if (!_i("setRemoteDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(ne("InvalidStateError", "Can not set remote " + s.type + " in state " + c.signalingState)); var l = {}; c.remoteStreams.forEach(function (v) { l[v.id] = v }); var f = [], p = M.splitSections(s.sdp), m = p.shift(), d = M.matchPrefix(m, "a=ice-lite").length > 0, h = M.matchPrefix(m, "a=group:BUNDLE ").length > 0; c.usingBundle = h; var b = M.matchPrefix(m, "a=ice-options:")[0]; return b ? c.canTrickleIceCandidates = b.substr(14).split(" ").indexOf("trickle") >= 0 : c.canTrickleIceCandidates = !1, p.forEach(function (v, g) { var C = M.splitLines(v), _ = M.getKind(v), y = M.isRejected(v) && M.matchPrefix(v, "a=bundle-only").length === 0, T = C[0].substr(2).split(" ")[2], R = M.getDirection(v, m), k = M.parseMsid(v), I = M.getMid(v) || M.generateIdentifier(); if (y || _ === "application" && (T === "DTLS/SCTP" || T === "UDP/DTLS/SCTP")) { c.transceivers[g] = { mid: I, kind: _, protocol: T, rejected: !0 }; return } !y && c.transceivers[g] && c.transceivers[g].rejected && (c.transceivers[g] = c._createTransceiver(_, !0)); var P, U, K, N, G, B, re, X, Q, he = M.parseRtpParameters(v), se, be; y || (se = M.getIceParameters(v, m), be = M.getDtlsParameters(v, m), be.role = "client"), re = M.parseRtpEncodingParameters(v); var me = M.parseRtcpParameters(v), Me = M.matchPrefix(v, "a=end-of-candidates", m).length > 0, Y = M.matchPrefix(v, "a=candidate:").map(function (fe) { return M.parseCandidate(fe) }).filter(function (fe) { return fe.component === 1 }); if ((s.type === "offer" || s.type === "answer") && !y && h && g > 0 && c.transceivers[g] && (c._disposeIceAndDtlsTransports(g), c.transceivers[g].iceGatherer = c.transceivers[0].iceGatherer, c.transceivers[g].iceTransport = c.transceivers[0].iceTransport, c.transceivers[g].dtlsTransport = c.transceivers[0].dtlsTransport, c.transceivers[g].rtpSender && c.transceivers[g].rtpSender.setTransport(c.transceivers[0].dtlsTransport), c.transceivers[g].rtpReceiver && c.transceivers[g].rtpReceiver.setTransport(c.transceivers[0].dtlsTransport)), s.type === "offer" && !y) { P = c.transceivers[g] || c._createTransceiver(_), P.mid = I, P.iceGatherer || (P.iceGatherer = c._createIceGatherer(g, h)), Y.length && P.iceTransport.state === "new" && (Me && (!h || g === 0) ? P.iceTransport.setRemoteCandidates(Y) : Y.forEach(function (fe) { zr(P.iceTransport, fe) })), X = e.RTCRtpReceiver.getCapabilities(_), t < 15019 && (X.codecs = X.codecs.filter(function (fe) { return fe.name !== "rtx" })), B = P.sendEncodingParameters || [{ ssrc: (2 * g + 2) * 1001 }]; var je = !1; if (R === "sendrecv" || R === "sendonly") { if (je = !P.rtpReceiver, G = P.rtpReceiver || new e.RTCRtpReceiver(P.dtlsTransport, _), je) { var Be; Q = G.track, k && k.stream === "-" || (k ? (l[k.stream] || (l[k.stream] = new e.MediaStream, Object.defineProperty(l[k.stream], "id", { get: function () { return k.stream } })), Object.defineProperty(Q, "id", { get: function () { return k.track } }), Be = l[k.stream]) : (l.default || (l.default = new e.MediaStream), Be = l.default)), Be && (r(Q, Be), P.associatedRemoteMediaStreams.push(Be)), f.push([Q, G, Be]) } } else P.rtpReceiver && P.rtpReceiver.track && (P.associatedRemoteMediaStreams.forEach(function (fe) { var Wn = fe.getTracks().find(function (lo) { return lo.id === P.rtpReceiver.track.id }); Wn && n(Wn, fe) }), P.associatedRemoteMediaStreams = []); P.localCapabilities = X, P.remoteCapabilities = he, P.rtpReceiver = G, P.rtcpParameters = me, P.sendEncodingParameters = B, P.recvEncodingParameters = re, c._transceive(c.transceivers[g], !1, je) } else if (s.type === "answer" && !y) { P = c.transceivers[g], U = P.iceGatherer, K = P.iceTransport, N = P.dtlsTransport, G = P.rtpReceiver, B = P.sendEncodingParameters, X = P.localCapabilities, c.transceivers[g].recvEncodingParameters = re, c.transceivers[g].remoteCapabilities = he, c.transceivers[g].rtcpParameters = me, Y.length && K.state === "new" && ((d || Me) && (!h || g === 0) ? K.setRemoteCandidates(Y) : Y.forEach(function (fe) { zr(P.iceTransport, fe) })), (!h || g === 0) && (K.state === "new" && K.start(U, se, "controlling"), N.state === "new" && N.start(be)); var co = Zt(P.localCapabilities, P.remoteCapabilities), uo = co.codecs.filter(function (fe) { return fe.name.toLowerCase() === "rtx" }).length; !uo && P.sendEncodingParameters[0].rtx && delete P.sendEncodingParameters[0].rtx, c._transceive(P, R === "sendrecv" || R === "recvonly", R === "sendrecv" || R === "sendonly"), G && (R === "sendrecv" || R === "sendonly") ? (Q = G.track, k ? (l[k.stream] || (l[k.stream] = new e.MediaStream), r(Q, l[k.stream]), f.push([Q, G, l[k.stream]])) : (l.default || (l.default = new e.MediaStream), r(Q, l.default), f.push([Q, G, l.default]))) : delete P.rtpReceiver } }), c._dtlsRole === void 0 && (c._dtlsRole = s.type === "offer" ? "active" : "passive"), c._remoteDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-remote-offer") : c._updateSignalingState("stable"), Object.keys(l).forEach(function (v) { var g = l[v]; if (g.getTracks().length) { if (c.remoteStreams.indexOf(g) === -1) { c.remoteStreams.push(g); var C = new Event("addstream"); C.stream = g, e.setTimeout(function () { c._dispatchEvent("addstream", C) }) } f.forEach(function (_) { var y = _[0], T = _[1]; g.id === _[2].id && i(c, y, T, [g]) }) } }), f.forEach(function (v) { v[2] || i(c, v[0], v[1], []) }), e.setTimeout(function () { !(c && c.transceivers) || c.transceivers.forEach(function (v) { v.iceTransport && v.iceTransport.state === "new" && v.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), v.iceTransport.addRemoteCandidate({})) }) }, 4e3), Promise.resolve() }, a.prototype.close = function () { this.transceivers.forEach(function (s) { s.iceTransport && s.iceTransport.stop(), s.dtlsTransport && s.dtlsTransport.stop(), s.rtpSender && s.rtpSender.stop(), s.rtpReceiver && s.rtpReceiver.stop() }), this._isClosed = !0, this._updateSignalingState("closed") }, a.prototype._updateSignalingState = function (s) { this.signalingState = s; var c = new Event("signalingstatechange"); this._dispatchEvent("signalingstatechange", c) }, a.prototype._maybeFireNegotiationNeeded = function () { var s = this; this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, e.setTimeout(function () { if (s.needNegotiation) { s.needNegotiation = !1; var c = new Event("negotiationneeded"); s._dispatchEvent("negotiationneeded", c) } }, 0)) }, a.prototype._updateIceConnectionState = function () { var s, c = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (f) { f.iceTransport && !f.rejected && c[f.iceTransport.state]++ }), s = "new", c.failed > 0 ? s = "failed" : c.checking > 0 ? s = "checking" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 ? s = "connected" : c.completed > 0 && (s = "completed"), s !== this.iceConnectionState) { this.iceConnectionState = s; var l = new Event("iceconnectionstatechange"); this._dispatchEvent("iceconnectionstatechange", l) } }, a.prototype._updateConnectionState = function () { var s, c = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (f) { f.iceTransport && f.dtlsTransport && !f.rejected && (c[f.iceTransport.state]++, c[f.dtlsTransport.state]++) }), c.connected += c.completed, s = "new", c.failed > 0 ? s = "failed" : c.connecting > 0 ? s = "connecting" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 && (s = "connected"), s !== this.connectionState) { this.connectionState = s; var l = new Event("connectionstatechange"); this._dispatchEvent("connectionstatechange", l) } }, a.prototype.createOffer = function () {
        var s = this; if (s._isClosed) return Promise.reject(ne("InvalidStateError", "Can not call createOffer after close")); var c = s.transceivers.filter(function (d) { return d.kind === "audio" }).length, l = s.transceivers.filter(function (d) { return d.kind === "video" }).length, f = arguments[0]; if (f) { if (f.mandatory || f.optional) throw new TypeError("Legacy mandatory/optional constraints not supported."); f.offerToReceiveAudio !== void 0 && (f.offerToReceiveAudio === !0 ? c = 1 : f.offerToReceiveAudio === !1 ? c = 0 : c = f.offerToReceiveAudio), f.offerToReceiveVideo !== void 0 && (f.offerToReceiveVideo === !0 ? l = 1 : f.offerToReceiveVideo === !1 ? l = 0 : l = f.offerToReceiveVideo) } for (s.transceivers.forEach(function (d) { d.kind === "audio" ? (c--, c < 0 && (d.wantReceive = !1)) : d.kind === "video" && (l--, l < 0 && (d.wantReceive = !1)) }); c > 0 || l > 0;)c > 0 && (s._createTransceiver("audio"), c--), l > 0 && (s._createTransceiver("video"), l--); var p = M.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.transceivers.forEach(function (d, h) { var b = d.track, v = d.kind, g = d.mid || M.generateIdentifier(); d.mid = g, d.iceGatherer || (d.iceGatherer = s._createIceGatherer(h, s.usingBundle)); var C = e.RTCRtpSender.getCapabilities(v); t < 15019 && (C.codecs = C.codecs.filter(function (y) { return y.name !== "rtx" })), C.codecs.forEach(function (y) { y.name === "H264" && y.parameters["level-asymmetry-allowed"] === void 0 && (y.parameters["level-asymmetry-allowed"] = "1"), d.remoteCapabilities && d.remoteCapabilities.codecs && d.remoteCapabilities.codecs.forEach(function (T) { y.name.toLowerCase() === T.name.toLowerCase() && y.clockRate === T.clockRate && (y.preferredPayloadType = T.payloadType) }) }), C.headerExtensions.forEach(function (y) { var T = d.remoteCapabilities && d.remoteCapabilities.headerExtensions || []; T.forEach(function (R) { y.uri === R.uri && (y.id = R.id) }) }); var _ = d.sendEncodingParameters || [{ ssrc: (2 * h + 1) * 1001 }]; b && t >= 15019 && v === "video" && !_[0].rtx && (_[0].rtx = { ssrc: _[0].ssrc + 1 }), d.wantReceive && (d.rtpReceiver = new e.RTCRtpReceiver(d.dtlsTransport, v)), d.localCapabilities = C, d.sendEncodingParameters = _ }), s._config.bundlePolicy !== "max-compat" && (p += "a=group:BUNDLE " + s.transceivers.map(function (d) { return d.mid }).join(" ") + `\r
`), p += `a=ice-options:trickle\r
`, s.transceivers.forEach(function (d, h) {
            p += bi(d, d.localCapabilities, "offer", d.stream, s._dtlsRole), p += `a=rtcp-rsize\r
`, d.iceGatherer && s.iceGatheringState !== "new" && (h === 0 || !s.usingBundle) && (d.iceGatherer.getLocalCandidates().forEach(function (b) {
                b.component = 1, p += "a=" + M.writeCandidate(b) + `\r
`}), d.iceGatherer.state === "completed" && (p += `a=end-of-candidates\r
`))
        }); var m = new e.RTCSessionDescription({ type: "offer", sdp: p }); return Promise.resolve(m)
    }, a.prototype.createAnswer = function () {
        var s = this; if (s._isClosed) return Promise.reject(ne("InvalidStateError", "Can not call createAnswer after close")); if (!(s.signalingState === "have-remote-offer" || s.signalingState === "have-local-pranswer")) return Promise.reject(ne("InvalidStateError", "Can not call createAnswer in signalingState " + s.signalingState)); var c = M.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.usingBundle && (c += "a=group:BUNDLE " + s.transceivers.map(function (p) { return p.mid }).join(" ") + `\r
`), c += `a=ice-options:trickle\r
`; var l = M.getMediaSections(s._remoteDescription.sdp).length; s.transceivers.forEach(function (p, m) {
            if (!(m + 1 > l)) {
                if (p.rejected) {
                    p.kind === "application" ? p.protocol === "DTLS/SCTP" ? c += `m=application 0 DTLS/SCTP 5000\r
`: c += "m=application 0 " + p.protocol + ` webrtc-datachannel\r
`: p.kind === "audio" ? c += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
`: p.kind === "video" && (c += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), c += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:`+ p.mid + `\r
`; return
                } if (p.stream) { var d; p.kind === "audio" ? d = p.stream.getAudioTracks()[0] : p.kind === "video" && (d = p.stream.getVideoTracks()[0]), d && t >= 15019 && p.kind === "video" && !p.sendEncodingParameters[0].rtx && (p.sendEncodingParameters[0].rtx = { ssrc: p.sendEncodingParameters[0].ssrc + 1 }) } var h = Zt(p.localCapabilities, p.remoteCapabilities), b = h.codecs.filter(function (v) { return v.name.toLowerCase() === "rtx" }).length; !b && p.sendEncodingParameters[0].rtx && delete p.sendEncodingParameters[0].rtx, c += bi(p, h, "answer", p.stream, s._dtlsRole), p.rtcpParameters && p.rtcpParameters.reducedSize && (c += `a=rtcp-rsize\r
`)
            }
        }); var f = new e.RTCSessionDescription({ type: "answer", sdp: c }); return Promise.resolve(f)
    }, a.prototype.addIceCandidate = function (s) {
        var c = this, l; return s && !(s.sdpMLineIndex !== void 0 || s.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function (f, p) {
            if (c._remoteDescription) if (!s || s.candidate === "") for (var m = 0; m < c.transceivers.length && !(!c.transceivers[m].rejected && (c.transceivers[m].iceTransport.addRemoteCandidate({}), l = M.getMediaSections(c._remoteDescription.sdp), l[m] += `a=end-of-candidates\r
`, c._remoteDescription.sdp = M.getDescription(c._remoteDescription.sdp) + l.join(""), c.usingBundle)); m++); else {
                var d = s.sdpMLineIndex; if (s.sdpMid) { for (var h = 0; h < c.transceivers.length; h++)if (c.transceivers[h].mid === s.sdpMid) { d = h; break } } var b = c.transceivers[d]; if (b) {
                    if (b.rejected) return f(); var v = Object.keys(s.candidate).length > 0 ? M.parseCandidate(s.candidate) : {}; if (v.protocol === "tcp" && (v.port === 0 || v.port === 9) || v.component && v.component !== 1) return f(); if ((d === 0 || d > 0 && b.iceTransport !== c.transceivers[0].iceTransport) && !zr(b.iceTransport, v)) return p(ne("OperationError", "Can not add ICE candidate")); var g = s.candidate.trim(); g.indexOf("a=") === 0 && (g = g.substr(2)), l = M.getMediaSections(c._remoteDescription.sdp), l[d] += "a=" + (v.type ? g : "end-of-candidates") + `\r
`, c._remoteDescription.sdp = M.getDescription(c._remoteDescription.sdp) + l.join("")
                } else return p(ne("OperationError", "Can not add ICE candidate"))
            } else return p(ne("InvalidStateError", "Can not add ICE candidate without a remote description")); f()
        })
    }, a.prototype.getStats = function (s) { if (s && s instanceof e.MediaStreamTrack) { var c = null; if (this.transceivers.forEach(function (f) { f.rtpSender && f.rtpSender.track === s ? c = f.rtpSender : f.rtpReceiver && f.rtpReceiver.track === s && (c = f.rtpReceiver) }), !c) throw ne("InvalidAccessError", "Invalid selector."); return c.getStats() } var l = []; return this.transceivers.forEach(function (f) { ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function (p) { f[p] && l.push(f[p].getStats()) }) }), Promise.all(l).then(function (f) { var p = new Map; return f.forEach(function (m) { m.forEach(function (d) { p.set(d.id, d) }) }), p }) }; var o = ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"]; o.forEach(function (s) { var c = e[s]; if (c && c.prototype && c.prototype.getStats) { var l = c.prototype.getStats; c.prototype.getStats = function () { return l.apply(this).then(function (f) { var p = new Map; return Object.keys(f).forEach(function (m) { f[m].type = Oc(f[m]), p.set(m, f[m]) }), p }) } } }); var u = ["createOffer", "createAnswer"]; return u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[0] == "function" || typeof l[1] == "function" ? c.apply(this, [arguments[2]]).then(function (f) { typeof l[0] == "function" && l[0].apply(null, [f]) }, function (f) { typeof l[1] == "function" && l[1].apply(null, [f]) }) : c.apply(this, arguments) } }), u = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[1] == "function" || typeof l[2] == "function" ? c.apply(this, arguments).then(function () { typeof l[1] == "function" && l[1].apply(null) }, function (f) { typeof l[2] == "function" && l[2].apply(null, [f]) }) : c.apply(this, arguments) } }), ["getStats"].forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[1] == "function" ? c.apply(this, arguments).then(function () { typeof l[1] == "function" && l[1].apply(null) }) : c.apply(this, arguments) } }), a
}; function Ma(e) { const t = e && e.navigator, r = function (i) { return { name: { PermissionDeniedError: "NotAllowedError" }[i.name] || i.name, message: i.message, constraint: i.constraint, toString() { return this.name } } }, n = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (i) { return n(i).catch(a => Promise.reject(r(a))) } } function ja(e) { "getDisplayMedia" in e.navigator && (!e.navigator.mediaDevices || e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator))) } function _n(e, t) { if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function (i) { return i }), e.RTCSessionDescription || (e.RTCSessionDescription = function (i) { return i }), t.version < 15025)) { const n = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled"); Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", { set(i) { n.set.call(this, i); const a = new Event("enabled"); a.enabled = i, this.dispatchEvent(a) } }) } e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype) && Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf } }), e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender); const r = Ic(e, t.version); e.RTCPeerConnection = function (i) { return i && i.iceServers && (i.iceServers = wc(i.iceServers, t.version), Gn("ICE servers after filtering:", i.iceServers)), new r(i) }, e.RTCPeerConnection.prototype = r.prototype } function Ba(e) { e.RTCRtpSender && !("replaceTrack" in e.RTCRtpSender.prototype) && (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack) } const Ci = Object.freeze(Object.defineProperty({ __proto__: null, shimPeerConnection: _n, shimReplaceTrack: Ba, shimGetUserMedia: Ma, shimGetDisplayMedia: ja }, Symbol.toStringTag, { value: "Module" })); function Fa(e, t) { const r = e && e.navigator, n = e && e.MediaStreamTrack; if (r.getUserMedia = function (i, a, o) { Dr("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r.mediaDevices.getUserMedia(i).then(a, o) }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) { const i = function (o, u, s) { u in o && !(s in o) && (o[s] = o[u], delete o[u]) }, a = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (o) { return typeof o == "object" && typeof o.audio == "object" && (o = JSON.parse(JSON.stringify(o)), i(o.audio, "autoGainControl", "mozAutoGainControl"), i(o.audio, "noiseSuppression", "mozNoiseSuppression")), a(o) }, n && n.prototype.getSettings) { const o = n.prototype.getSettings; n.prototype.getSettings = function () { const u = o.apply(this, arguments); return i(u, "mozAutoGainControl", "autoGainControl"), i(u, "mozNoiseSuppression", "noiseSuppression"), u } } if (n && n.prototype.applyConstraints) { const o = n.prototype.applyConstraints; n.prototype.applyConstraints = function (u) { return this.kind === "audio" && typeof u == "object" && (u = JSON.parse(JSON.stringify(u)), i(u, "autoGainControl", "mozAutoGainControl"), i(u, "noiseSuppression", "mozNoiseSuppression")), o.apply(this, [u]) } } } } function Mc(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || !e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = function (n) { if (!(n && n.video)) { const i = new DOMException("getDisplayMedia without video constraints is undefined"); return i.name = "NotFoundError", i.code = 8, Promise.reject(i) } return n.video === !0 ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n) }) } function Na(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function Cn(e, t) { if (typeof e != "object" || !(e.RTCPeerConnection || e.mozRTCPeerConnection)) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (i) { const a = e.RTCPeerConnection.prototype[i], o = { [i]() { return arguments[0] = new (i === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), a.apply(this, arguments) } }; e.RTCPeerConnection.prototype[i] = o[i] }); const r = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [a, o, u] = arguments; return n.apply(this, [a || null]).then(s => { if (t.version < 53 && !o) try { s.forEach(c => { c.type = r[c.type] || c.type }) } catch (c) { if (c.name !== "TypeError") throw c; s.forEach((l, f) => { s.set(f, Object.assign({}, l, { type: r[l.type] || l.type })) }) } return s }).then(o, u) } } function Ka(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const i = t.apply(this, []); return i.forEach(a => a._pc = this), i }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const i = r.apply(this, arguments); return i._pc = this, i }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function La(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }), gt(e, "track", r => (r.receiver._pc = r.srcElement, r)), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function Ua(e) { !e.RTCPeerConnection || "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { Dr("removeStream", "removeTrack"), this.getSenders().forEach(n => { n.track && r.getTracks().includes(n.track) && this.removeTrack(n) }) }) } function za(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function $a(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const n = arguments[1], i = n && "sendEncodings" in n; i && n.sendEncodings.forEach(o => { if ("rid" in o && !/^[a-z0-9]{0,16}$/i.test(o.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in o && !(parseFloat(o.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in o && !(parseFloat(o.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") }); const a = t.apply(this, arguments); if (i) { const { sender: o } = a, u = o.getParameters(); (!("encodings" in u) || u.encodings.length === 1 && Object.keys(u.encodings[0]).length === 0) && (u.encodings = n.sendEncodings, o.sendEncodings = n.sendEncodings, this.setParametersPromises.push(o.setParameters(u).then(() => { delete o.sendEncodings }).catch(() => { delete o.sendEncodings }))) } return a }) } function Ga(e) { if (!(typeof e == "object" && e.RTCRtpSender)) return; const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const n = t.apply(this, arguments); return "encodings" in n || (n.encodings = [].concat(this.sendEncodings || [{}])), n }) } function Va(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } function qa(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } const Si = Object.freeze(Object.defineProperty({ __proto__: null, shimOnTrack: Na, shimPeerConnection: Cn, shimSenderGetStats: Ka, shimReceiverGetStats: La, shimRemoveStream: Ua, shimRTCDataChannel: za, shimAddTransceiver: $a, shimGetParameters: Ga, shimCreateOffer: Va, shimCreateAnswer: qa, shimGetUserMedia: Fa, shimGetDisplayMedia: Mc }, Symbol.toStringTag, { value: "Module" })); function Ja(e) { if (!(typeof e != "object" || !e.RTCPeerConnection)) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (n) { this._localStreams || (this._localStreams = []), this._localStreams.includes(n) || this._localStreams.push(n), n.getAudioTracks().forEach(i => t.call(this, i, n)), n.getVideoTracks().forEach(i => t.call(this, i, n)) }, e.RTCPeerConnection.prototype.addTrack = function (n, ...i) { return i && i.forEach(a => { this._localStreams ? this._localStreams.includes(a) || this._localStreams.push(a) : this._localStreams = [a] }), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { this._localStreams || (this._localStreams = []); const n = this._localStreams.indexOf(r); if (n === -1) return; this._localStreams.splice(n, 1); const i = r.getTracks(); this.getSenders().forEach(a => { i.includes(a.track) && this.removeTrack(a) }) }) } } function Ha(e) { if (!(typeof e != "object" || !e.RTCPeerConnection) && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(r) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = r), this.addEventListener("track", this._onaddstreampoly = n => { n.streams.forEach(i => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(i)) return; this._remoteStreams.push(i); const a = new Event("addstream"); a.stream = i, this.dispatchEvent(a) }) }) } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const n = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (i) { i.streams.forEach(a => { if (n._remoteStreams || (n._remoteStreams = []), n._remoteStreams.indexOf(a) >= 0) return; n._remoteStreams.push(a); const o = new Event("addstream"); o.stream = a, n.dispatchEvent(o) }) }), t.apply(n, arguments) } } } function Wa(e) { if (typeof e != "object" || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer, i = t.setLocalDescription, a = t.setRemoteDescription, o = t.addIceCandidate; t.createOffer = function (c, l) { const f = arguments.length >= 2 ? arguments[2] : arguments[0], p = r.apply(this, [f]); return l ? (p.then(c, l), Promise.resolve()) : p }, t.createAnswer = function (c, l) { const f = arguments.length >= 2 ? arguments[2] : arguments[0], p = n.apply(this, [f]); return l ? (p.then(c, l), Promise.resolve()) : p }; let u = function (s, c, l) { const f = i.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }; t.setLocalDescription = u, u = function (s, c, l) { const f = a.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }, t.setRemoteDescription = u, u = function (s, c, l) { const f = o.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }, t.addIceCandidate = u } function Qa(e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const r = t.mediaDevices, n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = i => n(Ya(i)) } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (n, i, a) { t.mediaDevices.getUserMedia(n).then(i, a) }.bind(t)) } function Ya(e) { return e && e.video !== void 0 ? Object.assign({}, e, { video: ka(e.video) }) : e } function Xa(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection; e.RTCPeerConnection = function (n, i) { if (n && n.iceServers) { const a = []; for (let o = 0; o < n.iceServers.length; o++) { let u = n.iceServers[o]; !u.hasOwnProperty("urls") && u.hasOwnProperty("url") ? (Dr("RTCIceServer.url", "RTCIceServer.urls"), u = JSON.parse(JSON.stringify(u)), u.urls = u.url, delete u.url, a.push(u)) : a.push(n.iceServers[o]) } n.iceServers = a } return new t(n, i) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get() { return t.generateCertificate } }) } function Za(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function eo(e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (n) { if (n) { typeof n.offerToReceiveAudio < "u" && (n.offerToReceiveAudio = !!n.offerToReceiveAudio); const i = this.getTransceivers().find(o => o.receiver.track.kind === "audio"); n.offerToReceiveAudio === !1 && i ? i.direction === "sendrecv" ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : i.direction === "recvonly" && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : n.offerToReceiveAudio === !0 && !i && this.addTransceiver("audio"), typeof n.offerToReceiveVideo < "u" && (n.offerToReceiveVideo = !!n.offerToReceiveVideo); const a = this.getTransceivers().find(o => o.receiver.track.kind === "video"); n.offerToReceiveVideo === !1 && a ? a.direction === "sendrecv" ? a.setDirection ? a.setDirection("sendonly") : a.direction = "sendonly" : a.direction === "recvonly" && (a.setDirection ? a.setDirection("inactive") : a.direction = "inactive") : n.offerToReceiveVideo === !0 && !a && this.addTransceiver("video") } return t.apply(this, arguments) } } function to(e) { typeof e != "object" || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } const Ti = Object.freeze(Object.defineProperty({ __proto__: null, shimLocalStreamsAPI: Ja, shimRemoteStreamsAPI: Ha, shimCallbacksAPI: Wa, shimGetUserMedia: Qa, shimConstraints: Ya, shimRTCIceServerUrls: Xa, shimTrackEventTransceiver: Za, shimCreateOfferLegacy: eo, shimAudioContext: to }, Symbol.toStringTag, { value: "Module" })); function lr(e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (n) { if (typeof n == "object" && n.candidate && n.candidate.indexOf("a=") === 0 && (n = JSON.parse(JSON.stringify(n)), n.candidate = n.candidate.substr(2)), n.candidate && n.candidate.length) { const i = new t(n), a = ur.parseCandidate(n.candidate), o = Object.assign(i, a); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(n) }, e.RTCIceCandidate.prototype = t.prototype, gt(e, "icecandidate", r => (r.candidate && Object.defineProperty(r, "candidate", { value: new e.RTCIceCandidate(r.candidate), writable: "false" }), r)) } function Pt(e, t) { if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp } }); const r = function (u) { if (!u || !u.sdp) return !1; const s = ur.splitSections(u.sdp); return s.shift(), s.some(c => { const l = ur.parseMLine(c); return l && l.kind === "application" && l.protocol.indexOf("SCTP") !== -1 }) }, n = function (u) { const s = u.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (s === null || s.length < 2) return -1; const c = parseInt(s[1], 10); return c !== c ? -1 : c }, i = function (u) { let s = 65536; return t.browser === "firefox" && (t.version < 57 ? u === -1 ? s = 16384 : s = 2147483637 : t.version < 60 ? s = t.version === 57 ? 65535 : 65536 : s = 2147483637), s }, a = function (u, s) { let c = 65536; t.browser === "firefox" && t.version === 57 && (c = 65535); const l = ur.matchPrefix(u.sdp, "a=max-message-size:"); return l.length > 0 ? c = parseInt(l[0].substr(19), 10) : t.browser === "firefox" && s !== -1 && (c = 2147483637), c }, o = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, t.browser === "chrome" && t.version >= 76) { const { sdpSemantics: s } = this.getConfiguration(); s === "plan-b" && Object.defineProperty(this, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (r(arguments[0])) { const s = n(arguments[0]), c = i(s), l = a(arguments[0], s); let f; c === 0 && l === 0 ? f = Number.POSITIVE_INFINITY : c === 0 || l === 0 ? f = Math.max(c, l) : f = Math.min(c, l); const p = {}; Object.defineProperty(p, "maxMessageSize", { get() { return f } }), this._sctp = p } return o.apply(this, arguments) } } function Et(e) { if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return; function t(n, i) { const a = n.send; n.send = function () { const u = arguments[0], s = u.length || u.size || u.byteLength; if (n.readyState === "open" && i.sctp && s > i.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + i.sctp.maxMessageSize + " bytes)"); return a.apply(n, arguments) } } const r = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const i = r.apply(this, arguments); return t(i, this), i }, gt(e, "datachannel", n => (t(n.channel, n.target), n)) } function Sn(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(r) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), r && this.addEventListener("connectionstatechange", this._onconnectionstatechange = r) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach(r => { const n = t[r]; t[r] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = i => { const a = i.target; if (a._lastConnectionState !== a.connectionState) { a._lastConnectionState = a.connectionState; const o = new Event("connectionstatechange", i); a.dispatchEvent(o) } return i }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } }) } function Tn(e, t) {
    if (!e.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605) return; const r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (i) {
        if (i && i.sdp && i.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
            const a = i.sdp.split(`
`).filter(o => o.trim() !== "a=extmap-allow-mixed").join(`
`); e.RTCSessionDescription && i instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: i.type, sdp: a }) : i.sdp = a
        } return r.apply(this, arguments)
    }
} function fr(e, t) { if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype)) return; const r = e.RTCPeerConnection.prototype.addIceCandidate; !r || r.length === 0 || (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } const jc = Object.freeze(Object.defineProperty({ __proto__: null, shimRTCIceCandidate: lr, shimMaxMessageSize: Pt, shimSendThrowTypeError: Et, shimConnectionState: Sn, removeExtmapAllowMixed: Tn, shimAddIceCandidateNullOrEmpty: fr }, Symbol.toStringTag, { value: "Module" })); function Bc({ window: e } = {}, t = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }) { const r = Gn, n = xc(e), i = { browserDetails: n, commonShim: jc, extractVersion: kt, disableLog: Ec, disableWarnings: Rc }; switch (n.browser) { case "chrome": if (!gi || !bn || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), i; if (n.version === null) return r("Chrome shim can not determine version, not shimming."), i; r("adapter.js shimming chrome."), i.browserShim = gi, fr(e, n), Pa(e, n), Ea(e), bn(e, n), Ra(e), Aa(e, n), xa(e), Da(e), wa(e), Ia(e, n), lr(e), Sn(e), Pt(e, n), Et(e), Tn(e, n); break; case "firefox": if (!Si || !Cn || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), i; r("adapter.js shimming firefox."), i.browserShim = Si, fr(e, n), Fa(e, n), Cn(e, n), Na(e), Ua(e), Ka(e), La(e), za(e), $a(e), Ga(e), Va(e), qa(e), lr(e), Sn(e), Pt(e, n), Et(e); break; case "edge": if (!Ci || !_n || !t.shimEdge) return r("MS edge shim is not included in this adapter release."), i; r("adapter.js shimming edge."), i.browserShim = Ci, Ma(e), ja(e), _n(e, n), Ba(e), Pt(e, n), Et(e); break; case "safari": if (!Ti || !t.shimSafari) return r("Safari shim is not included in this adapter release."), i; r("adapter.js shimming safari."), i.browserShim = Ti, fr(e, n), Xa(e), eo(e), Wa(e), Ja(e), Ha(e), Za(e), Qa(e), to(e), lr(e), Pt(e, n), Et(e), Tn(e, n); break; default: r("Unsupported browser!"); break }return i } const ki = Bc({ window: typeof window > "u" ? void 0 : window }); function ke(e, t, r, n) { Object.defineProperty(e, t, { get: r, set: n, enumerable: !0, configurable: !0 }) } var $r = ki.default || ki, _t = new (function () {
    function e() { this.isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform), this.supportedBrowsers = ["firefox", "chrome", "safari"], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605 } return e.prototype.isWebRTCSupported = function () { return typeof RTCPeerConnection < "u" }, e.prototype.isBrowserSupported = function () { var t = this.getBrowser(), r = this.getVersion(), n = this.supportedBrowsers.includes(t); return n ? t === "chrome" ? r >= this.minChromeVersion : t === "firefox" ? r >= this.minFirefoxVersion : t === "safari" ? !this.isIOS && r >= this.minSafariVersion : !1 : !1 }, e.prototype.getBrowser = function () { return $r.browserDetails.browser }, e.prototype.getVersion = function () { return $r.browserDetails.version || 0 }, e.prototype.isUnifiedPlanSupported = function () { var t = this.getBrowser(), r = $r.browserDetails.version || 0; if (t === "chrome" && r < this.minChromeVersion) return !1; if (t === "firefox" && r >= this.minFirefoxVersion) return !0; if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1; var n, i = !1; try { n = new RTCPeerConnection, n.addTransceiver("audio"), i = !0 } catch { } finally { n && n.close() } return i }, e.prototype.toString = function () {
        return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported())
    }, e
}()), Pi = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: ["turn:eu-0.turn.peerjs.com:3478", "turn:us-0.turn.peerjs.com:3478"], username: "peerjs", credential: "peerjsp" }], sdpSemantics: "unified-plan" }, Fc = function () { function e() { this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = { Chrome: 1, chrome: 1 }, this.chunkedMTU = 16300, this.defaultConfig = Pi, this.browser = _t.getBrowser(), this.browserVersion = _t.getVersion(), this.supports = function () { var t = { browser: _t.isBrowserSupported(), webRTC: _t.isWebRTCSupported(), audioVideo: !1, data: !1, binaryBlob: !1, reliable: !1 }; if (!t.webRTC) return t; var r; try { r = new RTCPeerConnection(Pi), t.audioVideo = !0; var n = void 0; try { n = r.createDataChannel("_PEERJSTEST", { ordered: !0 }), t.data = !0, t.reliable = !!n.ordered; try { n.binaryType = "blob", t.binaryBlob = !_t.isIOS } catch { } } catch { } finally { n && n.close() } } catch { } finally { r && r.close() } return t }(), this.pack = hi.pack, this.unpack = hi.unpack, this._dataCount = 1 } return e.prototype.noop = function () { }, e.prototype.validateId = function (t) { return !t || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(t) }, e.prototype.chunk = function (t) { for (var r = [], n = t.size, i = Math.ceil(n / z.chunkedMTU), a = 0, o = 0; o < n;) { var u = Math.min(n, o + z.chunkedMTU), s = t.slice(o, u), c = { __peerData: this._dataCount, n: a, data: s, total: i }; r.push(c), o = u, a++ } return this._dataCount++, r }, e.prototype.blobToArrayBuffer = function (t, r) { var n = new FileReader; return n.onload = function (i) { i.target && r(i.target.result) }, n.readAsArrayBuffer(t), n }, e.prototype.binaryStringToArrayBuffer = function (t) { for (var r = new Uint8Array(t.length), n = 0; n < t.length; n++)r[n] = t.charCodeAt(n) & 255; return r.buffer }, e.prototype.randomToken = function () { return Math.random().toString(36).slice(2) }, e.prototype.isSecure = function () { return location.protocol === "https:" }, e }(), z = new Fc, ro = {}; ke(ro, "Peer", () => Bi, e => Bi = e); var qt = {}, Nc = Object.prototype.hasOwnProperty, le = "~"; function Nt() { } Object.create && (Nt.prototype = Object.create(null), new Nt().__proto__ || (le = !1)); function Kc(e, t, r) { this.fn = e, this.context = t, this.once = r || !1 } function no(e, t, r, n, i) { if (typeof r != "function") throw new TypeError("The listener must be a function"); var a = new Kc(r, n || e, i), o = le ? le + t : t; return e._events[o] ? e._events[o].fn ? e._events[o] = [e._events[o], a] : e._events[o].push(a) : (e._events[o] = a, e._eventsCount++), e } function pr(e, t) { --e._eventsCount === 0 ? e._events = new Nt : delete e._events[t] } function oe() { this._events = new Nt, this._eventsCount = 0 } oe.prototype.eventNames = function () { var t = [], r, n; if (this._eventsCount === 0) return t; for (n in r = this._events) Nc.call(r, n) && t.push(le ? n.slice(1) : n); return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(r)) : t }; oe.prototype.listeners = function (t) { var r = le ? le + t : t, n = this._events[r]; if (!n) return []; if (n.fn) return [n.fn]; for (var i = 0, a = n.length, o = new Array(a); i < a; i++)o[i] = n[i].fn; return o }; oe.prototype.listenerCount = function (t) { var r = le ? le + t : t, n = this._events[r]; return n ? n.fn ? 1 : n.length : 0 }; oe.prototype.emit = function (t, r, n, i, a, o) { var u = le ? le + t : t; if (!this._events[u]) return !1; var s = this._events[u], c = arguments.length, l, f; if (s.fn) { switch (s.once && this.removeListener(t, s.fn, void 0, !0), c) { case 1: return s.fn.call(s.context), !0; case 2: return s.fn.call(s.context, r), !0; case 3: return s.fn.call(s.context, r, n), !0; case 4: return s.fn.call(s.context, r, n, i), !0; case 5: return s.fn.call(s.context, r, n, i, a), !0; case 6: return s.fn.call(s.context, r, n, i, a, o), !0 }for (f = 1, l = new Array(c - 1); f < c; f++)l[f - 1] = arguments[f]; s.fn.apply(s.context, l) } else { var p = s.length, m; for (f = 0; f < p; f++)switch (s[f].once && this.removeListener(t, s[f].fn, void 0, !0), c) { case 1: s[f].fn.call(s[f].context); break; case 2: s[f].fn.call(s[f].context, r); break; case 3: s[f].fn.call(s[f].context, r, n); break; case 4: s[f].fn.call(s[f].context, r, n, i); break; default: if (!l) for (m = 1, l = new Array(c - 1); m < c; m++)l[m - 1] = arguments[m]; s[f].fn.apply(s[f].context, l) } } return !0 }; oe.prototype.on = function (t, r, n) { return no(this, t, r, n, !1) }; oe.prototype.once = function (t, r, n) { return no(this, t, r, n, !0) }; oe.prototype.removeListener = function (t, r, n, i) { var a = le ? le + t : t; if (!this._events[a]) return this; if (!r) return pr(this, a), this; var o = this._events[a]; if (o.fn) o.fn === r && (!i || o.once) && (!n || o.context === n) && pr(this, a); else { for (var u = 0, s = [], c = o.length; u < c; u++)(o[u].fn !== r || i && !o[u].once || n && o[u].context !== n) && s.push(o[u]); s.length ? this._events[a] = s.length === 1 ? s[0] : s : pr(this, a) } return this }; oe.prototype.removeAllListeners = function (t) { var r; return t ? (r = le ? le + t : t, this._events[r] && pr(this, r)) : (this._events = new Nt, this._eventsCount = 0), this }; oe.prototype.off = oe.prototype.removeListener; oe.prototype.addListener = oe.prototype.on; oe.prefixed = le; oe.EventEmitter = oe; qt = oe; var D = {}; ke(D, "LogLevel", () => pe, e => pe = e); ke(D, "default", () => Ei, e => Ei = e); var qe = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Je = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, Lc = "PeerJS: ", pe; (function (e) { e[e.Disabled = 0] = "Disabled", e[e.Errors = 1] = "Errors", e[e.Warnings = 2] = "Warnings", e[e.All = 3] = "All" })(pe || (pe = {})); var Uc = function () { function e() { this._logLevel = pe.Disabled } return Object.defineProperty(e.prototype, "logLevel", { get: function () { return this._logLevel }, set: function (t) { this._logLevel = t }, enumerable: !1, configurable: !0 }), e.prototype.log = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= pe.All && this._print.apply(this, Je([pe.All], qe(t), !1)) }, e.prototype.warn = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= pe.Warnings && this._print.apply(this, Je([pe.Warnings], qe(t), !1)) }, e.prototype.error = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= pe.Errors && this._print.apply(this, Je([pe.Errors], qe(t), !1)) }, e.prototype.setLogFunction = function (t) { this._print = t }, e.prototype._print = function (t) { for (var r = [], n = 1; n < arguments.length; n++)r[n - 1] = arguments[n]; var i = Je([Lc], qe(r), !1); for (var a in i) i[a] instanceof Error && (i[a] = "(" + i[a].name + ") " + i[a].message); t >= pe.All ? console.log.apply(console, Je([], qe(i), !1)) : t >= pe.Warnings ? console.warn.apply(console, Je(["WARNING"], qe(i), !1)) : t >= pe.Errors && console.error.apply(console, Je(["ERROR"], qe(i), !1)) }, e }(), Ei = new Uc, io = {}; ke(io, "Socket", () => Ri, e => Ri = e); var _e; (function (e) { e.Data = "data", e.Media = "media" })(_e || (_e = {})); var J; (function (e) { e.BrowserIncompatible = "browser-incompatible", e.Disconnected = "disconnected", e.InvalidID = "invalid-id", e.InvalidKey = "invalid-key", e.Network = "network", e.PeerUnavailable = "peer-unavailable", e.SslUnavailable = "ssl-unavailable", e.ServerError = "server-error", e.SocketError = "socket-error", e.SocketClosed = "socket-closed", e.UnavailableID = "unavailable-id", e.WebRTC = "webrtc" })(J || (J = {})); var Ee; (function (e) { e.Binary = "binary", e.BinaryUTF8 = "binary-utf8", e.JSON = "json" })(Ee || (Ee = {})); var we; (function (e) { e.Message = "message", e.Disconnected = "disconnected", e.Error = "error", e.Close = "close" })(we || (we = {})); var Z; (function (e) { e.Heartbeat = "HEARTBEAT", e.Candidate = "CANDIDATE", e.Offer = "OFFER", e.Answer = "ANSWER", e.Open = "OPEN", e.Error = "ERROR", e.IdTaken = "ID-TAKEN", e.InvalidKey = "INVALID-KEY", e.Leave = "LEAVE", e.Expire = "EXPIRE" })(Z || (Z = {})); var qn = {}; qn = JSON.parse('{"name":"peerjs","version":"1.4.6","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xFCckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"type":"module","sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.cjs","browser-unminified":"dist/peerjs.cjs","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"includeNodeModules":true,"context":"browser","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"includeNodeModules":true,"context":"browser","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build && cp dist/peerjs.cjs dist/peerjs.js && cp dist/peerjs.min.cjs dist/peerjs.min.js","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}'); var zc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), $c = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Gc = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, Vc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Ri = function (e) { zc(t, e); function t(r, n, i, a, o, u) { u === void 0 && (u = 5e3); var s = e.call(this) || this; s.pingInterval = u, s._disconnected = !0, s._messagesQueue = []; var c = r ? "wss://" : "ws://"; return s._baseUrl = c + n + ":" + i + a + "peerjs?key=" + o, s } return t.prototype.start = function (r, n) { var i = this; this._id = r; var a = "".concat(this._baseUrl, "&id=").concat(r, "&token=").concat(n); !!this._socket || !this._disconnected || (this._socket = new WebSocket(a + "&version=" + qn.version), this._disconnected = !1, this._socket.onmessage = function (o) { var u; try { u = JSON.parse(o.data), D.default.log("Server message received:", u) } catch { D.default.log("Invalid server message", o.data); return } i.emit(we.Message, u) }, this._socket.onclose = function (o) { i._disconnected || (D.default.log("Socket closed.", o), i._cleanup(), i._disconnected = !0, i.emit(we.Disconnected)) }, this._socket.onopen = function () { i._disconnected || (i._sendQueuedMessages(), D.default.log("Socket open"), i._scheduleHeartbeat()) }) }, t.prototype._scheduleHeartbeat = function () { var r = this; this._wsPingTimer = setTimeout(function () { r._sendHeartbeat() }, this.pingInterval) }, t.prototype._sendHeartbeat = function () { if (!this._wsOpen()) { D.default.log("Cannot send heartbeat, because socket closed"); return } var r = JSON.stringify({ type: Z.Heartbeat }); this._socket.send(r), this._scheduleHeartbeat() }, t.prototype._wsOpen = function () { return !!this._socket && this._socket.readyState === 1 }, t.prototype._sendQueuedMessages = function () { var r, n, i = Gc([], $c(this._messagesQueue), !1); this._messagesQueue = []; try { for (var a = Vc(i), o = a.next(); !o.done; o = a.next()) { var u = o.value; this.send(u) } } catch (s) { r = { error: s } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } }, t.prototype.send = function (r) { if (!this._disconnected) { if (!this._id) { this._messagesQueue.push(r); return } if (!r.type) { this.emit(we.Error, "Invalid message"); return } if (!!this._wsOpen()) { var n = JSON.stringify(r); this._socket.send(n) } } }, t.prototype.close = function () { this._disconnected || (this._cleanup(), this._disconnected = !0) }, t.prototype._cleanup = function () { this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer) }, t }(qt.EventEmitter), kn = {}; ke(kn, "MediaConnection", () => wi, e => wi = e); var Jn = {}; ke(Jn, "Negotiator", () => xi, e => xi = e); var Tr = function () { return Tr = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, Tr.apply(this, arguments) }, er = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(l) { try { c(n.next(l)) } catch (f) { o(f) } } function s(l) { try { c(n.throw(l)) } catch (f) { o(f) } } function c(l) { l.done ? a(l.value) : i(l.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, tr = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (l) { return s([c, l]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (l) { c = [6, l], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, xi = function () { function e(t) { this.connection = t } return e.prototype.startConnection = function (t) { var r = this._startPeerConnection(); if (this.connection.peerConnection = r, this.connection.type === _e.Media && t._stream && this._addTracksToConnection(t._stream, r), t.originator) { if (this.connection.type === _e.Data) { var n = this.connection, i = { ordered: !!t.reliable }, a = r.createDataChannel(n.label, i); n.initialize(a) } this._makeOffer() } else this.handleSDP("OFFER", t.sdp) }, e.prototype._startPeerConnection = function () { D.default.log("Creating RTCPeerConnection."); var t = new RTCPeerConnection(this.connection.provider.options.config); return this._setupListeners(t), t }, e.prototype._setupListeners = function (t) { var r = this, n = this.connection.peer, i = this.connection.connectionId, a = this.connection.type, o = this.connection.provider; D.default.log("Listening for ICE candidates."), t.onicecandidate = function (u) { !u.candidate || !u.candidate.candidate || (D.default.log("Received ICE candidates for ".concat(n, ":"), u.candidate), o.socket.send({ type: Z.Candidate, payload: { candidate: u.candidate, type: a, connectionId: i }, dst: n })) }, t.oniceconnectionstatechange = function () { switch (t.iceConnectionState) { case "failed": D.default.log("iceConnectionState is failed, closing connections to " + n), r.connection.emit("error", new Error("Negotiation of connection to " + n + " failed.")), r.connection.close(); break; case "closed": D.default.log("iceConnectionState is closed, closing connections to " + n), r.connection.emit("error", new Error("Connection to " + n + " closed.")), r.connection.close(); break; case "disconnected": D.default.log("iceConnectionState changed to disconnected on the connection with " + n); break; case "completed": t.onicecandidate = z.noop; break }r.connection.emit("iceStateChanged", t.iceConnectionState) }, D.default.log("Listening for data channel"), t.ondatachannel = function (u) { D.default.log("Received data channel"); var s = u.channel, c = o.getConnection(n, i); c.initialize(s) }, D.default.log("Listening for remote stream"), t.ontrack = function (u) { D.default.log("Received remote stream"); var s = u.streams[0], c = o.getConnection(n, i); if (c.type === _e.Media) { var l = c; r._addStreamToMediaConnection(s, l) } } }, e.prototype.cleanup = function () { D.default.log("Cleaning up PeerConnection to " + this.connection.peer); var t = this.connection.peerConnection; if (!!t) { this.connection.peerConnection = null, t.onicecandidate = t.oniceconnectionstatechange = t.ondatachannel = t.ontrack = function () { }; var r = t.signalingState !== "closed", n = !1; if (this.connection.type === _e.Data) { var i = this.connection, a = i.dataChannel; a && (n = !!a.readyState && a.readyState !== "closed") } (r || n) && t.close() } }, e.prototype._makeOffer = function () { return er(this, void 0, Promise, function () { var t, r, n, i, a, o, u; return tr(this, function (s) { switch (s.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 7, , 8]), [4, t.createOffer(this.connection.options.constraints)]; case 2: n = s.sent(), D.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), s.label = 3; case 3: return s.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return s.sent(), D.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), i = { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, metadata: this.connection.metadata, browser: z.browser }, this.connection.type === _e.Data && (a = this.connection, i = Tr(Tr({}, i), { label: a.label, reliable: a.reliable, serialization: a.serialization })), r.socket.send({ type: Z.Offer, payload: i, dst: this.connection.peer }), [3, 6]; case 5: return o = s.sent(), o != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (r.emitError(J.WebRTC, o), D.default.log("Failed to setLocalDescription, ", o)), [3, 6]; case 6: return [3, 8]; case 7: return u = s.sent(), r.emitError(J.WebRTC, u), D.default.log("Failed to createOffer, ", u), [3, 8]; case 8: return [2] } }) }) }, e.prototype._makeAnswer = function () { return er(this, void 0, Promise, function () { var t, r, n, i, a; return tr(this, function (o) { switch (o.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, o.label = 1; case 1: return o.trys.push([1, 7, , 8]), [4, t.createAnswer()]; case 2: n = o.sent(), D.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), o.label = 3; case 3: return o.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return o.sent(), D.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), r.socket.send({ type: Z.Answer, payload: { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, browser: z.browser }, dst: this.connection.peer }), [3, 6]; case 5: return i = o.sent(), r.emitError(J.WebRTC, i), D.default.log("Failed to setLocalDescription, ", i), [3, 6]; case 6: return [3, 8]; case 7: return a = o.sent(), r.emitError(J.WebRTC, a), D.default.log("Failed to create answer, ", a), [3, 8]; case 8: return [2] } }) }) }, e.prototype.handleSDP = function (t, r) { return er(this, void 0, Promise, function () { var n, i, a, o; return tr(this, function (u) { switch (u.label) { case 0: r = new RTCSessionDescription(r), n = this.connection.peerConnection, i = this.connection.provider, D.default.log("Setting remote description", r), a = this, u.label = 1; case 1: return u.trys.push([1, 5, , 6]), [4, n.setRemoteDescription(r)]; case 2: return u.sent(), D.default.log("Set remoteDescription:".concat(t, " for:").concat(this.connection.peer)), t !== "OFFER" ? [3, 4] : [4, a._makeAnswer()]; case 3: u.sent(), u.label = 4; case 4: return [3, 6]; case 5: return o = u.sent(), i.emitError(J.WebRTC, o), D.default.log("Failed to setRemoteDescription, ", o), [3, 6]; case 6: return [2] } }) }) }, e.prototype.handleCandidate = function (t) { return er(this, void 0, Promise, function () { var r, n, i, a, o, u; return tr(this, function (s) { switch (s.label) { case 0: D.default.log("handleCandidate:", t), r = t.candidate, n = t.sdpMLineIndex, i = t.sdpMid, a = this.connection.peerConnection, o = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 3, , 4]), [4, a.addIceCandidate(new RTCIceCandidate({ sdpMid: i, sdpMLineIndex: n, candidate: r }))]; case 2: return s.sent(), D.default.log("Added ICE candidate for:".concat(this.connection.peer)), [3, 4]; case 3: return u = s.sent(), o.emitError(J.WebRTC, u), D.default.log("Failed to handleCandidate, ", u), [3, 4]; case 4: return [2] } }) }) }, e.prototype._addTracksToConnection = function (t, r) { if (D.default.log("add tracks from stream ".concat(t.id, " to peer connection")), !r.addTrack) return D.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored."); t.getTracks().forEach(function (n) { r.addTrack(n, t) }) }, e.prototype._addStreamToMediaConnection = function (t, r) { D.default.log("add stream ".concat(t.id, " to media connection ").concat(r.connectionId)), r.addStream(t) }, e }(), Hn = {}; ke(Hn, "BaseConnection", () => Di, e => Di = e); var qc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Di = function (e) { qc(t, e); function t(r, n, i) { var a = e.call(this) || this; return a.peer = r, a.provider = n, a.options = i, a._open = !1, a.metadata = i.metadata, a } return Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), t }(qt.EventEmitter), Jc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), kr = function () { return kr = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, kr.apply(this, arguments) }, Hc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, wi = function (e) { Jc(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a._localStream = a.options._stream, a.connectionId = a.options.connectionId || t.ID_PREFIX + z.randomToken(), a._negotiator = new Jn.Negotiator(a), a._localStream && a._negotiator.startConnection({ _stream: a._localStream, originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return _e.Media }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "localStream", { get: function () { return this._localStream }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "remoteStream", { get: function () { return this._remoteStream }, enumerable: !1, configurable: !0 }), t.prototype.addStream = function (r) { D.default.log("Receiving stream", r), this._remoteStream = r, e.prototype.emit.call(this, "stream", r) }, t.prototype.handleMessage = function (r) { var n = r.type, i = r.payload; switch (r.type) { case Z.Answer: this._negotiator.handleSDP(n, i.sdp), this._open = !0; break; case Z.Candidate: this._negotiator.handleCandidate(i.candidate); break; default: D.default.warn("Unrecognized message type:".concat(n, " from peer:").concat(this.peer)); break } }, t.prototype.answer = function (r, n) { var i, a; if (n === void 0 && (n = {}), this._localStream) { D.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?"); return } this._localStream = r, n && n.sdpTransform && (this.options.sdpTransform = n.sdpTransform), this._negotiator.startConnection(kr(kr({}, this.options._payload), { _stream: r })); var o = this.provider._getMessages(this.connectionId); try { for (var u = Hc(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; this.handleMessage(c) } } catch (l) { i = { error: l } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } this._open = !0 }, t.prototype.close = function () { this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.ID_PREFIX = "mc_", t }(Hn.BaseConnection), Pn = {}; ke(Pn, "DataConnection", () => Ai, e => Ai = e); var ao = {}; ke(ao, "EncodingQueue", () => Oi, e => Oi = e); var Wc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Oi = function (e) { Wc(t, e); function t() { var r = e.call(this) || this; return r.fileReader = new FileReader, r._queue = [], r._processing = !1, r.fileReader.onload = function (n) { r._processing = !1, n.target && r.emit("done", n.target.result), r.doNextTask() }, r.fileReader.onerror = function (n) { D.default.error("EncodingQueue error:", n), r._processing = !1, r.destroy(), r.emit("error", n) }, r } return Object.defineProperty(t.prototype, "queue", { get: function () { return this._queue }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "size", { get: function () { return this.queue.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "processing", { get: function () { return this._processing }, enumerable: !1, configurable: !0 }), t.prototype.enque = function (r) { this.queue.push(r), !this.processing && this.doNextTask() }, t.prototype.destroy = function () { this.fileReader.abort(), this._queue = [] }, t.prototype.doNextTask = function () { this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift()))) }, t }(qt.EventEmitter), Qc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Yc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Ai = function (e) { Qc(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a.stringify = JSON.stringify, a.parse = JSON.parse, a._buffer = [], a._bufferSize = 0, a._buffering = !1, a._chunkedData = {}, a._encodingQueue = new ao.EncodingQueue, a.connectionId = a.options.connectionId || t.ID_PREFIX + z.randomToken(), a.label = a.options.label || a.connectionId, a.serialization = a.options.serialization || Ee.Binary, a.reliable = !!a.options.reliable, a._encodingQueue.on("done", function (o) { a._bufferedSend(o) }), a._encodingQueue.on("error", function () { D.default.error("DC#".concat(a.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), a.close() }), a._negotiator = new Jn.Negotiator(a), a._negotiator.startConnection(a.options._payload || { originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return _e.Data }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dataChannel", { get: function () { return this._dc }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "bufferSize", { get: function () { return this._bufferSize }, enumerable: !1, configurable: !0 }), t.prototype.initialize = function (r) { this._dc = r, this._configureDataChannel() }, t.prototype._configureDataChannel = function () { var r = this; (!z.supports.binaryBlob || z.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function () { D.default.log("DC#".concat(r.connectionId, " dc connection success")), r._open = !0, r.emit("open") }, this.dataChannel.onmessage = function (n) { D.default.log("DC#".concat(r.connectionId, " dc onmessage:"), n.data), r._handleDataMessage(n) }, this.dataChannel.onclose = function () { D.default.log("DC#".concat(r.connectionId, " dc closed for:"), r.peer), r.close() } }, t.prototype._handleDataMessage = function (r) { var n = this, i = r.data, a = i.constructor, o = this.serialization === Ee.Binary || this.serialization === Ee.BinaryUTF8, u = i; if (o) { if (a === Blob) { z.blobToArrayBuffer(i, function (c) { var l = z.unpack(c); n.emit("data", l) }); return } else if (a === ArrayBuffer) u = z.unpack(i); else if (a === String) { var s = z.binaryStringToArrayBuffer(i); u = z.unpack(s) } } else this.serialization === Ee.JSON && (u = this.parse(i)); if (u.__peerData) { this._handleChunk(u); return } e.prototype.emit.call(this, "data", u) }, t.prototype._handleChunk = function (r) { var n = r.__peerData, i = this._chunkedData[n] || { data: [], count: 0, total: r.total }; if (i.data[r.n] = r.data, i.count++, this._chunkedData[n] = i, i.total === i.count) { delete this._chunkedData[n]; var a = new Blob(i.data); this._handleDataMessage({ data: a }) } }, t.prototype.close = function () { this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.prototype.send = function (r, n) { if (!this.open) { e.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages.")); return } if (this.serialization === Ee.JSON) this._bufferedSend(this.stringify(r)); else if (this.serialization === Ee.Binary || this.serialization === Ee.BinaryUTF8) { var i = z.pack(r); if (!n && i.size > z.chunkedMTU) { this._sendChunks(i); return } z.supports.binaryBlob ? this._bufferedSend(i) : this._encodingQueue.enque(i) } else this._bufferedSend(r) }, t.prototype._bufferedSend = function (r) { (this._buffering || !this._trySend(r)) && (this._buffer.push(r), this._bufferSize = this._buffer.length) }, t.prototype._trySend = function (r) { var n = this; if (!this.open) return !1; if (this.dataChannel.bufferedAmount > t.MAX_BUFFERED_AMOUNT) return this._buffering = !0, setTimeout(function () { n._buffering = !1, n._tryBuffer() }, 50), !1; try { this.dataChannel.send(r) } catch (i) { return D.default.error("DC#:".concat(this.connectionId, " Error when sending:"), i), this._buffering = !0, this.close(), !1 } return !0 }, t.prototype._tryBuffer = function () { if (!!this.open && this._buffer.length !== 0) { var r = this._buffer[0]; this._trySend(r) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer()) } }, t.prototype._sendChunks = function (r) { var n, i, a = z.chunk(r); D.default.log("DC#".concat(this.connectionId, " Try to send ").concat(a.length, " chunks...")); try { for (var o = Yc(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; this.send(s, !0) } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.handleMessage = function (r) { var n = r.payload; switch (r.type) { case Z.Answer: this._negotiator.handleSDP(r.type, n.sdp); break; case Z.Candidate: this._negotiator.handleCandidate(n.candidate); break; default: D.default.warn("Unrecognized message type:", r.type, "from peer:", this.peer); break } }, t.ID_PREFIX = "dc_", t.MAX_BUFFERED_AMOUNT = 8388608, t }(Hn.BaseConnection), oo = {}; ke(oo, "API", () => ji, e => ji = e); var Ii = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(l) { try { c(n.next(l)) } catch (f) { o(f) } } function s(l) { try { c(n.throw(l)) } catch (f) { o(f) } } function c(l) { l.done ? a(l.value) : i(l.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, Mi = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (l) { return s([c, l]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (l) { c = [6, l], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, ji = function () { function e(t) { this._options = t } return e.prototype._buildRequest = function (t) { var r = this._options.secure ? "https" : "http", n = this._options, i = n.host, a = n.port, o = n.path, u = n.key, s = new URL("".concat(r, "://").concat(i, ":").concat(a).concat(o).concat(u, "/").concat(t)); return s.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), s.searchParams.set("version", qn.version), fetch(s.href, { referrerPolicy: this._options.referrerPolicy }) }, e.prototype.retrieveId = function () { return Ii(this, void 0, Promise, function () { var t, r, n; return Mi(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("id")]; case 1: if (t = i.sent(), t.status !== 200) throw new Error("Error. Status:".concat(t.status)); return [2, t.text()]; case 2: throw r = i.sent(), D.default.error("Error retrieving ID", r), n = "", this._options.path === "/" && this._options.host !== z.CLOUD_HOST && (n = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + n); case 3: return [2] } }) }) }, e.prototype.listAllPeers = function () { return Ii(this, void 0, Promise, function () { var t, r, n; return Mi(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("peers")]; case 1: if (t = i.sent(), t.status !== 200) throw t.status === 401 ? (r = "", this._options.host === z.CLOUD_HOST ? r = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : r = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + r)) : new Error("Error. Status:".concat(t.status)); return [2, t.json()]; case 2: throw n = i.sent(), D.default.error("Error retrieving list peers", n), new Error("Could not get list peers from the server." + n); case 3: return [2] } }) }) }, e }(), Xc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), wt = function () { return wt = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, wt.apply(this, arguments) }, Ct = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, Zc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Bi = function (e) { Xc(t, e); function t(r, n) { var i = e.call(this) || this; i._id = null, i._lastServerId = null, i._destroyed = !1, i._disconnected = !1, i._open = !1, i._connections = new Map, i._lostMessages = new Map; var a; return r && r.constructor == Object ? n = r : r && (a = r.toString()), n = wt({ debug: 0, host: z.CLOUD_HOST, port: z.CLOUD_PORT, path: "/", key: t.DEFAULT_KEY, token: z.randomToken(), config: z.defaultConfig, referrerPolicy: "strict-origin-when-cross-origin" }, n), i._options = n, i._options.host === "/" && (i._options.host = window.location.hostname), i._options.path && (i._options.path[0] !== "/" && (i._options.path = "/" + i._options.path), i._options.path[i._options.path.length - 1] !== "/" && (i._options.path += "/")), i._options.secure === void 0 && i._options.host !== z.CLOUD_HOST ? i._options.secure = z.isSecure() : i._options.host == z.CLOUD_HOST && (i._options.secure = !0), i._options.logFunction && D.default.setLogFunction(i._options.logFunction), D.default.logLevel = i._options.debug || 0, i._api = new oo.API(n), i._socket = i._createServerConnection(), !z.supports.audioVideo && !z.supports.data ? (i._delayedAbort(J.BrowserIncompatible, "The current browser does not support WebRTC"), i) : !!a && !z.validateId(a) ? (i._delayedAbort(J.InvalidID, 'ID "'.concat(a, '" is invalid')), i) : (a ? i._initialize(a) : i._api.retrieveId().then(function (o) { return i._initialize(o) }).catch(function (o) { return i._abort(J.ServerError, o) }), i) } return Object.defineProperty(t.prototype, "id", { get: function () { return this._id }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "options", { get: function () { return this._options }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "socket", { get: function () { return this._socket }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "connections", { get: function () { var r, n, i = Object.create(null); try { for (var a = Ct(this._connections), o = a.next(); !o.done; o = a.next()) { var u = Zc(o.value, 2), s = u[0], c = u[1]; i[s] = c } } catch (l) { r = { error: l } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } return i }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "destroyed", { get: function () { return this._destroyed }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "disconnected", { get: function () { return this._disconnected }, enumerable: !1, configurable: !0 }), t.prototype._createServerConnection = function () { var r = this, n = new io.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval); return n.on(we.Message, function (i) { r._handleMessage(i) }), n.on(we.Error, function (i) { r._abort(J.SocketError, i) }), n.on(we.Disconnected, function () { r.disconnected || (r.emitError(J.Network, "Lost connection to server."), r.disconnect()) }), n.on(we.Close, function () { r.disconnected || r._abort(J.SocketClosed, "Underlying socket is already closed.") }), n }, t.prototype._initialize = function (r) { this._id = r, this.socket.start(r, this._options.token) }, t.prototype._handleMessage = function (r) { var n, i, a = r.type, o = r.payload, u = r.src; switch (a) { case Z.Open: this._lastServerId = this.id, this._open = !0, this.emit("open", this.id); break; case Z.Error: this._abort(J.ServerError, o.msg); break; case Z.IdTaken: this._abort(J.UnavailableID, 'ID "'.concat(this.id, '" is taken')); break; case Z.InvalidKey: this._abort(J.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid')); break; case Z.Leave: D.default.log("Received leave message from ".concat(u)), this._cleanupPeer(u), this._connections.delete(u); break; case Z.Expire: this.emitError(J.PeerUnavailable, "Could not connect to peer ".concat(u)); break; case Z.Offer: var d = o.connectionId, h = this.getConnection(u, d); if (h && (h.close(), D.default.warn("Offer received for existing Connection ID:".concat(d))), o.type === _e.Media) { var s = new kn.MediaConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata }); h = s, this._addConnection(u, h), this.emit("call", s) } else if (o.type === _e.Data) { var c = new Pn.DataConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata, label: o.label, serialization: o.serialization, reliable: o.reliable }); h = c, this._addConnection(u, h), this.emit("connection", c) } else { D.default.warn("Received malformed connection type:".concat(o.type)); return } var l = this._getMessages(d); try { for (var f = Ct(l), p = f.next(); !p.done; p = f.next()) { var m = p.value; h.handleMessage(m) } } catch (b) { n = { error: b } } finally { try { p && !p.done && (i = f.return) && i.call(f) } finally { if (n) throw n.error } } break; default: if (!o) { D.default.warn("You received a malformed message from ".concat(u, " of type ").concat(a)); return } var d = o.connectionId, h = this.getConnection(u, d); h && h.peerConnection ? h.handleMessage(r) : d ? this._storeMessage(d, r) : D.default.warn("You received an unrecognized message:", r); break } }, t.prototype._storeMessage = function (r, n) { this._lostMessages.has(r) || this._lostMessages.set(r, []), this._lostMessages.get(r).push(n) }, t.prototype._getMessages = function (r) { var n = this._lostMessages.get(r); return n ? (this._lostMessages.delete(r), n) : [] }, t.prototype.connect = function (r, n) { if (n === void 0 && (n = {}), this.disconnected) { D.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } var i = new Pn.DataConnection(r, this, n); return this._addConnection(r, i), i }, t.prototype.call = function (r, n, i) { if (i === void 0 && (i = {}), this.disconnected) { D.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } if (!n) { D.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`."); return } var a = new kn.MediaConnection(r, this, wt(wt({}, i), { _stream: n })); return this._addConnection(r, a), a }, t.prototype._addConnection = function (r, n) { D.default.log("add connection ".concat(n.type, ":").concat(n.connectionId, " to peerId:").concat(r)), this._connections.has(r) || this._connections.set(r, []), this._connections.get(r).push(n) }, t.prototype._removeConnection = function (r) { var n = this._connections.get(r.peer); if (n) { var i = n.indexOf(r); i !== -1 && n.splice(i, 1) } this._lostMessages.delete(r.connectionId) }, t.prototype.getConnection = function (r, n) { var i, a, o = this._connections.get(r); if (!o) return null; try { for (var u = Ct(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; if (c.connectionId === n) return c } } catch (l) { i = { error: l } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } return null }, t.prototype._delayedAbort = function (r, n) { var i = this; setTimeout(function () { i._abort(r, n) }, 0) }, t.prototype._abort = function (r, n) { D.default.error("Aborting!"), this.emitError(r, n), this._lastServerId ? this.disconnect() : this.destroy() }, t.prototype.emitError = function (r, n) { D.default.error("Error:", n); var i; typeof n == "string" ? i = new Error(n) : i = n, i.type = r, this.emit("error", i) }, t.prototype.destroy = function () { this.destroyed || (D.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close")) }, t.prototype._cleanup = function () { var r, n; try { for (var i = Ct(this._connections.keys()), a = i.next(); !a.done; a = i.next()) { var o = a.value; this._cleanupPeer(o), this._connections.delete(o) } } catch (u) { r = { error: u } } finally { try { a && !a.done && (n = i.return) && n.call(i) } finally { if (r) throw r.error } } this.socket.removeAllListeners() }, t.prototype._cleanupPeer = function (r) { var n, i, a = this._connections.get(r); if (!!a) try { for (var o = Ct(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; s.close() } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.disconnect = function () { if (!this.disconnected) { var r = this.id; D.default.log("Disconnect peer with ID:".concat(r)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = r, this._id = null, this.emit("disconnected", r) } }, t.prototype.reconnect = function () { if (this.disconnected && !this.destroyed) D.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId); else { if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed."); if (!this.disconnected && !this.open) D.default.error("In a hurry? We're still trying to make the initial connection!"); else throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!")) } }, t.prototype.listAllPeers = function (r) { var n = this; r === void 0 && (r = function (i) { }), this._api.listAllPeers().then(function (i) { return r(i) }).catch(function (i) { return n._abort(J.ServerError, i) }) }, t.DEFAULT_KEY = "peerjs", t }(qt.EventEmitter), eu = ro.Peer; let de, L, w, rr, ut = {}, lt = {}, dr = {}, ft = {}, ze = {}; const tu = [S.positionChanged], so = "http://localhost:5000/"; OctoPrint.options.baseurl = so; $s().then(async () => { let e = await O.printer.toArray(); e.length > 0 && (w = e[0]); let t = await O.nanofactoryPeers.toArray(); t.length > 0 ? rr = t[0] : (rr = new ga, rr.add()), L = await O.networking.get("1"), L || (L = new ya("1"), await L.add()); const r = new URLSearchParams(window.location.search); L.peerID || (L.peerID = r.get("peerID"), L.save({ peerID: L.peerID }), w || (w = new ba(L.peerID), w.add())), L.apiKey || (L.apiKey = r.get("apiKey"), L.save({ apiKey: L.apiKey })), L.masterPeerID = r.get("masterPeerID"), L.save({ masterPeerID: L.masterPeerID }), rr.addToList(dt.WHITELISTED, L.masterPeerID), L.peerID.length > 0 && ru() }); async function ru() { OctoPrint.options.apikey = L.apiKey, de = new eu(L.peerID), nu(), await Ws(), w = (await O.printer.toArray())[0], await Qs(), await Ys(), await OctoPrint.socket.connect(), OctoPrint.socket.onMessage("*", e => bc(e)) } function nu() { de.on("open", function (e) { console.log("Connected to peer server with id:" + e) }), de.on("connection", function (e) { console.log("Connected with peer:" + e.peer), e.on("data", function (t) { console.log("Received Label: " + e.label), yc(t, e.peer, e.label, e.metadata), tu.includes(e.label) || e.close() }) }), de.on("disconnected", function () { console.log("Disconnected from signaling server, reconnecting..."), de.reconnect() }), de.on("close", function () { console.log("Peer destroyed, cannot reconnect") }), de.on("error", function (e) { console.error(e) }) }
