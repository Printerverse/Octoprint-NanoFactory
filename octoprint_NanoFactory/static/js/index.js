var Wa = Object.defineProperty; var Ya = (e, t, r) => t in e ? Wa(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; var P = (e, t, r) => (Ya(e, typeof t != "symbol" ? t + "" : t, r), r); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o) }).observe(document, { childList: !0, subtree: !0 }); function r(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerpolicy && (a.referrerPolicy = i.referrerpolicy), i.crossorigin === "use-credentials" ? a.credentials = "include" : i.crossorigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function n(i) { if (i.ep) return; i.ep = !0; const a = r(i); fetch(i.href, a) } })(); var w = (e => (e.syncAllRequest = "1", e.syncAllResponse = "2", e.profileChanged = "3", e.positionChanged = "57", e.positionChangedResponse = "4", e.positionChangedRequest = "53", e.positionChangedStop = "54", e.cameraStreamRequest = "5", e.cameraStreamResponse = "34", e.cameraStreamStop = "44", e.temperatureStreamRequest = "6", e.temperatureStreamResponse = "35", e.temperatureStreamStop = "43", e.bedLevelingRequest = "7", e.bedLevelingResponse = "8", e.terminalRequest = "9", e.terminalResponse = "10", e.terminalStop = "42", e.filamentModified = "58", e.filamentAssigned = "11", e.filamentRemoved = "12", e.filamentModifiedResponse = "40", e.filamentModifiedRequest = "52", e.filamentModifiedStop = "55", e.jobCreated = "13", e.jobFile = "41", e.jobDone = "14", e.jobCancelled = "15", e.jobFailed = "16", e.jobDeleted = "17", e.jobPause = "25", e.jobResume = "26", e.jobPrinting = "37", e.jobFilamentModified = "30", e.currentJobUpdatesResponse = "49", e.currentJobUpdatesRequest = "51", e.currentJobUpdatesStop = "56", e.jobRankChange = "18", e.actionCreated = "19", e.actionModified = "20", e.actionExecuted = "21", e.actionDeleted = "22", e.executeCustomGcode = "23", e.emergencyStop = "24", e.connectPrinter = "27", e.disconnectPrinter = "28", e.connectionOptionsChanged = "38", e.printerStateChanged = "39", e.refreshConnectionOptions = "45", e.filamentExtrude = "46", e.targetTool = "47", e.targetBed = "48", e.handshakeRequest = "50", e.handshakeResponse = "31", e.queuePaused = "29", e.home = "32", e))(w || {}); let Nt; function dn(e, t, r) {
    const n = { label: r, metadata: e, serialization: "json", reliable: !0 }; Nt = ve.connect(e, n), Nt.on("open", function () { Nt.send(JSON.stringify(t)), console.log("Sent:", t) }), Nt.on("error", function (i) {
        console.error("Could not send data: ", t, `
 Error: `, i)
    })
} function qt(e, t) { br.available.forEach(r => { dn(r, e, t) }) }/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var B = function () { return B = Object.assign || function (t) { for (var r, n = 1, i = arguments.length; n < i; n++) { r = arguments[n]; for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]) } return t }, B.apply(this, arguments) }; function Mr(e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) } var $ = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, H = Object.keys, ie = Array.isArray; typeof Promise < "u" && !$.Promise && ($.Promise = Promise); function ce(e, t) { return typeof t != "object" || H(t).forEach(function (r) { e[r] = t[r] }), e } var kt = Object.getPrototypeOf, Qa = {}.hasOwnProperty; function me(e, t) { return Qa.call(e, t) } function st(e, t) { typeof t == "function" && (t = t(kt(e))), (typeof Reflect > "u" ? H : Reflect.ownKeys)(t).forEach(function (r) { Ae(e, r, t[r]) }) } var Ti = Object.defineProperty; function Ae(e, t, r, n) { Ti(e, t, ce(r && me(r, "get") && typeof r.get == "function" ? { get: r.get, set: r.set, configurable: !0 } : { value: r, configurable: !0, writable: !0 }, n)) } function ct(e) { return { from: function (t) { return e.prototype = Object.create(t.prototype), Ae(e.prototype, "constructor", e), { extend: st.bind(null, e.prototype) } } } } var Xa = Object.getOwnPropertyDescriptor; function hn(e, t) { var r = Xa(e, t), n; return r || (n = kt(e)) && hn(n, t) } var Za = [].slice; function _r(e, t, r) { return Za.call(e, t, r) } function ki(e, t) { return t(e) } function vt(e) { if (!e) throw new Error("Assertion Failed") } function Pi(e) { $.setImmediate ? setImmediate(e) : setTimeout(e, 0) } function Ri(e, t) { return e.reduce(function (r, n, i) { var a = t(n, i); return a && (r[a[0]] = a[1]), r }, {}) } function eo(e, t, r) { try { e.apply(null, r) } catch (n) { t && t(n) } } function we(e, t) { if (me(e, t)) return e[t]; if (!t) return e; if (typeof t != "string") { for (var r = [], n = 0, i = t.length; n < i; ++n) { var a = we(e, t[n]); r.push(a) } return r } var o = t.indexOf("."); if (o !== -1) { var u = e[t.substr(0, o)]; return u === void 0 ? void 0 : we(u, t.substr(o + 1)) } } function _e(e, t, r) { if (!(!e || t === void 0) && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) { vt(typeof r != "string" && "length" in r); for (var n = 0, i = t.length; n < i; ++n)_e(e, t[n], r[n]) } else { var a = t.indexOf("."); if (a !== -1) { var o = t.substr(0, a), u = t.substr(a + 1); if (u === "") r === void 0 ? ie(e) && !isNaN(parseInt(o)) ? e.splice(o, 1) : delete e[o] : e[o] = r; else { var s = e[o]; (!s || !me(e, o)) && (s = e[o] = {}), _e(s, u, r) } } else r === void 0 ? ie(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r } } function to(e, t) { typeof t == "string" ? _e(e, t, void 0) : "length" in t && [].map.call(t, function (r) { _e(e, r, void 0) }) } function Ei(e) { var t = {}; for (var r in e) me(e, r) && (t[r] = e[r]); return t } var ro = [].concat; function xi(e) { return ro.apply([], e) } var Di = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(xi([8, 16, 32, 64].map(function (e) { return ["Int", "Uint", "Float"].map(function (t) { return t + e + "Array" }) }))).filter(function (e) { return $[e] }), no = Di.map(function (e) { return $[e] }); Ri(Di, function (e) { return [e, !0] }); var Ke = null; function At(e) { Ke = typeof WeakMap < "u" && new WeakMap; var t = jr(e); return Ke = null, t } function jr(e) { if (!e || typeof e != "object") return e; var t = Ke && Ke.get(e); if (t) return t; if (ie(e)) { t = [], Ke && Ke.set(e, t); for (var r = 0, n = e.length; r < n; ++r)t.push(jr(e[r])) } else if (no.indexOf(e.constructor) >= 0) t = e; else { var i = kt(e); t = i === Object.prototype ? {} : Object.create(i), Ke && Ke.set(e, t); for (var a in e) me(e, a) && (t[a] = jr(e[a])) } return t } var io = {}.toString; function Br(e) { return io.call(e).slice(8, -1) } var Fr = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ao = typeof Fr == "symbol" ? function (e) { var t; return e != null && (t = e[Fr]) && t.apply(e) } : function () { return null }, tt = {}; function Ee(e) { var t, r, n, i; if (arguments.length === 1) { if (ie(e)) return e.slice(); if (this === tt && typeof e == "string") return [e]; if (i = ao(e)) { for (r = []; n = i.next(), !n.done;)r.push(n.value); return r } if (e == null) return [e]; if (t = e.length, typeof t == "number") { for (r = new Array(t); t--;)r[t] = e[t]; return r } return [e] } for (t = arguments.length, r = new Array(t); t--;)r[t] = arguments[t]; return r } var vn = typeof Symbol < "u" ? function (e) { return e[Symbol.toStringTag] === "AsyncFunction" } : function () { return !1 }, Se = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href); function wi(e, t) { Se = e, Oi = t } var Oi = function () { return !0 }, oo = !new Error("").stack; function Xe() { if (oo) try { throw Xe.arguments, new Error } catch (e) { return e } return new Error } function Kr(e, t) {
    var r = e.stack; return r ? (t = t || 0, r.indexOf(e.name) === 0 && (t += (e.name + e.message).split(`
`).length), r.split(`
`).slice(t).filter(Oi).map(function (n) {
        return `
`+ n
    }).join("")) : ""
} var so = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"], Ai = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], mn = so.concat(Ai), co = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" }; function ut(e, t) { this._e = Xe(), this.name = e, this.message = t } ct(ut).from(Error).extend({ stack: { get: function () { return this._stack || (this._stack = this.name + ": " + this.message + Kr(this._e, 2)) } }, toString: function () { return this.name + ": " + this.message } }); function Ii(e, t) {
    return e + ". Errors: " + Object.keys(t).map(function (r) { return t[r].toString() }).filter(function (r, n, i) { return i.indexOf(r) === n }).join(`
`)
} function sr(e, t, r, n) { this._e = Xe(), this.failures = t, this.failedKeys = n, this.successCount = r, this.message = Ii(e, t) } ct(sr).from(ut); function _t(e, t) { this._e = Xe(), this.name = "BulkError", this.failures = Object.keys(t).map(function (r) { return t[r] }), this.failuresByPos = t, this.message = Ii(e, t) } ct(_t).from(ut); var yn = mn.reduce(function (e, t) { return e[t] = t + "Error", e }, {}), uo = ut, I = mn.reduce(function (e, t) {
    var r = t + "Error"; function n(i, a) {
        this._e = Xe(), this.name = r, i ? typeof i == "string" ? (this.message = "" + i + (a ? `
 `+ a : ""), this.inner = a || null) : typeof i == "object" && (this.message = i.name + " " + i.message, this.inner = i) : (this.message = co[t] || r, this.inner = null)
    } return ct(n).from(uo), e[t] = n, e
}, {}); I.Syntax = SyntaxError; I.Type = TypeError; I.Range = RangeError; var Kn = Ai.reduce(function (e, t) { return e[t + "Error"] = I[t], e }, {}); function lo(e, t) { if (!e || e instanceof ut || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Kn[e.name]) return e; var r = new Kn[e.name](t || e.message, e); return "stack" in e && Ae(r, "stack", { get: function () { return this.inner.stack } }), r } var Cr = mn.reduce(function (e, t) { return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = I[t]), e }, {}); Cr.ModifyError = sr; Cr.DexieError = ut; Cr.BulkError = _t; function U() { } function It(e) { return e } function fo(e, t) { return e == null || e === It ? t : function (r) { return t(e(r)) } } function Ye(e, t) { return function () { e.apply(this, arguments), t.apply(this, arguments) } } function po(e, t) { return e === U ? t : function () { var r = e.apply(this, arguments); r !== void 0 && (arguments[0] = r); var n = this.onsuccess, i = this.onerror; this.onsuccess = null, this.onerror = null; var a = t.apply(this, arguments); return n && (this.onsuccess = this.onsuccess ? Ye(n, this.onsuccess) : n), i && (this.onerror = this.onerror ? Ye(i, this.onerror) : i), a !== void 0 ? a : r } } function ho(e, t) { return e === U ? t : function () { e.apply(this, arguments); var r = this.onsuccess, n = this.onerror; this.onsuccess = this.onerror = null, t.apply(this, arguments), r && (this.onsuccess = this.onsuccess ? Ye(r, this.onsuccess) : r), n && (this.onerror = this.onerror ? Ye(n, this.onerror) : n) } } function vo(e, t) { return e === U ? t : function (r) { var n = e.apply(this, arguments); ce(r, n); var i = this.onsuccess, a = this.onerror; this.onsuccess = null, this.onerror = null; var o = t.apply(this, arguments); return i && (this.onsuccess = this.onsuccess ? Ye(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? Ye(a, this.onerror) : a), n === void 0 ? o === void 0 ? void 0 : o : ce(n, o) } } function mo(e, t) { return e === U ? t : function () { return t.apply(this, arguments) === !1 ? !1 : e.apply(this, arguments) } } function gn(e, t) { return e === U ? t : function () { var r = e.apply(this, arguments); if (r && typeof r.then == "function") { for (var n = this, i = arguments.length, a = new Array(i); i--;)a[i] = arguments[i]; return r.then(function () { return t.apply(n, a) }) } return t.apply(this, arguments) } } var Pt = {}, yo = 100, go = 20, Mi = 100, bn = typeof Promise > "u" ? [] : function () { var e = Promise.resolve(); if (typeof crypto > "u" || !crypto.subtle) return [e, kt(e), e]; var t = crypto.subtle.digest("SHA-512", new Uint8Array([0])); return [t, kt(t), e] }(), Nr = bn[0], cr = bn[1], Lr = bn[2], ji = cr && cr.then, Wt = Nr && Nr.constructor, _n = !!Lr, Ur = !1, bo = Lr ? function () { Lr.then(Lt) } : $.setImmediate ? setImmediate.bind(null, Lt) : $.MutationObserver ? function () { var e = document.createElement("div"); new MutationObserver(function () { Lt(), e = null }).observe(e, { attributes: !0 }), e.setAttribute("i", "1") } : function () { setTimeout(Lt, 0) }, Rt = function (e, t) { mt.push([e, t]), ur && (bo(), ur = !1) }, zr = !0, ur = !0, qe = [], Yt = [], $r = null, Gr = It, it = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: Un, pgp: !1, env: {}, finalize: function () { this.unhandleds.forEach(function (e) { try { Un(e[0], e[1]) } catch { } }) } }, D = it, mt = [], We = 0, Qt = []; function E(e) { if (typeof this != "object") throw new TypeError("Promises must be constructed via new"); this._listeners = [], this.onuncatched = U, this._lib = !1; var t = this._PSD = D; if (Se && (this._stackHolder = Xe(), this._prev = null, this._numPrev = 0), typeof e != "function") { if (e !== Pt) throw new TypeError("Not a function"); this._state = arguments[1], this._value = arguments[2], this._state === !1 && Vr(this, this._value); return } this._state = null, this._value = null, ++t.ref, Fi(this, e) } var Jr = { get: function () { var e = D, t = lr; function r(n, i) { var a = this, o = !e.global && (e !== D || t !== lr), u = o && !Ie(), s = new E(function (c, l) { Cn(a, new Bi(pr(n, e, o, u), pr(i, e, o, u), c, l, e)) }); return Se && Li(s, this), s } return r.prototype = Pt, r }, set: function (e) { Ae(this, "then", e && e.prototype === Pt ? Jr : { get: function () { return e }, set: Jr.set }) } }; st(E.prototype, {
    then: Jr, _then: function (e, t) { Cn(this, new Bi(null, null, e, t, D)) }, catch: function (e) { if (arguments.length === 1) return this.then(null, e); var t = arguments[0], r = arguments[1]; return typeof t == "function" ? this.then(null, function (n) { return n instanceof t ? r(n) : Xt(n) }) : this.then(null, function (n) { return n && n.name === t ? r(n) : Xt(n) }) }, finally: function (e) { return this.then(function (t) { return e(), t }, function (t) { return e(), Xt(t) }) }, stack: {
        get: function () {
            if (this._stack) return this._stack; try {
                Ur = !0; var e = Ni(this, [], go), t = e.join(`
From previous: `); return this._state !== null && (this._stack = t), t
            } finally { Ur = !1 }
        }
    }, timeout: function (e, t) { var r = this; return e < 1 / 0 ? new E(function (n, i) { var a = setTimeout(function () { return i(new I.Timeout(t)) }, e); r.then(n, i).finally(clearTimeout.bind(null, a)) }) : this }
}); typeof Symbol < "u" && Symbol.toStringTag && Ae(E.prototype, Symbol.toStringTag, "Dexie.Promise"); it.env = Ui(); function Bi(e, t, r, n, i) { this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = r, this.reject = n, this.psd = i } st(E, { all: function () { var e = Ee.apply(null, arguments).map(fr); return new E(function (t, r) { e.length === 0 && t([]); var n = e.length; e.forEach(function (i, a) { return E.resolve(i).then(function (o) { e[a] = o, --n || t(e) }, r) }) }) }, resolve: function (e) { if (e instanceof E) return e; if (e && typeof e.then == "function") return new E(function (r, n) { e.then(r, n) }); var t = new E(Pt, !0, e); return Li(t, $r), t }, reject: Xt, race: function () { var e = Ee.apply(null, arguments).map(fr); return new E(function (t, r) { e.map(function (n) { return E.resolve(n).then(t, r) }) }) }, PSD: { get: function () { return D }, set: function (e) { return D = e } }, totalEchoes: { get: function () { return lr } }, newPSD: Le, usePSD: ft, scheduler: { get: function () { return Rt }, set: function (e) { Rt = e } }, rejectionMapper: { get: function () { return Gr }, set: function (e) { Gr = e } }, follow: function (e, t) { return new E(function (r, n) { return Le(function (i, a) { var o = D; o.unhandleds = [], o.onunhandled = a, o.finalize = Ye(function () { var u = this; Co(function () { u.unhandleds.length === 0 ? i() : a(u.unhandleds[0]) }) }, o.finalize), e() }, t, r, n) }) } }); Wt && (Wt.allSettled && Ae(E, "allSettled", function () { var e = Ee.apply(null, arguments).map(fr); return new E(function (t) { e.length === 0 && t([]); var r = e.length, n = new Array(r); e.forEach(function (i, a) { return E.resolve(i).then(function (o) { return n[a] = { status: "fulfilled", value: o } }, function (o) { return n[a] = { status: "rejected", reason: o } }).then(function () { return --r || t(n) }) }) }) }), Wt.any && typeof AggregateError < "u" && Ae(E, "any", function () { var e = Ee.apply(null, arguments).map(fr); return new E(function (t, r) { e.length === 0 && r(new AggregateError([])); var n = e.length, i = new Array(n); e.forEach(function (a, o) { return E.resolve(a).then(function (u) { return t(u) }, function (u) { i[o] = u, --n || r(new AggregateError(i)) }) }) }) })); function Fi(e, t) { try { t(function (r) { if (e._state === null) { if (r === e) throw new TypeError("A promise cannot be resolved with itself."); var n = e._lib && Mt(); r && typeof r.then == "function" ? Fi(e, function (i, a) { r instanceof E ? r._then(i, a) : r.then(i, a) }) : (e._state = !0, e._value = r, Ki(e)), n && jt() } }, Vr.bind(null, e)) } catch (r) { Vr(e, r) } } function Vr(e, t) { if (Yt.push(t), e._state === null) { var r = e._lib && Mt(); t = Gr(t), e._state = !1, e._value = t, Se && t !== null && typeof t == "object" && !t._promise && eo(function () { var n = hn(t, "stack"); t._promise = e, Ae(t, "stack", { get: function () { return Ur ? n && (n.get ? n.get.apply(t) : n.value) : e.stack } }) }), So(e), Ki(e), r && jt() } } function Ki(e) { var t = e._listeners; e._listeners = []; for (var r = 0, n = t.length; r < n; ++r)Cn(e, t[r]); var i = e._PSD; --i.ref || i.finalize(), We === 0 && (++We, Rt(function () { --We === 0 && Sn() }, [])) } function Cn(e, t) { if (e._state === null) { e._listeners.push(t); return } var r = e._state ? t.onFulfilled : t.onRejected; if (r === null) return (e._state ? t.resolve : t.reject)(e._value); ++t.psd.ref, ++We, Rt(_o, [r, e, t]) } function _o(e, t, r) { try { $r = t; var n, i = t._value; t._state ? n = e(i) : (Yt.length && (Yt = []), n = e(i), Yt.indexOf(i) === -1 && To(t)), r.resolve(n) } catch (a) { r.reject(a) } finally { $r = null, --We === 0 && Sn(), --r.psd.ref || r.psd.finalize() } } function Ni(e, t, r) { if (t.length === r) return t; var n = ""; if (e._state === !1) { var i = e._value, a, o; i != null ? (a = i.name || "Error", o = i.message || i, n = Kr(i, 0)) : (a = i, o = ""), t.push(a + (o ? ": " + o : "") + n) } return Se && (n = Kr(e._stackHolder, 2), n && t.indexOf(n) === -1 && t.push(n), e._prev && Ni(e._prev, t, r)), t } function Li(e, t) { var r = t ? t._numPrev + 1 : 0; r < yo && (e._prev = t, e._numPrev = r) } function Lt() { Mt() && jt() } function Mt() { var e = zr; return zr = !1, ur = !1, e } function jt() { var e, t, r; do for (; mt.length > 0;)for (e = mt, mt = [], r = e.length, t = 0; t < r; ++t) { var n = e[t]; n[0].apply(null, n[1]) } while (mt.length > 0); zr = !0, ur = !0 } function Sn() { var e = qe; qe = [], e.forEach(function (n) { n._PSD.onunhandled.call(null, n._value, n) }); for (var t = Qt.slice(0), r = t.length; r;)t[--r]() } function Co(e) { function t() { e(), Qt.splice(Qt.indexOf(t), 1) } Qt.push(t), ++We, Rt(function () { --We === 0 && Sn() }, []) } function So(e) { qe.some(function (t) { return t._value === e._value }) || qe.push(e) } function To(e) { for (var t = qe.length; t;)if (qe[--t]._value === e._value) { qe.splice(t, 1); return } } function Xt(e) { return new E(Pt, !1, e) } function G(e, t) { var r = D; return function () { var n = Mt(), i = D; try { return Ue(r, !0), e.apply(this, arguments) } catch (a) { t && t(a) } finally { Ue(i, !1), n && jt() } } } var ne = { awaits: 0, echoes: 0, id: 0 }, ko = 0, Zt = [], Pr = 0, lr = 0, Po = 0; function Le(e, t, r, n) { var i = D, a = Object.create(i); a.parent = i, a.ref = 0, a.global = !1, a.id = ++Po; var o = it.env; a.env = _n ? { Promise: E, PromiseProp: { value: E, configurable: !0, writable: !0 }, all: E.all, race: E.race, allSettled: E.allSettled, any: E.any, resolve: E.resolve, reject: E.reject, nthen: Nn(o.nthen, a), gthen: Nn(o.gthen, a) } : {}, t && ce(a, t), ++i.ref, a.finalize = function () { --this.parent.ref || this.parent.finalize() }; var u = ft(a, e, r, n); return a.ref === 0 && a.finalize(), u } function lt() { return ne.id || (ne.id = ++ko), ++ne.awaits, ne.echoes += Mi, ne.id } function Ie() { return ne.awaits ? (--ne.awaits === 0 && (ne.id = 0), ne.echoes = ne.awaits * Mi, !0) : !1 } ("" + ji).indexOf("[native code]") === -1 && (lt = Ie = U); function fr(e) { return ne.echoes && e && e.constructor === Wt ? (lt(), e.then(function (t) { return Ie(), t }, function (t) { return Ie(), q(t) })) : e } function Ro(e) { ++lr, (!ne.echoes || --ne.echoes === 0) && (ne.echoes = ne.id = 0), Zt.push(D), Ue(e, !0) } function Eo() { var e = Zt[Zt.length - 1]; Zt.pop(), Ue(e, !1) } function Ue(e, t) { var r = D; if ((t ? ne.echoes && (!Pr++ || e !== D) : Pr && (!--Pr || e !== D)) && zi(t ? Ro.bind(null, e) : Eo), e !== D && (D = e, r === it && (it.env = Ui()), _n)) { var n = it.env.Promise, i = e.env; cr.then = i.nthen, n.prototype.then = i.gthen, (r.global || e.global) && (Object.defineProperty($, "Promise", i.PromiseProp), n.all = i.all, n.race = i.race, n.resolve = i.resolve, n.reject = i.reject, i.allSettled && (n.allSettled = i.allSettled), i.any && (n.any = i.any)) } } function Ui() { var e = $.Promise; return _n ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor($, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject, nthen: cr.then, gthen: e.prototype.then } : {} } function ft(e, t, r, n, i) { var a = D; try { return Ue(e, !0), t(r, n, i) } finally { Ue(a, !1) } } function zi(e) { ji.call(Nr, e) } function pr(e, t, r, n) { return typeof e != "function" ? e : function () { var i = D; r && lt(), Ue(t, !0); try { return e.apply(this, arguments) } finally { Ue(i, !1), n && zi(Ie) } } } function Nn(e, t) { return function (r, n) { return e.call(this, pr(r, t), pr(n, t)) } } var Ln = "unhandledrejection"; function Un(e, t) { var r; try { r = t.onuncatched(e) } catch { } if (r !== !1) try { var n, i = { promise: t, reason: e }; if ($.document && document.createEvent ? (n = document.createEvent("Event"), n.initEvent(Ln, !0, !0), ce(n, i)) : $.CustomEvent && (n = new CustomEvent(Ln, { detail: i }), ce(n, i)), n && $.dispatchEvent && (dispatchEvent(n), !$.PromiseRejectionEvent && $.onunhandledrejection)) try { $.onunhandledrejection(n) } catch { } Se && n && !n.defaultPrevented && console.warn("Unhandled rejection: " + (e.stack || e)) } catch { } } var q = E.reject; function Hr(e, t, r, n) { if (!e.idbdb || !e._state.openComplete && !D.letThrough && !e._vip) { if (e._state.openComplete) return q(new I.DatabaseClosed(e._state.dbOpenError)); if (!e._state.isBeingOpened) { if (!e._options.autoOpen) return q(new I.DatabaseClosed); e.open().catch(U) } return e._state.dbReadyPromise.then(function () { return Hr(e, t, r, n) }) } else { var i = e._createTransaction(t, r, e._dbSchema); try { i.create(), e._state.PR1398_maxLoop = 3 } catch (a) { return a.name === yn.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return Hr(e, t, r, n) })) : q(a) } return i._promise(t, function (a, o) { return Le(function () { return D.trans = i, n(a, o, i) }) }).then(function (a) { return i._completion.then(function () { return a }) }) } } var zn = "3.2.2", Ve = String.fromCharCode(65535), qr = -1 / 0, ke = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", $i = "String expected.", Ct = [], Sr = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), xo = Sr, Do = Sr, Gi = function (e) { return !/(dexie\.js|dexie\.min\.js)/.test(e) }, Tr = "__dbnames", Rr = "readonly", Er = "readwrite"; function Qe(e, t) { return e ? t ? function () { return e.apply(this, arguments) && t.apply(this, arguments) } : e : t } var Ji = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 }; function Ut(e) { return typeof e == "string" && !/\./.test(e) ? function (t) { return t[e] === void 0 && e in t && (t = At(t), delete t[e]), t } : function (t) { return t } } var wo = function () { function e() { } return e.prototype._trans = function (t, r, n) { var i = this._tx || D.trans, a = this.name; function o(s, c, l) { if (!l.schema[a]) throw new I.NotFound("Table " + a + " not part of transaction"); return r(l.idbtrans, l) } var u = Mt(); try { return i && i.db === this.db ? i === D.trans ? i._promise(t, o, n) : Le(function () { return i._promise(t, o, n) }, { trans: i, transless: D.transless || D }) : Hr(this.db, t, [this.name], o) } finally { u && jt() } }, e.prototype.get = function (t, r) { var n = this; return t && t.constructor === Object ? this.where(t).first(r) : this._trans("readonly", function (i) { return n.core.get({ trans: i, key: t }).then(function (a) { return n.hook.reading.fire(a) }) }).then(r) }, e.prototype.where = function (t) { if (typeof t == "string") return new this.db.WhereClause(this, t); if (ie(t)) return new this.db.WhereClause(this, "[" + t.join("+") + "]"); var r = H(t); if (r.length === 1) return this.where(r[0]).equals(t[r[0]]); var n = this.schema.indexes.concat(this.schema.primKey).filter(function (l) { return l.compound && r.every(function (f) { return l.keyPath.indexOf(f) >= 0 }) && l.keyPath.every(function (f) { return r.indexOf(f) >= 0 }) })[0]; if (n && this.db._maxKey !== Ve) return this.where(n.name).equals(n.keyPath.map(function (l) { return t[l] })); !n && Se && console.warn("The query " + JSON.stringify(t) + " on " + this.name + " would benefit of a " + ("compound index [" + r.join("+") + "]")); var i = this.schema.idxByName, a = this.db._deps.indexedDB; function o(l, f) { try { return a.cmp(l, f) === 0 } catch { return !1 } } var u = r.reduce(function (l, f) { var p = l[0], v = l[1], d = i[f], h = t[f]; return [p || d, p || !d ? Qe(v, d && d.multi ? function (b) { var m = we(b, f); return ie(m) && m.some(function (g) { return o(h, g) }) } : function (b) { return o(h, we(b, f)) }) : v] }, [null, null]), s = u[0], c = u[1]; return s ? this.where(s.name).equals(t[s.keyPath]).filter(c) : n ? this.filter(c) : this.where(r).equals("") }, e.prototype.filter = function (t) { return this.toCollection().and(t) }, e.prototype.count = function (t) { return this.toCollection().count(t) }, e.prototype.offset = function (t) { return this.toCollection().offset(t) }, e.prototype.limit = function (t) { return this.toCollection().limit(t) }, e.prototype.each = function (t) { return this.toCollection().each(t) }, e.prototype.toArray = function (t) { return this.toCollection().toArray(t) }, e.prototype.toCollection = function () { return new this.db.Collection(new this.db.WhereClause(this)) }, e.prototype.orderBy = function (t) { return new this.db.Collection(new this.db.WhereClause(this, ie(t) ? "[" + t.join("+") + "]" : t)) }, e.prototype.reverse = function () { return this.toCollection().reverse() }, e.prototype.mapToClass = function (t) { this.schema.mappedClass = t; var r = function (n) { if (!n) return n; var i = Object.create(t.prototype); for (var a in n) if (me(n, a)) try { i[a] = n[a] } catch { } return i }; return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook("reading", r), t }, e.prototype.defineClass = function () { function t(r) { ce(this, r) } return this.mapToClass(t) }, e.prototype.add = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Ut(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "add", keys: r != null ? [r] : null, values: [u] }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { _e(t, o, s) } catch { } return s }) }, e.prototype.update = function (t, r) { if (typeof t == "object" && !ie(t)) { var n = we(t, this.schema.primKey.keyPath); if (n === void 0) return q(new I.InvalidArgument("Given object does not contain its primary key")); try { typeof r != "function" ? H(r).forEach(function (i) { _e(t, i, r[i]) }) : r(t, { value: t, primKey: n }) } catch { } return this.where(":id").equals(n).modify(r) } else return this.where(":id").equals(t).modify(r) }, e.prototype.put = function (t, r) { var n = this, i = this.schema.primKey, a = i.auto, o = i.keyPath, u = t; return o && a && (u = Ut(o)(t)), this._trans("readwrite", function (s) { return n.core.mutate({ trans: s, type: "put", values: [u], keys: r != null ? [r] : null }) }).then(function (s) { return s.numFailures ? E.reject(s.failures[0]) : s.lastResult }).then(function (s) { if (o) try { _e(t, o, s) } catch { } return s }) }, e.prototype.delete = function (t) { var r = this; return this._trans("readwrite", function (n) { return r.core.mutate({ trans: n, type: "delete", keys: [t] }) }).then(function (n) { return n.numFailures ? E.reject(n.failures[0]) : void 0 }) }, e.prototype.clear = function () { var t = this; return this._trans("readwrite", function (r) { return t.core.mutate({ trans: r, type: "deleteRange", range: Ji }) }).then(function (r) { return r.numFailures ? E.reject(r.failures[0]) : void 0 }) }, e.prototype.bulkGet = function (t) { var r = this; return this._trans("readonly", function (n) { return r.core.getMany({ keys: t, trans: n }).then(function (i) { return i.map(function (a) { return r.hook.reading.fire(a) }) }) }) }, e.prototype.bulkAdd = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, l = s.keyPath; if (l && a) throw new I.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new I.InvalidArgument("Arguments objects and keys must have the same length"); var f = t.length, p = l && c ? t.map(Ut(l)) : t; return i.core.mutate({ trans: u, type: "add", keys: a, values: p, wantResults: o }).then(function (v) { var d = v.numFailures, h = v.results, b = v.lastResult, m = v.failures, g = o ? h : b; if (d === 0) return g; throw new _t(i.name + ".bulkAdd(): " + d + " of " + f + " operations failed", m) }) }) }, e.prototype.bulkPut = function (t, r, n) { var i = this, a = Array.isArray(r) ? r : void 0; n = n || (a ? void 0 : r); var o = n ? n.allKeys : void 0; return this._trans("readwrite", function (u) { var s = i.schema.primKey, c = s.auto, l = s.keyPath; if (l && a) throw new I.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys"); if (a && a.length !== t.length) throw new I.InvalidArgument("Arguments objects and keys must have the same length"); var f = t.length, p = l && c ? t.map(Ut(l)) : t; return i.core.mutate({ trans: u, type: "put", keys: a, values: p, wantResults: o }).then(function (v) { var d = v.numFailures, h = v.results, b = v.lastResult, m = v.failures, g = o ? h : b; if (d === 0) return g; throw new _t(i.name + ".bulkPut(): " + d + " of " + f + " operations failed", m) }) }) }, e.prototype.bulkDelete = function (t) { var r = this, n = t.length; return this._trans("readwrite", function (i) { return r.core.mutate({ trans: i, type: "delete", keys: t }) }).then(function (i) { var a = i.numFailures, o = i.lastResult, u = i.failures; if (a === 0) return o; throw new _t(r.name + ".bulkDelete(): " + a + " of " + n + " operations failed", u) }) }, e }(); function Bt(e) { var t = {}, r = function (u, s) { if (s) { for (var c = arguments.length, l = new Array(c - 1); --c;)l[c - 1] = arguments[c]; return t[u].subscribe.apply(null, l), e } else if (typeof u == "string") return t[u] }; r.addEventType = a; for (var n = 1, i = arguments.length; n < i; ++n)a(arguments[n]); return r; function a(u, s, c) { if (typeof u == "object") return o(u); s || (s = mo), c || (c = U); var l = { subscribers: [], fire: c, subscribe: function (f) { l.subscribers.indexOf(f) === -1 && (l.subscribers.push(f), l.fire = s(l.fire, f)) }, unsubscribe: function (f) { l.subscribers = l.subscribers.filter(function (p) { return p !== f }), l.fire = l.subscribers.reduce(s, c) } }; return t[u] = r[u] = l, l } function o(u) { H(u).forEach(function (s) { var c = u[s]; if (ie(c)) a(s, u[s][0], u[s][1]); else if (c === "asap") var l = a(s, It, function () { for (var p = arguments.length, v = new Array(p); p--;)v[p] = arguments[p]; l.subscribers.forEach(function (d) { Pi(function () { d.apply(null, v) }) }) }); else throw new I.InvalidArgument("Invalid event config") }) } } function Ft(e, t) { return ct(t).from({ prototype: e }), t } function Oo(e) { return Ft(wo.prototype, function (r, n, i) { this.db = e, this._tx = i, this.name = r, this.schema = n, this.hook = e._allTables[r] ? e._allTables[r].hook : Bt(null, { creating: [po, U], reading: [fo, It], updating: [vo, U], deleting: [ho, U] }) }) } function Ze(e, t) { return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter) } function xr(e, t) { e.filter = Qe(e.filter, t) } function Dr(e, t, r) { var n = e.replayFilter; e.replayFilter = n ? function () { return Qe(n(), t()) } : t, e.justLimit = r && !n } function Ao(e, t) { e.isMatch = Qe(e.isMatch, t) } function er(e, t) { if (e.isPrimKey) return t.primaryKey; var r = t.getIndexByKeyPath(e.index); if (!r) throw new I.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed"); return r } function $n(e, t, r) { var n = er(e, t.schema); return t.openCursor({ trans: r, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: n, range: e.range } }) } function zt(e, t, r, n) { var i = e.replayFilter ? Qe(e.filter, e.replayFilter()) : e.filter; if (e.or) { var a = {}, o = function (u, s, c) { if (!i || i(s, c, function (p) { return s.stop(p) }, function (p) { return s.fail(p) })) { var l = s.primaryKey, f = "" + l; f === "[object ArrayBuffer]" && (f = "" + new Uint8Array(l)), me(a, f) || (a[f] = !0, t(u, s, c)) } }; return Promise.all([e.or._iterate(o, r), Gn($n(e, n, r), e.algorithm, o, !e.keysOnly && e.valueMapper)]) } else return Gn($n(e, n, r), Qe(e.algorithm, i), t, !e.keysOnly && e.valueMapper) } function Gn(e, t, r, n) { var i = n ? function (o, u, s) { return r(n(o), u, s) } : r, a = G(i); return e.then(function (o) { if (o) return o.start(function () { var u = function () { return o.continue() }; (!t || t(o, function (s) { return u = s }, function (s) { o.stop(s), u = U }, function (s) { o.fail(s), u = U })) && a(o.value, o, function (s) { return u = s }), u() }) }) } function se(e, t) { try { var r = Jn(e), n = Jn(t); if (r !== n) return r === "Array" ? 1 : n === "Array" ? -1 : r === "binary" ? 1 : n === "binary" ? -1 : r === "string" ? 1 : n === "string" ? -1 : r === "Date" ? 1 : n !== "Date" ? NaN : -1; switch (r) { case "number": case "Date": case "string": return e > t ? 1 : e < t ? -1 : 0; case "binary": return Mo(Vn(e), Vn(t)); case "Array": return Io(e, t) } } catch { } return NaN } function Io(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a) { var o = se(e[a], t[a]); if (o !== 0) return o } return r === n ? 0 : r < n ? -1 : 1 } function Mo(e, t) { for (var r = e.length, n = t.length, i = r < n ? r : n, a = 0; a < i; ++a)if (e[a] !== t[a]) return e[a] < t[a] ? -1 : 1; return r === n ? 0 : r < n ? -1 : 1 } function Jn(e) { var t = typeof e; if (t !== "object") return t; if (ArrayBuffer.isView(e)) return "binary"; var r = Br(e); return r === "ArrayBuffer" ? "binary" : r } function Vn(e) { return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e) } var jo = function () { function e() { } return e.prototype._read = function (t, r) { var n = this._ctx; return n.error ? n.table._trans(null, q.bind(null, n.error)) : n.table._trans("readonly", t).then(r) }, e.prototype._write = function (t) { var r = this._ctx; return r.error ? r.table._trans(null, q.bind(null, r.error)) : r.table._trans("readwrite", t, "locked") }, e.prototype._addAlgorithm = function (t) { var r = this._ctx; r.algorithm = Qe(r.algorithm, t) }, e.prototype._iterate = function (t, r) { return zt(this._ctx, t, r, this._ctx.table.core) }, e.prototype.clone = function (t) { var r = Object.create(this.constructor.prototype), n = Object.create(this._ctx); return t && ce(n, t), r._ctx = n, r }, e.prototype.raw = function () { return this._ctx.valueMapper = null, this }, e.prototype.each = function (t) { var r = this._ctx; return this._read(function (n) { return zt(r, t, n, r.table.core) }) }, e.prototype.count = function (t) { var r = this; return this._read(function (n) { var i = r._ctx, a = i.table.core; if (Ze(i, !0)) return a.count({ trans: n, query: { index: er(i, a.schema), range: i.range } }).then(function (u) { return Math.min(u, i.limit) }); var o = 0; return zt(i, function () { return ++o, !1 }, n, a).then(function () { return o }) }).then(t) }, e.prototype.sortBy = function (t, r) { var n = t.split(".").reverse(), i = n[0], a = n.length - 1; function o(c, l) { return l ? o(c[n[l]], l - 1) : c[i] } var u = this._ctx.dir === "next" ? 1 : -1; function s(c, l) { var f = o(c, a), p = o(l, a); return f < p ? -u : f > p ? u : 0 } return this.toArray(function (c) { return c.sort(s) }).then(r) }, e.prototype.toArray = function (t) { var r = this; return this._read(function (n) { var i = r._ctx; if (i.dir === "next" && Ze(i, !0) && i.limit > 0) { var a = i.valueMapper, o = er(i, i.table.core.schema); return i.table.core.query({ trans: n, limit: i.limit, values: !0, query: { index: o, range: i.range } }).then(function (s) { var c = s.result; return a ? c.map(a) : c }) } else { var u = []; return zt(i, function (s) { return u.push(s) }, n, i.table.core).then(function () { return u }) } }, t) }, e.prototype.offset = function (t) { var r = this._ctx; return t <= 0 ? this : (r.offset += t, Ze(r) ? Dr(r, function () { var n = t; return function (i, a) { return n === 0 ? !0 : n === 1 ? (--n, !1) : (a(function () { i.advance(n), n = 0 }), !1) } }) : Dr(r, function () { var n = t; return function () { return --n < 0 } }), this) }, e.prototype.limit = function (t) { return this._ctx.limit = Math.min(this._ctx.limit, t), Dr(this._ctx, function () { var r = t; return function (n, i, a) { return --r <= 0 && i(a), r >= 0 } }, !0), this }, e.prototype.until = function (t, r) { return xr(this._ctx, function (n, i, a) { return t(n.value) ? (i(a), r) : !0 }), this }, e.prototype.first = function (t) { return this.limit(1).toArray(function (r) { return r[0] }).then(t) }, e.prototype.last = function (t) { return this.reverse().first(t) }, e.prototype.filter = function (t) { return xr(this._ctx, function (r) { return t(r.value) }), Ao(this._ctx, t), this }, e.prototype.and = function (t) { return this.filter(t) }, e.prototype.or = function (t) { return new this.db.WhereClause(this._ctx.table, t, this) }, e.prototype.reverse = function () { return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this }, e.prototype.desc = function () { return this.reverse() }, e.prototype.eachKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.key, i) }) }, e.prototype.eachUniqueKey = function (t) { return this._ctx.unique = "unique", this.eachKey(t) }, e.prototype.eachPrimaryKey = function (t) { var r = this._ctx; return r.keysOnly = !r.isMatch, this.each(function (n, i) { t(i.primaryKey, i) }) }, e.prototype.keys = function (t) { var r = this._ctx; r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.key) }).then(function () { return n }).then(t) }, e.prototype.primaryKeys = function (t) { var r = this._ctx; if (r.dir === "next" && Ze(r, !0) && r.limit > 0) return this._read(function (i) { var a = er(r, r.table.core.schema); return r.table.core.query({ trans: i, values: !1, limit: r.limit, query: { index: a, range: r.range } }) }).then(function (i) { var a = i.result; return a }).then(t); r.keysOnly = !r.isMatch; var n = []; return this.each(function (i, a) { n.push(a.primaryKey) }).then(function () { return n }).then(t) }, e.prototype.uniqueKeys = function (t) { return this._ctx.unique = "unique", this.keys(t) }, e.prototype.firstKey = function (t) { return this.limit(1).keys(function (r) { return r[0] }).then(t) }, e.prototype.lastKey = function (t) { return this.reverse().firstKey(t) }, e.prototype.distinct = function () { var t = this._ctx, r = t.index && t.table.schema.idxByName[t.index]; if (!r || !r.multi) return this; var n = {}; return xr(this._ctx, function (i) { var a = i.primaryKey.toString(), o = me(n, a); return n[a] = !0, !o }), this }, e.prototype.modify = function (t) { var r = this, n = this._ctx; return this._write(function (i) { var a; if (typeof t == "function") a = t; else { var o = H(t), u = o.length; a = function (m) { for (var g = !1, C = 0; C < u; ++C) { var _ = o[C], y = t[_]; we(m, _) !== y && (_e(m, _, y), g = !0) } return g } } var s = n.table.core, c = s.schema.primaryKey, l = c.outbound, f = c.extractKey, p = r.db._options.modifyChunkSize || 200, v = [], d = 0, h = [], b = function (m, g) { var C = g.failures, _ = g.numFailures; d += m - _; for (var y = 0, S = H(C); y < S.length; y++) { var R = S[y]; v.push(C[R]) } }; return r.clone().primaryKeys().then(function (m) { var g = function (C) { var _ = Math.min(p, m.length - C); return s.getMany({ trans: i, keys: m.slice(C, C + _), cache: "immutable" }).then(function (y) { for (var S = [], R = [], T = l ? [] : null, O = [], k = 0; k < _; ++k) { var N = y[k], K = { value: At(N), primKey: m[C + k] }; a.call(K, K.value, K) !== !1 && (K.value == null ? O.push(m[C + k]) : !l && se(f(N), f(K.value)) !== 0 ? (O.push(m[C + k]), S.push(K.value)) : (R.push(K.value), l && T.push(m[C + k]))) } var F = Ze(n) && n.limit === 1 / 0 && (typeof t != "function" || t === wr) && { index: n.index, range: n.range }; return Promise.resolve(S.length > 0 && s.mutate({ trans: i, type: "add", values: S }).then(function (z) { for (var M in z.failures) O.splice(parseInt(M), 1); b(S.length, z) })).then(function () { return (R.length > 0 || F && typeof t == "object") && s.mutate({ trans: i, type: "put", keys: T, values: R, criteria: F, changeSpec: typeof t != "function" && t }).then(function (z) { return b(R.length, z) }) }).then(function () { return (O.length > 0 || F && t === wr) && s.mutate({ trans: i, type: "delete", keys: O, criteria: F }).then(function (z) { return b(O.length, z) }) }).then(function () { return m.length > C + _ && g(C + p) }) }) }; return g(0).then(function () { if (v.length > 0) throw new sr("Error modifying one or more objects", v, d, h); return m.length }) }) }) }, e.prototype.delete = function () { var t = this._ctx, r = t.range; return Ze(t) && (t.isPrimKey && !Do || r.type === 3) ? this._write(function (n) { var i = t.table.core.schema.primaryKey, a = r; return t.table.core.count({ trans: n, query: { index: i, range: a } }).then(function (o) { return t.table.core.mutate({ trans: n, type: "deleteRange", range: a }).then(function (u) { var s = u.failures; u.lastResult, u.results; var c = u.numFailures; if (c) throw new sr("Could not delete some values", Object.keys(s).map(function (l) { return s[l] }), o - c); return o - c }) }) }) : this.modify(wr) }, e }(), wr = function (e, t) { return t.value = null }; function Bo(e) { return Ft(jo.prototype, function (r, n) { this.db = e; var i = Ji, a = null; if (n) try { i = n() } catch (c) { a = c } var o = r._ctx, u = o.table, s = u.hook.reading.fire; this._ctx = { table: u, index: o.index, isPrimKey: !o.index || u.schema.primKey.keyPath && o.index === u.schema.primKey.name, range: i, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: a, or: o.or, valueMapper: s !== It ? s : null } }) } function Fo(e, t) { return e < t ? -1 : e === t ? 0 : 1 } function Ko(e, t) { return e > t ? -1 : e === t ? 0 : 1 } function he(e, t, r) { var n = e instanceof Hi ? new e.Collection(e) : e; return n._ctx.error = r ? new r(t) : new TypeError(t), n } function et(e) { return new e.Collection(e, function () { return Vi("") }).limit(0) } function No(e) { return e === "next" ? function (t) { return t.toUpperCase() } : function (t) { return t.toLowerCase() } } function Lo(e) { return e === "next" ? function (t) { return t.toLowerCase() } : function (t) { return t.toUpperCase() } } function Uo(e, t, r, n, i, a) { for (var o = Math.min(e.length, n.length), u = -1, s = 0; s < o; ++s) { var c = t[s]; if (c !== n[s]) return i(e[s], r[s]) < 0 ? e.substr(0, s) + r[s] + r.substr(s + 1) : i(e[s], n[s]) < 0 ? e.substr(0, s) + n[s] + r.substr(s + 1) : u >= 0 ? e.substr(0, u) + t[u] + r.substr(u + 1) : null; i(e[s], c) < 0 && (u = s) } return o < n.length && a === "next" ? e + r.substr(e.length) : o < e.length && a === "prev" ? e.substr(0, r.length) : u < 0 ? null : e.substr(0, u) + n[u] + r.substr(u + 1) } function $t(e, t, r, n) { var i, a, o, u, s, c, l, f = r.length; if (!r.every(function (h) { return typeof h == "string" })) return he(e, $i); function p(h) { i = No(h), a = Lo(h), o = h === "next" ? Fo : Ko; var b = r.map(function (m) { return { lower: a(m), upper: i(m) } }).sort(function (m, g) { return o(m.lower, g.lower) }); u = b.map(function (m) { return m.upper }), s = b.map(function (m) { return m.lower }), c = h, l = h === "next" ? "" : n } p("next"); var v = new e.Collection(e, function () { return Fe(u[0], s[f - 1] + n) }); v._ondirectionchange = function (h) { p(h) }; var d = 0; return v._addAlgorithm(function (h, b, m) { var g = h.key; if (typeof g != "string") return !1; var C = a(g); if (t(C, s, d)) return !0; for (var _ = null, y = d; y < f; ++y) { var S = Uo(g, C, u[y], s[y], o, c); S === null && _ === null ? d = y + 1 : (_ === null || o(_, S) > 0) && (_ = S) } return b(_ !== null ? function () { h.continue(_ + l) } : m), !1 }), v } function Fe(e, t, r, n) { return { type: 2, lower: e, upper: t, lowerOpen: r, upperOpen: n } } function Vi(e) { return { type: 1, lower: e, upper: e } } var Hi = function () { function e() { } return Object.defineProperty(e.prototype, "Collection", { get: function () { return this._ctx.table.db.Collection }, enumerable: !1, configurable: !0 }), e.prototype.between = function (t, r, n, i) { n = n !== !1, i = i === !0; try { return this._cmp(t, r) > 0 || this._cmp(t, r) === 0 && (n || i) && !(n && i) ? et(this) : new this.Collection(this, function () { return Fe(t, r, !n, !i) }) } catch { return he(this, ke) } }, e.prototype.equals = function (t) { return t == null ? he(this, ke) : new this.Collection(this, function () { return Vi(t) }) }, e.prototype.above = function (t) { return t == null ? he(this, ke) : new this.Collection(this, function () { return Fe(t, void 0, !0) }) }, e.prototype.aboveOrEqual = function (t) { return t == null ? he(this, ke) : new this.Collection(this, function () { return Fe(t, void 0, !1) }) }, e.prototype.below = function (t) { return t == null ? he(this, ke) : new this.Collection(this, function () { return Fe(void 0, t, !1, !0) }) }, e.prototype.belowOrEqual = function (t) { return t == null ? he(this, ke) : new this.Collection(this, function () { return Fe(void 0, t) }) }, e.prototype.startsWith = function (t) { return typeof t != "string" ? he(this, $i) : this.between(t, t + Ve, !0, !0) }, e.prototype.startsWithIgnoreCase = function (t) { return t === "" ? this.startsWith(t) : $t(this, function (r, n) { return r.indexOf(n[0]) === 0 }, [t], Ve) }, e.prototype.equalsIgnoreCase = function (t) { return $t(this, function (r, n) { return r === n[0] }, [t], "") }, e.prototype.anyOfIgnoreCase = function () { var t = Ee.apply(tt, arguments); return t.length === 0 ? et(this) : $t(this, function (r, n) { return n.indexOf(r) !== -1 }, t, "") }, e.prototype.startsWithAnyOfIgnoreCase = function () { var t = Ee.apply(tt, arguments); return t.length === 0 ? et(this) : $t(this, function (r, n) { return n.some(function (i) { return r.indexOf(i) === 0 }) }, t, Ve) }, e.prototype.anyOf = function () { var t = this, r = Ee.apply(tt, arguments), n = this._cmp; try { r.sort(n) } catch { return he(this, ke) } if (r.length === 0) return et(this); var i = new this.Collection(this, function () { return Fe(r[0], r[r.length - 1]) }); i._ondirectionchange = function (o) { n = o === "next" ? t._ascending : t._descending, r.sort(n) }; var a = 0; return i._addAlgorithm(function (o, u, s) { for (var c = o.key; n(c, r[a]) > 0;)if (++a, a === r.length) return u(s), !1; return n(c, r[a]) === 0 ? !0 : (u(function () { o.continue(r[a]) }), !1) }), i }, e.prototype.notEqual = function (t) { return this.inAnyRange([[qr, t], [t, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 }) }, e.prototype.noneOf = function () { var t = Ee.apply(tt, arguments); if (t.length === 0) return new this.Collection(this); try { t.sort(this._ascending) } catch { return he(this, ke) } var r = t.reduce(function (n, i) { return n ? n.concat([[n[n.length - 1][1], i]]) : [[qr, i]] }, null); return r.push([t[t.length - 1], this.db._maxKey]), this.inAnyRange(r, { includeLowers: !1, includeUppers: !1 }) }, e.prototype.inAnyRange = function (t, r) { var n = this, i = this._cmp, a = this._ascending, o = this._descending, u = this._min, s = this._max; if (t.length === 0) return et(this); if (!t.every(function (y) { return y[0] !== void 0 && y[1] !== void 0 && a(y[0], y[1]) <= 0 })) return he(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", I.InvalidArgument); var c = !r || r.includeLowers !== !1, l = r && r.includeUppers === !0; function f(y, S) { for (var R = 0, T = y.length; R < T; ++R) { var O = y[R]; if (i(S[0], O[1]) < 0 && i(S[1], O[0]) > 0) { O[0] = u(O[0], S[0]), O[1] = s(O[1], S[1]); break } } return R === T && y.push(S), y } var p = a; function v(y, S) { return p(y[0], S[0]) } var d; try { d = t.reduce(f, []), d.sort(v) } catch { return he(this, ke) } var h = 0, b = l ? function (y) { return a(y, d[h][1]) > 0 } : function (y) { return a(y, d[h][1]) >= 0 }, m = c ? function (y) { return o(y, d[h][0]) > 0 } : function (y) { return o(y, d[h][0]) >= 0 }; function g(y) { return !b(y) && !m(y) } var C = b, _ = new this.Collection(this, function () { return Fe(d[0][0], d[d.length - 1][1], !c, !l) }); return _._ondirectionchange = function (y) { y === "next" ? (C = b, p = a) : (C = m, p = o), d.sort(v) }, _._addAlgorithm(function (y, S, R) { for (var T = y.key; C(T);)if (++h, h === d.length) return S(R), !1; return g(T) ? !0 : (n._cmp(T, d[h][1]) === 0 || n._cmp(T, d[h][0]) === 0 || S(function () { p === a ? y.continue(d[h][0]) : y.continue(d[h][1]) }), !1) }), _ }, e.prototype.startsWithAnyOf = function () { var t = Ee.apply(tt, arguments); return t.every(function (r) { return typeof r == "string" }) ? t.length === 0 ? et(this) : this.inAnyRange(t.map(function (r) { return [r, r + Ve] })) : he(this, "startsWithAnyOf() only works with strings") }, e }(); function zo(e) { return Ft(Hi.prototype, function (r, n, i) { this.db = e, this._ctx = { table: r, index: n === ":id" ? null : n, or: i }; var a = e._deps.indexedDB; if (!a) throw new I.MissingAPI; this._cmp = this._ascending = a.cmp.bind(a), this._descending = function (o, u) { return a.cmp(u, o) }, this._max = function (o, u) { return a.cmp(o, u) > 0 ? o : u }, this._min = function (o, u) { return a.cmp(o, u) < 0 ? o : u }, this._IDBKeyRange = e._deps.IDBKeyRange }) } function Ce(e) { return G(function (t) { return Et(t), e(t.target.error), !1 }) } function Et(e) { e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault() } var xt = "storagemutated", Ne = "x-storagemutated-1", ze = Bt(null, xt), $o = function () { function e() { } return e.prototype._lock = function () { return vt(!D.global), ++this._reculock, this._reculock === 1 && !D.global && (D.lockOwnerFor = this), this }, e.prototype._unlock = function () { if (vt(!D.global), --this._reculock === 0) for (D.global || (D.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) { var t = this._blockedFuncs.shift(); try { ft(t[1], t[0]) } catch { } } return this }, e.prototype._locked = function () { return this._reculock && D.lockOwnerFor !== this }, e.prototype.create = function (t) { var r = this; if (!this.mode) return this; var n = this.db.idbdb, i = this.db._state.dbOpenError; if (vt(!this.idbtrans), !t && !n) switch (i && i.name) { case "DatabaseClosedError": throw new I.DatabaseClosed(i); case "MissingAPIError": throw new I.MissingAPI(i.message, i); default: throw new I.OpenFailed(i) }if (!this.active) throw new I.TransactionInactive; return vt(this._completion._state === null), t = this.idbtrans = t || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : n.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })), t.onerror = G(function (a) { Et(a), r._reject(t.error) }), t.onabort = G(function (a) { Et(a), r.active && r._reject(new I.Abort(t.error)), r.active = !1, r.on("abort").fire(a) }), t.oncomplete = G(function () { r.active = !1, r._resolve(), "mutatedParts" in t && ze.storagemutated.fire(t.mutatedParts) }), this }, e.prototype._promise = function (t, r, n) { var i = this; if (t === "readwrite" && this.mode !== "readwrite") return q(new I.ReadOnly("Transaction is readonly")); if (!this.active) return q(new I.TransactionInactive); if (this._locked()) return new E(function (o, u) { i._blockedFuncs.push([function () { i._promise(t, r, n).then(o, u) }, D]) }); if (n) return Le(function () { var o = new E(function (u, s) { i._lock(); var c = r(u, s, i); c && c.then && c.then(u, s) }); return o.finally(function () { return i._unlock() }), o._lib = !0, o }); var a = new E(function (o, u) { var s = r(o, u, i); s && s.then && s.then(o, u) }); return a._lib = !0, a }, e.prototype._root = function () { return this.parent ? this.parent._root() : this }, e.prototype.waitFor = function (t) { var r = this._root(), n = E.resolve(t); if (r._waitingFor) r._waitingFor = r._waitingFor.then(function () { return n }); else { r._waitingFor = n, r._waitingQueue = []; var i = r.idbtrans.objectStore(r.storeNames[0]); (function o() { for (++r._spinCount; r._waitingQueue.length;)r._waitingQueue.shift()(); r._waitingFor && (i.get(-1 / 0).onsuccess = o) })() } var a = r._waitingFor; return new E(function (o, u) { n.then(function (s) { return r._waitingQueue.push(G(o.bind(null, s))) }, function (s) { return r._waitingQueue.push(G(u.bind(null, s))) }).finally(function () { r._waitingFor === a && (r._waitingFor = null) }) }) }, e.prototype.abort = function () { this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new I.Abort)) }, e.prototype.table = function (t) { var r = this._memoizedTables || (this._memoizedTables = {}); if (me(r, t)) return r[t]; var n = this.schema[t]; if (!n) throw new I.NotFound("Table " + t + " not part of transaction"); var i = new this.db.Table(t, n, this); return i.core = this.db.core.table(t), r[t] = i, i }, e }(); function Go(e) { return Ft($o.prototype, function (r, n, i, a, o) { var u = this; this.db = e, this.mode = r, this.storeNames = n, this.schema = i, this.chromeTransactionDurability = a, this.idbtrans = null, this.on = Bt(this, "complete", "error", "abort"), this.parent = o || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new E(function (s, c) { u._resolve = s, u._reject = c }), this._completion.then(function () { u.active = !1, u.on.complete.fire() }, function (s) { var c = u.active; return u.active = !1, u.on.error.fire(s), u.parent ? u.parent._reject(s) : c && u.idbtrans && u.idbtrans.abort(), q(s) }) }) } function Wr(e, t, r, n, i, a, o) { return { name: e, keyPath: t, unique: r, multi: n, auto: i, compound: a, src: (r && !o ? "&" : "") + (n ? "*" : "") + (i ? "++" : "") + qi(t) } } function qi(e) { return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "" } function Wi(e, t, r) { return { name: e, primKey: t, indexes: r, mappedClass: null, idxByName: Ri(r, function (n) { return [n.name, n] }) } } function Jo(e) { return e.length === 1 ? e[0] : e } var Dt = function (e) { try { return e.only([[]]), Dt = function () { return [[]] }, [[]] } catch { return Dt = function () { return Ve }, Ve } }; function Yr(e) { return e == null ? function () { } : typeof e == "string" ? Vo(e) : function (t) { return we(t, e) } } function Vo(e) { var t = e.split("."); return t.length === 1 ? function (r) { return r[e] } : function (r) { return we(r, e) } } function Hn(e) { return [].slice.call(e) } var Ho = 0; function St(e) { return e == null ? ":id" : typeof e == "string" ? e : "[" + e.join("+") + "]" } function qo(e, t, r) { function n(f, p) { var v = Hn(f.objectStoreNames); return { schema: { name: f.name, tables: v.map(function (d) { return p.objectStore(d) }).map(function (d) { var h = d.keyPath, b = d.autoIncrement, m = ie(h), g = h == null, C = {}, _ = { name: d.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g, compound: m, keyPath: h, autoIncrement: b, unique: !0, extractKey: Yr(h) }, indexes: Hn(d.indexNames).map(function (y) { return d.index(y) }).map(function (y) { var S = y.name, R = y.unique, T = y.multiEntry, O = y.keyPath, k = ie(O), N = { name: S, compound: k, keyPath: O, unique: R, multiEntry: T, extractKey: Yr(O) }; return C[St(O)] = N, N }), getIndexByKeyPath: function (y) { return C[St(y)] } }; return C[":id"] = _.primaryKey, h != null && (C[St(h)] = _.primaryKey), _ }) }, hasGetAll: v.length > 0 && "getAll" in p.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) } } function i(f) { if (f.type === 3) return null; if (f.type === 4) throw new Error("Cannot convert never type to IDBKeyRange"); var p = f.lower, v = f.upper, d = f.lowerOpen, h = f.upperOpen, b = p === void 0 ? v === void 0 ? null : t.upperBound(v, !!h) : v === void 0 ? t.lowerBound(p, !!d) : t.bound(p, v, !!d, !!h); return b } function a(f) { var p = f.name; function v(b) { var m = b.trans, g = b.type, C = b.keys, _ = b.values, y = b.range; return new Promise(function (S, R) { S = G(S); var T = m.objectStore(p), O = T.keyPath == null, k = g === "put" || g === "add"; if (!k && g !== "delete" && g !== "deleteRange") throw new Error("Invalid operation type: " + g); var N = (C || _ || { length: 1 }).length; if (C && _ && C.length !== _.length) throw new Error("Given keys array must have same length as given values array."); if (N === 0) return S({ numFailures: 0, failures: {}, results: [], lastResult: void 0 }); var K, F = [], z = [], M = 0, te = function (de) { ++M, Et(de) }; if (g === "deleteRange") { if (y.type === 4) return S({ numFailures: M, failures: z, results: [], lastResult: void 0 }); y.type === 3 ? F.push(K = T.clear()) : F.push(K = T.delete(i(y))) } else { var Q = k ? O ? [_, C] : [_, null] : [C, null], W = Q[0], pe = Q[1]; if (k) for (var oe = 0; oe < N; ++oe)F.push(K = pe && pe[oe] !== void 0 ? T[g](W[oe], pe[oe]) : T[g](W[oe])), K.onerror = te; else for (var oe = 0; oe < N; ++oe)F.push(K = T[g](W[oe])), K.onerror = te } var ye = function (de) { var Me = de.target.result; F.forEach(function (Y, je) { return Y.error != null && (z[je] = Y.error) }), S({ numFailures: M, failures: z, results: g === "delete" ? C : F.map(function (Y) { return Y.result }), lastResult: Me }) }; K.onerror = function (de) { te(de), ye(de) }, K.onsuccess = ye }) } function d(b) { var m = b.trans, g = b.values, C = b.query, _ = b.reverse, y = b.unique; return new Promise(function (S, R) { S = G(S); var T = C.index, O = C.range, k = m.objectStore(p), N = T.isPrimaryKey ? k : k.index(T.name), K = _ ? y ? "prevunique" : "prev" : y ? "nextunique" : "next", F = g || !("openKeyCursor" in N) ? N.openCursor(i(O), K) : N.openKeyCursor(i(O), K); F.onerror = Ce(R), F.onsuccess = G(function (z) { var M = F.result; if (!M) { S(null); return } M.___id = ++Ho, M.done = !1; var te = M.continue.bind(M), Q = M.continuePrimaryKey; Q && (Q = Q.bind(M)); var W = M.advance.bind(M), pe = function () { throw new Error("Cursor not started") }, oe = function () { throw new Error("Cursor not stopped") }; M.trans = m, M.stop = M.continue = M.continuePrimaryKey = M.advance = pe, M.fail = G(R), M.next = function () { var ye = this, de = 1; return this.start(function () { return de-- ? ye.continue() : ye.stop() }).then(function () { return ye }) }, M.start = function (ye) { var de = new Promise(function (Y, je) { Y = G(Y), F.onerror = Ce(je), M.fail = je, M.stop = function (Be) { M.stop = M.continue = M.continuePrimaryKey = M.advance = oe, Y(Be) } }), Me = function () { if (F.result) try { ye() } catch (Y) { M.fail(Y) } else M.done = !0, M.start = function () { throw new Error("Cursor behind last entry") }, M.stop() }; return F.onsuccess = G(function (Y) { F.onsuccess = Me, Me() }), M.continue = te, M.continuePrimaryKey = Q, M.advance = W, Me(), de }, S(M) }, R) }) } function h(b) { return function (m) { return new Promise(function (g, C) { g = G(g); var _ = m.trans, y = m.values, S = m.limit, R = m.query, T = S === 1 / 0 ? void 0 : S, O = R.index, k = R.range, N = _.objectStore(p), K = O.isPrimaryKey ? N : N.index(O.name), F = i(k); if (S === 0) return g({ result: [] }); if (b) { var z = y ? K.getAll(F, T) : K.getAllKeys(F, T); z.onsuccess = function (W) { return g({ result: W.target.result }) }, z.onerror = Ce(C) } else { var M = 0, te = y || !("openKeyCursor" in K) ? K.openCursor(F) : K.openKeyCursor(F), Q = []; te.onsuccess = function (W) { var pe = te.result; if (!pe) return g({ result: Q }); if (Q.push(y ? pe.value : pe.primaryKey), ++M === S) return g({ result: Q }); pe.continue() }, te.onerror = Ce(C) } }) } } return { name: p, schema: f, mutate: v, getMany: function (b) { var m = b.trans, g = b.keys; return new Promise(function (C, _) { C = G(C); for (var y = m.objectStore(p), S = g.length, R = new Array(S), T = 0, O = 0, k, N = function (M) { var te = M.target; (R[te._pos] = te.result) != null, ++O === T && C(R) }, K = Ce(_), F = 0; F < S; ++F) { var z = g[F]; z != null && (k = y.get(g[F]), k._pos = F, k.onsuccess = N, k.onerror = K, ++T) } T === 0 && C(R) }) }, get: function (b) { var m = b.trans, g = b.key; return new Promise(function (C, _) { C = G(C); var y = m.objectStore(p), S = y.get(g); S.onsuccess = function (R) { return C(R.target.result) }, S.onerror = Ce(_) }) }, query: h(s), openCursor: d, count: function (b) { var m = b.query, g = b.trans, C = m.index, _ = m.range; return new Promise(function (y, S) { var R = g.objectStore(p), T = C.isPrimaryKey ? R : R.index(C.name), O = i(_), k = O ? T.count(O) : T.count(); k.onsuccess = G(function (N) { return y(N.target.result) }), k.onerror = Ce(S) }) } } } var o = n(e, r), u = o.schema, s = o.hasGetAll, c = u.tables.map(function (f) { return a(f) }), l = {}; return c.forEach(function (f) { return l[f.name] = f }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function (f) { var p = l[f]; if (!p) throw new Error("Table '" + f + "' not found"); return l[f] }, MIN_KEY: -1 / 0, MAX_KEY: Dt(t), schema: u } } function Wo(e, t) { return t.reduce(function (r, n) { var i = n.create; return B(B({}, r), i(r)) }, e) } function Yo(e, t, r, n) { var i = r.IDBKeyRange; r.indexedDB; var a = Wo(qo(t, i, n), e.dbcore); return { dbcore: a } } function Tn(e, t) { var r = e._novip, n = t.db, i = Yo(r._middlewares, n, r._deps, t); r.core = i.dbcore, r.tables.forEach(function (a) { var o = a.name; r.core.schema.tables.some(function (u) { return u.name === o }) && (a.core = r.core.table(o), r[o] instanceof r.Table && (r[o].core = a.core)) }) } function dr(e, t, r, n) { var i = e._novip; r.forEach(function (a) { var o = n[a]; t.forEach(function (u) { var s = hn(u, a); (!s || "value" in s && s.value === void 0) && (u === i.Transaction.prototype || u instanceof i.Transaction ? Ae(u, a, { get: function () { return this.table(a) }, set: function (c) { Ti(this, a, { value: c, writable: !0, configurable: !0, enumerable: !0 }) } }) : u[a] = new i.Table(a, o)) }) }) } function Qr(e, t) { var r = e._novip; t.forEach(function (n) { for (var i in n) n[i] instanceof r.Table && delete n[i] }) } function Qo(e, t) { return e._cfg.version - t._cfg.version } function Xo(e, t, r, n) { var i = e._dbSchema, a = e._createTransaction("readwrite", e._storeNames, i); a.create(r), a._completion.catch(n); var o = a._reject.bind(a), u = D.transless || D; Le(function () { D.trans = a, D.transless = u, t === 0 ? (H(i).forEach(function (s) { kn(r, s, i[s].primKey, i[s].indexes) }), Tn(e, r), E.follow(function () { return e.on.populate.fire(a) }).catch(o)) : Zo(e, t, a, r).catch(o) }) } function Zo(e, t, r, n) { var i = e._novip, a = [], o = i._versions, u = i._dbSchema = Pn(i, i.idbdb, n), s = !1, c = o.filter(function (f) { return f._cfg.version >= t }); c.forEach(function (f) { a.push(function () { var p = u, v = f._cfg.dbschema; Zr(i, p, n), Zr(i, v, n), u = i._dbSchema = v; var d = Yi(p, v); d.add.forEach(function (_) { kn(n, _[0], _[1].primKey, _[1].indexes) }), d.change.forEach(function (_) { if (_.recreate) throw new I.Upgrade("Not yet support for changing primary key"); var y = n.objectStore(_.name); _.add.forEach(function (S) { return Xr(y, S) }), _.change.forEach(function (S) { y.deleteIndex(S.name), Xr(y, S) }), _.del.forEach(function (S) { return y.deleteIndex(S) }) }); var h = f._cfg.contentUpgrade; if (h && f._cfg.version > t) { Tn(i, n), r._memoizedTables = {}, s = !0; var b = Ei(v); d.del.forEach(function (_) { b[_] = p[_] }), Qr(i, [i.Transaction.prototype]), dr(i, [i.Transaction.prototype], H(b), b), r.schema = b; var m = vn(h); m && lt(); var g, C = E.follow(function () { if (g = h(r), g && m) { var _ = Ie.bind(null, null); g.then(_, _) } }); return g && typeof g.then == "function" ? E.resolve(g) : C.then(function () { return g }) } }), a.push(function (p) { if (!s || !xo) { var v = f._cfg.dbschema; ts(v, p) } Qr(i, [i.Transaction.prototype]), dr(i, [i.Transaction.prototype], i._storeNames, i._dbSchema), r.schema = i._dbSchema }) }); function l() { return a.length ? E.resolve(a.shift()(r.idbtrans)).then(l) : E.resolve() } return l().then(function () { es(u, n) }) } function Yi(e, t) { var r = { del: [], add: [], change: [] }, n; for (n in e) t[n] || r.del.push(n); for (n in t) { var i = e[n], a = t[n]; if (!i) r.add.push([n, a]); else { var o = { name: n, def: a, recreate: !1, del: [], add: [], change: [] }; if ("" + (i.primKey.keyPath || "") != "" + (a.primKey.keyPath || "") || i.primKey.auto !== a.primKey.auto && !Sr) o.recreate = !0, r.change.push(o); else { var u = i.idxByName, s = a.idxByName, c = void 0; for (c in u) s[c] || o.del.push(c); for (c in s) { var l = u[c], f = s[c]; l ? l.src !== f.src && o.change.push(f) : o.add.push(f) } (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && r.change.push(o) } } } return r } function kn(e, t, r, n) { var i = e.db.createObjectStore(t, r.keyPath ? { keyPath: r.keyPath, autoIncrement: r.auto } : { autoIncrement: r.auto }); return n.forEach(function (a) { return Xr(i, a) }), i } function es(e, t) { H(e).forEach(function (r) { t.db.objectStoreNames.contains(r) || kn(t, r, e[r].primKey, e[r].indexes) }) } function ts(e, t) { [].slice.call(t.db.objectStoreNames).forEach(function (r) { return e[r] == null && t.db.deleteObjectStore(r) }) } function Xr(e, t) { e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi }) } function Pn(e, t, r) { var n = {}, i = _r(t.objectStoreNames, 0); return i.forEach(function (a) { for (var o = r.objectStore(a), u = o.keyPath, s = Wr(qi(u), u || "", !1, !1, !!o.autoIncrement, u && typeof u != "string", !0), c = [], l = 0; l < o.indexNames.length; ++l) { var f = o.index(o.indexNames[l]); u = f.keyPath; var p = Wr(f.name, u, !!f.unique, !!f.multiEntry, !1, u && typeof u != "string", !1); c.push(p) } n[a] = Wi(a, s, c) }), n } function rs(e, t, r) { var n = e._novip; n.verno = t.version / 10; var i = n._dbSchema = Pn(n, t, r); n._storeNames = _r(t.objectStoreNames, 0), dr(n, [n._allTables], H(i), i) } function ns(e, t) { var r = Pn(e, e.idbdb, t), n = Yi(r, e._dbSchema); return !(n.add.length || n.change.some(function (i) { return i.add.length || i.change.length })) } function Zr(e, t, r) { for (var n = e._novip, i = r.db.objectStoreNames, a = 0; a < i.length; ++a) { var o = i[a], u = r.objectStore(o); n._hasGetAll = "getAll" in u; for (var s = 0; s < u.indexNames.length; ++s) { var c = u.indexNames[s], l = u.index(c).keyPath, f = typeof l == "string" ? l : "[" + _r(l).join("+") + "]"; if (t[o]) { var p = t[o].idxByName[f]; p && (p.name = c, delete t[o].idxByName[f], t[o].idxByName[c] = p) } } } typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && $.WorkerGlobalScope && $ instanceof $.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1) } function is(e) { return e.split(",").map(function (t, r) { t = t.trim(); var n = t.replace(/([&*]|\+\+)/g, ""), i = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split("+") : n; return Wr(n, i || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), ie(i), r === 0) }) } var as = function () { function e() { } return e.prototype._parseStoresSpec = function (t, r) { H(t).forEach(function (n) { if (t[n] !== null) { var i = is(t[n]), a = i.shift(); if (a.multi) throw new I.Schema("Primary key cannot be multi-valued"); i.forEach(function (o) { if (o.auto) throw new I.Schema("Only primary key can be marked as autoIncrement (++)"); if (!o.keyPath) throw new I.Schema("Index must have a name and cannot be an empty string") }), r[n] = Wi(n, a, i) } }) }, e.prototype.stores = function (t) { var r = this.db; this._cfg.storesSource = this._cfg.storesSource ? ce(this._cfg.storesSource, t) : t; var n = r._versions, i = {}, a = {}; return n.forEach(function (o) { ce(i, o._cfg.storesSource), a = o._cfg.dbschema = {}, o._parseStoresSpec(i, a) }), r._dbSchema = a, Qr(r, [r._allTables, r, r.Transaction.prototype]), dr(r, [r._allTables, r, r.Transaction.prototype, this._cfg.tables], H(a), a), r._storeNames = H(a), this }, e.prototype.upgrade = function (t) { return this._cfg.contentUpgrade = gn(this._cfg.contentUpgrade || U, t), this }, e }(); function os(e) { return Ft(as.prototype, function (r) { this.db = e, this._cfg = { version: r, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null } }) } function Rn(e, t) { var r = e._dbNamesDB; return r || (r = e._dbNamesDB = new wn(Tr, { addons: [], indexedDB: e, IDBKeyRange: t }), r.version(1).stores({ dbnames: "name" })), r.table("dbnames") } function En(e) { return e && typeof e.databases == "function" } function ss(e) { var t = e.indexedDB, r = e.IDBKeyRange; return En(t) ? Promise.resolve(t.databases()).then(function (n) { return n.map(function (i) { return i.name }).filter(function (i) { return i !== Tr }) }) : Rn(t, r).toCollection().primaryKeys() } function cs(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !En(r) && t !== Tr && Rn(r, n).put({ name: t }).catch(U) } function us(e, t) { var r = e.indexedDB, n = e.IDBKeyRange; !En(r) && t !== Tr && Rn(r, n).delete(t).catch(U) } function en(e) { return Le(function () { return D.letThrough = !0, e() }) } function ls() { var e = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent); if (!e || !indexedDB.databases) return Promise.resolve(); var t; return new Promise(function (r) { var n = function () { return indexedDB.databases().finally(r) }; t = setInterval(n, 100), n() }).finally(function () { return clearInterval(t) }) } function fs(e) { var t = e._state, r = e._deps.indexedDB; if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function () { return t.dbOpenError ? q(t.dbOpenError) : e }); Se && (t.openCanceller._stackHolder = Xe()), t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1; var n = t.openCanceller; function i() { if (t.openCanceller !== n) throw new I.DatabaseClosed("db.open() was cancelled") } var a = t.dbReadyResolve, o = null, u = !1; return E.race([n, (typeof navigator > "u" ? E.resolve() : ls()).then(function () { return new E(function (s, c) { if (i(), !r) throw new I.MissingAPI; var l = e.name, f = t.autoSchema ? r.open(l) : r.open(l, Math.round(e.verno * 10)); if (!f) throw new I.MissingAPI; f.onerror = Ce(c), f.onblocked = G(e._fireOnBlocked), f.onupgradeneeded = G(function (p) { if (o = f.transaction, t.autoSchema && !e._options.allowEmptyDB) { f.onerror = Et, o.abort(), f.result.close(); var v = r.deleteDatabase(l); v.onsuccess = v.onerror = G(function () { c(new I.NoSuchDatabase("Database " + l + " doesnt exist")) }) } else { o.onerror = Ce(c); var d = p.oldVersion > Math.pow(2, 62) ? 0 : p.oldVersion; u = d < 1, e._novip.idbdb = f.result, Xo(e, d / 10, o, c) } }, c), f.onsuccess = G(function () { o = null; var p = e._novip.idbdb = f.result, v = _r(p.objectStoreNames); if (v.length > 0) try { var d = p.transaction(Jo(v), "readonly"); t.autoSchema ? rs(e, p, d) : (Zr(e, e._dbSchema, d), ns(e, d) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), Tn(e, d) } catch { } Ct.push(e), p.onversionchange = G(function (h) { t.vcFired = !0, e.on("versionchange").fire(h) }), p.onclose = G(function (h) { e.on("close").fire(h) }), u && cs(e._deps, l), s() }, c) }) })]).then(function () { return i(), t.onReadyBeingFired = [], E.resolve(en(function () { return e.on.ready.fire(e.vip) })).then(function s() { if (t.onReadyBeingFired.length > 0) { var c = t.onReadyBeingFired.reduce(gn, U); return t.onReadyBeingFired = [], E.resolve(en(function () { return c(e.vip) })).then(s) } }) }).finally(function () { t.onReadyBeingFired = null, t.isBeingOpened = !1 }).then(function () { return e }).catch(function (s) { t.dbOpenError = s; try { o && o.abort() } catch { } return n === t.openCanceller && e._close(), q(s) }).finally(function () { t.openComplete = !0, a() }) } function tn(e) { var t = function (o) { return e.next(o) }, r = function (o) { return e.throw(o) }, n = a(t), i = a(r); function a(o) { return function (u) { var s = o(u), c = s.value; return s.done ? c : !c || typeof c.then != "function" ? ie(c) ? Promise.all(c).then(n, i) : n(c) : c.then(n, i) } } return a(t)() } function ps(e, t, r) { var n = arguments.length; if (n < 2) throw new I.InvalidArgument("Too few arguments"); for (var i = new Array(n - 1); --n;)i[n - 1] = arguments[n]; r = i.pop(); var a = xi(i); return [e, a, r] } function Qi(e, t, r, n, i) { return E.resolve().then(function () { var a = D.transless || D, o = e._createTransaction(t, r, e._dbSchema, n), u = { trans: o, transless: a }; if (n) o.idbtrans = n.idbtrans; else try { o.create(), e._state.PR1398_maxLoop = 3 } catch (f) { return f.name === yn.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e._close(), e.open().then(function () { return Qi(e, t, r, null, i) })) : q(f) } var s = vn(i); s && lt(); var c, l = E.follow(function () { if (c = i.call(o, o), c) if (s) { var f = Ie.bind(null, null); c.then(f, f) } else typeof c.next == "function" && typeof c.throw == "function" && (c = tn(c)) }, u); return (c && typeof c.then == "function" ? E.resolve(c).then(function (f) { return o.active ? f : q(new I.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")) }) : l.then(function () { return c })).then(function (f) { return n && o._resolve(), o._completion.then(function () { return f }) }).catch(function (f) { return o._reject(f), q(f) }) }) } function Gt(e, t, r) { for (var n = ie(e) ? e.slice() : [e], i = 0; i < r; ++i)n.push(t); return n } function ds(e) { return B(B({}, e), { table: function (t) { var r = e.table(t), n = r.schema, i = {}, a = []; function o(h, b, m) { var g = St(h), C = i[g] = i[g] || [], _ = h == null ? 0 : typeof h == "string" ? 1 : h.length, y = b > 0, S = B(B({}, m), { isVirtual: y, keyTail: b, keyLength: _, extractKey: Yr(h), unique: !y && m.unique }); if (C.push(S), S.isPrimaryKey || a.push(S), _ > 1) { var R = _ === 2 ? h[0] : h.slice(0, _ - 1); o(R, b + 1, m) } return C.sort(function (T, O) { return T.keyTail - O.keyTail }), S } var u = o(n.primaryKey.keyPath, 0, n.primaryKey); i[":id"] = [u]; for (var s = 0, c = n.indexes; s < c.length; s++) { var l = c[s]; o(l.keyPath, 0, l) } function f(h) { var b = i[St(h)]; return b && b[0] } function p(h, b) { return { type: h.type === 1 ? 2 : h.type, lower: Gt(h.lower, h.lowerOpen ? e.MAX_KEY : e.MIN_KEY, b), lowerOpen: !0, upper: Gt(h.upper, h.upperOpen ? e.MIN_KEY : e.MAX_KEY, b), upperOpen: !0 } } function v(h) { var b = h.query.index; return b.isVirtual ? B(B({}, h), { query: { index: b, range: p(h.query.range, b.keyTail) } }) : h } var d = B(B({}, r), { schema: B(B({}, n), { primaryKey: u, indexes: a, getIndexByKeyPath: f }), count: function (h) { return r.count(v(h)) }, query: function (h) { return r.query(v(h)) }, openCursor: function (h) { var b = h.query.index, m = b.keyTail, g = b.isVirtual, C = b.keyLength; if (!g) return r.openCursor(h); function _(y) { function S(T) { T != null ? y.continue(Gt(T, h.reverse ? e.MAX_KEY : e.MIN_KEY, m)) : h.unique ? y.continue(y.key.slice(0, C).concat(h.reverse ? e.MIN_KEY : e.MAX_KEY, m)) : y.continue() } var R = Object.create(y, { continue: { value: S }, continuePrimaryKey: { value: function (T, O) { y.continuePrimaryKey(Gt(T, e.MAX_KEY, m), O) } }, primaryKey: { get: function () { return y.primaryKey } }, key: { get: function () { var T = y.key; return C === 1 ? T[0] : T.slice(0, C) } }, value: { get: function () { return y.value } } }); return R } return r.openCursor(v(h)).then(function (y) { return y && _(y) }) } }); return d } }) } var hs = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: ds }; function xn(e, t, r, n) { return r = r || {}, n = n || "", H(e).forEach(function (i) { if (!me(t, i)) r[n + i] = void 0; else { var a = e[i], o = t[i]; if (typeof a == "object" && typeof o == "object" && a && o) { var u = Br(a), s = Br(o); u !== s ? r[n + i] = t[i] : u === "Object" ? xn(a, o, r, n + i + ".") : a !== o && (r[n + i] = t[i]) } else a !== o && (r[n + i] = t[i]) } }), H(t).forEach(function (i) { me(e, i) || (r[n + i] = t[i]) }), r } function vs(e, t) { return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey) } var ms = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function (e) { return B(B({}, e), { table: function (t) { var r = e.table(t), n = r.schema.primaryKey, i = B(B({}, r), { mutate: function (a) { var o = D.trans, u = o.table(t).hook, s = u.deleting, c = u.creating, l = u.updating; switch (a.type) { case "add": if (c.fire === U) break; return o._promise("readwrite", function () { return f(a) }, !0); case "put": if (c.fire === U && l.fire === U) break; return o._promise("readwrite", function () { return f(a) }, !0); case "delete": if (s.fire === U) break; return o._promise("readwrite", function () { return f(a) }, !0); case "deleteRange": if (s.fire === U) break; return o._promise("readwrite", function () { return p(a) }, !0) }return r.mutate(a); function f(d) { var h = D.trans, b = d.keys || vs(n, d); if (!b) throw new Error("Keys missing"); return d = d.type === "add" || d.type === "put" ? B(B({}, d), { keys: b }) : B({}, d), d.type !== "delete" && (d.values = Mr([], d.values, !0)), d.keys && (d.keys = Mr([], d.keys, !0)), ys(r, d, b).then(function (m) { var g = b.map(function (C, _) { var y = m[_], S = { onerror: null, onsuccess: null }; if (d.type === "delete") s.fire.call(S, C, y, h); else if (d.type === "add" || y === void 0) { var R = c.fire.call(S, C, d.values[_], h); C == null && R != null && (C = R, d.keys[_] = C, n.outbound || _e(d.values[_], n.keyPath, C)) } else { var T = xn(y, d.values[_]), O = l.fire.call(S, T, C, y, h); if (O) { var k = d.values[_]; Object.keys(O).forEach(function (N) { me(k, N) ? k[N] = O[N] : _e(k, N, O[N]) }) } } return S }); return r.mutate(d).then(function (C) { for (var _ = C.failures, y = C.results, S = C.numFailures, R = C.lastResult, T = 0; T < b.length; ++T) { var O = y ? y[T] : b[T], k = g[T]; O == null ? k.onerror && k.onerror(_[T]) : k.onsuccess && k.onsuccess(d.type === "put" && m[T] ? d.values[T] : O) } return { failures: _, results: y, numFailures: S, lastResult: R } }).catch(function (C) { return g.forEach(function (_) { return _.onerror && _.onerror(C) }), Promise.reject(C) }) }) } function p(d) { return v(d.trans, d.range, 1e4) } function v(d, h, b) { return r.query({ trans: d, values: !1, query: { index: n, range: h }, limit: b }).then(function (m) { var g = m.result; return f({ type: "delete", keys: g, trans: d }).then(function (C) { return C.numFailures > 0 ? Promise.reject(C.failures[0]) : g.length < b ? { failures: [], numFailures: 0, lastResult: void 0 } : v(d, B(B({}, h), { lower: g[g.length - 1], lowerOpen: !0 }), b) }) }) } } }); return i } }) } }; function ys(e, t, r) { return t.type === "add" ? Promise.resolve([]) : e.getMany({ trans: t.trans, keys: r, cache: "immutable" }) } function Xi(e, t, r) { try { if (!t || t.keys.length < e.length) return null; for (var n = [], i = 0, a = 0; i < t.keys.length && a < e.length; ++i)se(t.keys[i], e[a]) === 0 && (n.push(r ? At(t.values[i]) : t.values[i]), ++a); return n.length === e.length ? n : null } catch { return null } } var gs = { stack: "dbcore", level: -1, create: function (e) { return { table: function (t) { var r = e.table(t); return B(B({}, r), { getMany: function (n) { if (!n.cache) return r.getMany(n); var i = Xi(n.keys, n.trans._cache, n.cache === "clone"); return i ? E.resolve(i) : r.getMany(n).then(function (a) { return n.trans._cache = { keys: n.keys, values: n.cache === "clone" ? At(a) : a }, a }) }, mutate: function (n) { return n.type !== "add" && (n.trans._cache = null), r.mutate(n) } }) } } } }, Or; function Dn(e) { return !("from" in e) } var Re = function (e, t) { if (this) ce(this, arguments.length ? { d: 1, from: e, to: arguments.length > 1 ? t : e } : { d: 0 }); else { var r = new Re; return e && "d" in e && ce(r, e), r } }; st(Re.prototype, (Or = { add: function (e) { return hr(this, e), this }, addKey: function (e) { return wt(this, e, e), this }, addKeys: function (e) { var t = this; return e.forEach(function (r) { return wt(t, r, r) }), this } }, Or[Fr] = function () { return rn(this) }, Or)); function wt(e, t, r) { var n = se(t, r); if (!isNaN(n)) { if (n > 0) throw RangeError(); if (Dn(e)) return ce(e, { from: t, to: r, d: 1 }); var i = e.l, a = e.r; if (se(r, e.from) < 0) return i ? wt(i, t, r) : e.l = { from: t, to: r, d: 1, l: null, r: null }, qn(e); if (se(t, e.to) > 0) return a ? wt(a, t, r) : e.r = { from: t, to: r, d: 1, l: null, r: null }, qn(e); se(t, e.from) < 0 && (e.from = t, e.l = null, e.d = a ? a.d + 1 : 1), se(r, e.to) > 0 && (e.to = r, e.r = null, e.d = e.l ? e.l.d + 1 : 1); var o = !e.r; i && !e.l && hr(e, i), a && o && hr(e, a) } } function hr(e, t) { function r(n, i) { var a = i.from, o = i.to, u = i.l, s = i.r; wt(n, a, o), u && r(n, u), s && r(n, s) } Dn(t) || r(e, t) } function bs(e, t) { var r = rn(t), n = r.next(); if (n.done) return !1; for (var i = n.value, a = rn(e), o = a.next(i.from), u = o.value; !n.done && !o.done;) { if (se(u.from, i.to) <= 0 && se(u.to, i.from) >= 0) return !0; se(i.from, u.from) < 0 ? i = (n = r.next(u.from)).value : u = (o = a.next(i.from)).value } return !1 } function rn(e) { var t = Dn(e) ? null : { s: 0, n: e }; return { next: function (r) { for (var n = arguments.length > 0; t;)switch (t.s) { case 0: if (t.s = 1, n) for (; t.n.l && se(r, t.n.from) < 0;)t = { up: t, n: t.n.l, s: 1 }; else for (; t.n.l;)t = { up: t, n: t.n.l, s: 1 }; case 1: if (t.s = 2, !n || se(r, t.n.to) <= 0) return { value: t.n, done: !1 }; case 2: if (t.n.r) { t.s = 3, t = { up: t, n: t.n.r, s: 0 }; continue } case 3: t = t.up }return { done: !0 } } } } function qn(e) { var t, r, n = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((r = e.l) === null || r === void 0 ? void 0 : r.d) || 0), i = n > 1 ? "r" : n < -1 ? "l" : ""; if (i) { var a = i === "r" ? "l" : "r", o = B({}, e), u = e[i]; e.from = u.from, e.to = u.to, e[i] = u[i], o[i] = u[a], e[a] = o, o.d = Wn(o) } e.d = Wn(e) } function Wn(e) { var t = e.r, r = e.l; return (t ? r ? Math.max(t.d, r.d) : t.d : r ? r.d : 0) + 1 } var _s = { stack: "dbcore", level: 0, create: function (e) { var t = e.schema.name, r = new Re(e.MIN_KEY, e.MAX_KEY); return B(B({}, e), { table: function (n) { var i = e.table(n), a = i.schema, o = a.primaryKey, u = o.extractKey, s = o.outbound, c = B(B({}, i), { mutate: function (p) { var v = p.trans, d = v.mutatedParts || (v.mutatedParts = {}), h = function (R) { var T = "idb://" + t + "/" + n + "/" + R; return d[T] || (d[T] = new Re) }, b = h(""), m = h(":dels"), g = p.type, C = p.type === "deleteRange" ? [p.range] : p.type === "delete" ? [p.keys] : p.values.length < 50 ? [[], p.values] : [], _ = C[0], y = C[1], S = p.trans._cache; return i.mutate(p).then(function (R) { if (ie(_)) { g !== "delete" && (_ = R.results), b.addKeys(_); var T = Xi(_, S); !T && g !== "add" && m.addKeys(_), (T || y) && Cs(h, a, T, y) } else if (_) { var O = { from: _.lower, to: _.upper }; m.add(O), b.add(O) } else b.add(r), m.add(r), a.indexes.forEach(function (k) { return h(k.name).add(r) }); return R }) } }), l = function (p) { var v, d, h = p.query, b = h.index, m = h.range; return [b, new Re((v = m.lower) !== null && v !== void 0 ? v : e.MIN_KEY, (d = m.upper) !== null && d !== void 0 ? d : e.MAX_KEY)] }, f = { get: function (p) { return [o, new Re(p.key)] }, getMany: function (p) { return [o, new Re().addKeys(p.keys)] }, count: l, query: l, openCursor: l }; return H(f).forEach(function (p) { c[p] = function (v) { var d = D.subscr; if (d) { var h = function (S) { var R = "idb://" + t + "/" + n + "/" + S; return d[R] || (d[R] = new Re) }, b = h(""), m = h(":dels"), g = f[p](v), C = g[0], _ = g[1]; if (h(C.name || "").add(_), !C.isPrimaryKey) if (p === "count") m.add(r); else { var y = p === "query" && s && v.values && i.query(B(B({}, v), { values: !1 })); return i[p].apply(this, arguments).then(function (S) { if (p === "query") { if (s && v.values) return y.then(function (k) { var N = k.result; return b.addKeys(N), S }); var R = v.values ? S.result.map(u) : S.result; v.values ? b.addKeys(R) : m.addKeys(R) } else if (p === "openCursor") { var T = S, O = v.values; return T && Object.create(T, { key: { get: function () { return m.addKey(T.primaryKey), T.key } }, primaryKey: { get: function () { var k = T.primaryKey; return m.addKey(k), k } }, value: { get: function () { return O && b.addKey(T.primaryKey), T.value } } }) } return S }) } } return i[p].apply(this, arguments) } }), c } }) } }; function Cs(e, t, r, n) { function i(a) { var o = e(a.name || ""); function u(c) { return c != null ? a.extractKey(c) : null } var s = function (c) { return a.multiEntry && ie(c) ? c.forEach(function (l) { return o.addKey(l) }) : o.addKey(c) }; (r || n).forEach(function (c, l) { var f = r && u(r[l]), p = n && u(n[l]); se(f, p) !== 0 && (f != null && s(f), p != null && s(p)) }) } t.indexes.forEach(i) } var wn = function () { function e(t, r) { var n = this; this._middlewares = {}, this.verno = 0; var i = e.dependencies; this._options = r = B({ addons: e.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange }, r), this._deps = { indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange }; var a = r.addons; this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this; var o = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: U, dbReadyPromise: null, cancelOpen: U, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 }; o.dbReadyPromise = new E(function (u) { o.dbReadyResolve = u }), o.openCanceller = new E(function (u, s) { o.cancelOpen = s }), this._state = o, this.name = t, this.on = Bt(this, "populate", "blocked", "versionchange", "close", { ready: [gn, U] }), this.on.ready.subscribe = ki(this.on.ready.subscribe, function (u) { return function (s, c) { e.vip(function () { var l = n._state; if (l.openComplete) l.dbOpenError || E.resolve().then(s), c && u(s); else if (l.onReadyBeingFired) l.onReadyBeingFired.push(s), c && u(s); else { u(s); var f = n; c || u(function p() { f.on.ready.unsubscribe(s), f.on.ready.unsubscribe(p) }) } }) } }), this.Collection = Bo(this), this.Table = Oo(this), this.Transaction = Go(this), this.Version = os(this), this.WhereClause = zo(this), this.on("versionchange", function (u) { u.newVersion > 0 ? console.warn("Another connection wants to upgrade database '" + n.name + "'. Closing db now to resume the upgrade.") : console.warn("Another connection wants to delete database '" + n.name + "'. Closing db now to resume the delete request."), n.close() }), this.on("blocked", function (u) { !u.newVersion || u.newVersion < u.oldVersion ? console.warn("Dexie.delete('" + n.name + "') was blocked") : console.warn("Upgrade '" + n.name + "' blocked by other connection holding version " + u.oldVersion / 10) }), this._maxKey = Dt(r.IDBKeyRange), this._createTransaction = function (u, s, c, l) { return new n.Transaction(u, s, c, n._options.chromeTransactionDurability, l) }, this._fireOnBlocked = function (u) { n.on("blocked").fire(u), Ct.filter(function (s) { return s.name === n.name && s !== n && !s._state.vcFired }).map(function (s) { return s.on("versionchange").fire(u) }) }, this.use(hs), this.use(ms), this.use(_s), this.use(gs), this.vip = Object.create(this, { _vip: { value: !0 } }), a.forEach(function (u) { return u(n) }) } return e.prototype.version = function (t) { if (isNaN(t) || t < .1) throw new I.Type("Given version is not a positive number"); if (t = Math.round(t * 10) / 10, this.idbdb || this._state.isBeingOpened) throw new I.Schema("Cannot add version when database is open"); this.verno = Math.max(this.verno, t); var r = this._versions, n = r.filter(function (i) { return i._cfg.version === t })[0]; return n || (n = new this.Version(t), r.push(n), r.sort(Qo), n.stores({}), this._state.autoSchema = !1, n) }, e.prototype._whenReady = function (t) { var r = this; return this.idbdb && (this._state.openComplete || D.letThrough || this._vip) ? t() : new E(function (n, i) { if (r._state.openComplete) return i(new I.DatabaseClosed(r._state.dbOpenError)); if (!r._state.isBeingOpened) { if (!r._options.autoOpen) { i(new I.DatabaseClosed); return } r.open().catch(U) } r._state.dbReadyPromise.then(n, i) }).then(t) }, e.prototype.use = function (t) { var r = t.stack, n = t.create, i = t.level, a = t.name; a && this.unuse({ stack: r, name: a }); var o = this._middlewares[r] || (this._middlewares[r] = []); return o.push({ stack: r, create: n, level: i == null ? 10 : i, name: a }), o.sort(function (u, s) { return u.level - s.level }), this }, e.prototype.unuse = function (t) { var r = t.stack, n = t.name, i = t.create; return r && this._middlewares[r] && (this._middlewares[r] = this._middlewares[r].filter(function (a) { return i ? a.create !== i : n ? a.name !== n : !1 })), this }, e.prototype.open = function () { return fs(this) }, e.prototype._close = function () { var t = this._state, r = Ct.indexOf(this); if (r >= 0 && Ct.splice(r, 1), this.idbdb) { try { this.idbdb.close() } catch { } this._novip.idbdb = null } t.dbReadyPromise = new E(function (n) { t.dbReadyResolve = n }), t.openCanceller = new E(function (n, i) { t.cancelOpen = i }) }, e.prototype.close = function () { this._close(); var t = this._state; this._options.autoOpen = !1, t.dbOpenError = new I.DatabaseClosed, t.isBeingOpened && t.cancelOpen(t.dbOpenError) }, e.prototype.delete = function () { var t = this, r = arguments.length > 0, n = this._state; return new E(function (i, a) { var o = function () { t.close(); var u = t._deps.indexedDB.deleteDatabase(t.name); u.onsuccess = G(function () { us(t._deps, t.name), i() }), u.onerror = Ce(a), u.onblocked = t._fireOnBlocked }; if (r) throw new I.InvalidArgument("Arguments not allowed in db.delete()"); n.isBeingOpened ? n.dbReadyPromise.then(o) : o() }) }, e.prototype.backendDB = function () { return this.idbdb }, e.prototype.isOpen = function () { return this.idbdb !== null }, e.prototype.hasBeenClosed = function () { var t = this._state.dbOpenError; return t && t.name === "DatabaseClosed" }, e.prototype.hasFailed = function () { return this._state.dbOpenError !== null }, e.prototype.dynamicallyOpened = function () { return this._state.autoSchema }, Object.defineProperty(e.prototype, "tables", { get: function () { var t = this; return H(this._allTables).map(function (r) { return t._allTables[r] }) }, enumerable: !1, configurable: !0 }), e.prototype.transaction = function () { var t = ps.apply(this, arguments); return this._transaction.apply(this, t) }, e.prototype._transaction = function (t, r, n) { var i = this, a = D.trans; (!a || a.db !== this || t.indexOf("!") !== -1) && (a = null); var o = t.indexOf("?") !== -1; t = t.replace("!", "").replace("?", ""); var u, s; try { if (s = r.map(function (l) { var f = l instanceof i.Table ? l.name : l; if (typeof f != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed"); return f }), t == "r" || t === Rr) u = Rr; else if (t == "rw" || t == Er) u = Er; else throw new I.InvalidArgument("Invalid transaction mode: " + t); if (a) { if (a.mode === Rr && u === Er) if (o) a = null; else throw new I.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY"); a && s.forEach(function (l) { if (a && a.storeNames.indexOf(l) === -1) if (o) a = null; else throw new I.SubTransaction("Table " + l + " not included in parent transaction.") }), o && a && !a.active && (a = null) } } catch (l) { return a ? a._promise(null, function (f, p) { p(l) }) : q(l) } var c = Qi.bind(null, this, u, s, a, n); return a ? a._promise(u, c, "lock") : D.trans ? ft(D.transless, function () { return i._whenReady(c) }) : this._whenReady(c) }, e.prototype.table = function (t) { if (!me(this._allTables, t)) throw new I.InvalidTable("Table " + t + " does not exist"); return this._allTables[t] }, e }(), Ss = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ts = function () { function e(t) { this._subscribe = t } return e.prototype.subscribe = function (t, r, n) { return this._subscribe(!t || typeof t == "function" ? { next: t, error: r, complete: n } : t) }, e.prototype[Ss] = function () { return this }, e }(); function Zi(e, t) { return H(t).forEach(function (r) { var n = e[r] || (e[r] = new Re); hr(n, t[r]) }), e } function ks(e) { return new Ts(function (t) { var r = vn(e); function n(v) { r && lt(); var d = function () { return Le(e, { subscr: v, trans: null }) }, h = D.trans ? ft(D.transless, d) : d(); return r && h.then(Ie, Ie), h } var i = !1, a = {}, o = {}, u = { get closed() { return i }, unsubscribe: function () { i = !0, ze.storagemutated.unsubscribe(f) } }; t.start && t.start(u); var s = !1, c = !1; function l() { return H(o).some(function (v) { return a[v] && bs(a[v], o[v]) }) } var f = function (v) { Zi(a, v), l() && p() }, p = function () { if (!(s || i)) { a = {}; var v = {}, d = n(v); c || (ze(xt, f), c = !0), s = !0, Promise.resolve(d).then(function (h) { s = !1, !i && (l() ? p() : (a = {}, o = v, t.next && t.next(h))) }, function (h) { s = !1, t.error && t.error(h), u.unsubscribe() }) } }; return p(), u }) } var nn; try { nn = { indexedDB: $.indexedDB || $.mozIndexedDB || $.webkitIndexedDB || $.msIndexedDB, IDBKeyRange: $.IDBKeyRange || $.webkitIDBKeyRange } } catch { nn = { indexedDB: null, IDBKeyRange: null } } var Je = wn; st(Je, B(B({}, Cr), { delete: function (e) { var t = new Je(e, { addons: [] }); return t.delete() }, exists: function (e) { return new Je(e, { addons: [] }).open().then(function (t) { return t.close(), !0 }).catch("NoSuchDatabaseError", function () { return !1 }) }, getDatabaseNames: function (e) { try { return ss(Je.dependencies).then(e) } catch { return q(new I.MissingAPI) } }, defineClass: function () { function e(t) { ce(this, t) } return e }, ignoreTransaction: function (e) { return D.trans ? ft(D.transless, e) : e() }, vip: en, async: function (e) { return function () { try { var t = tn(e.apply(this, arguments)); return !t || typeof t.then != "function" ? E.resolve(t) : t } catch (r) { return q(r) } } }, spawn: function (e, t, r) { try { var n = tn(e.apply(r, t || [])); return !n || typeof n.then != "function" ? E.resolve(n) : n } catch (i) { return q(i) } }, currentTransaction: { get: function () { return D.trans || null } }, waitFor: function (e, t) { var r = E.resolve(typeof e == "function" ? Je.ignoreTransaction(e) : e).timeout(t || 6e4); return D.trans ? D.trans.waitFor(r) : r }, Promise: E, debug: { get: function () { return Se }, set: function (e) { wi(e, e === "dexie" ? function () { return !0 } : Gi) } }, derive: ct, extend: ce, props: st, override: ki, Events: Bt, on: ze, liveQuery: ks, extendObservabilitySet: Zi, getByKeyPath: we, setByKeyPath: _e, delByKeyPath: to, shallowClone: Ei, deepClone: At, getObjectDiff: xn, cmp: se, asap: Pi, minKey: qr, addons: [], connections: Ct, errnames: yn, dependencies: nn, semVer: zn, version: zn.split(".").map(function (e) { return parseInt(e) }).reduce(function (e, t, r) { return e + t / Math.pow(10, r * 2) }) })); Je.maxKey = Dt(Je.dependencies.IDBKeyRange); typeof dispatchEvent < "u" && typeof addEventListener < "u" && (ze(xt, function (e) { if (!xe) { var t; Sr ? (t = document.createEvent("CustomEvent"), t.initCustomEvent(Ne, !0, !0, e)) : t = new CustomEvent(Ne, { detail: e }), xe = !0, dispatchEvent(t), xe = !1 } }), addEventListener(Ne, function (e) { var t = e.detail; xe || vr(t) })); function vr(e) { var t = xe; try { xe = !0, ze.storagemutated.fire(e) } finally { xe = t } } var xe = !1; if (typeof BroadcastChannel < "u") { var Yn = new BroadcastChannel(Ne); ze(xt, function (e) { xe || Yn.postMessage(e) }), Yn.onmessage = function (e) { e.data && vr(e.data) } } else if (typeof self < "u" && typeof navigator < "u") { ze(xt, function (e) { try { xe || (typeof localStorage < "u" && localStorage.setItem(Ne, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && Mr([], self.clients.matchAll({ includeUncontrolled: !0 }), !0).forEach(function (t) { return t.postMessage({ type: Ne, changedParts: e }) })) } catch { } }), typeof addEventListener < "u" && addEventListener("storage", function (e) { if (e.key === Ne) { var t = JSON.parse(e.newValue); t && vr(t.changedParts) } }); var Qn = self.document && navigator.serviceWorker; Qn && Qn.addEventListener("message", Ps) } function Ps(e) { var t = e.data; t && t.type === Ne && vr(t.changedParts) } E.rejectionMapper = lo; wi(Se, Gi); class Rs { constructor(t, r, n, i, a, o, u, s, c, l, f, p, v, d) { P(this, "id"); P(this, "brand"); P(this, "material"); P(this, "color"); P(this, "cost"); P(this, "currency"); P(this, "status"); P(this, "weightTotal"); P(this, "weightPrinted"); P(this, "density"); P(this, "diameter"); P(this, "dateBought"); P(this, "nozzleTemperature"); P(this, "bedTemperature"); P(this, "filamentDepletedCutoff"); this.id = t, this.brand = r, this.material = n, this.color = i, this.cost = a, this.currency = o, this.status = "loaded", this.weightTotal = u, this.weightPrinted = s, this.diameter = l, this.density = c, this.dateBought = f, this.nozzleTemperature = p, this.bedTemperature = v, this.filamentDepletedCutoff = d, this.weightTotal - this.weightPrinted < this.filamentDepletedCutoff && (this.status = "depleted") } get name() { return `${this.brand} ${this.material}` } get percentRemaining() { return Math.round((this.weightTotal - this.weightPrinted) / this.weightTotal * 100) } get percentPrinted() { return Math.round(this.weightPrinted / this.weightTotal * 100) } get weightRemaining() { return this.weightTotal - this.weightPrinted } get costPrinted() { return this.cost - this.percentRemaining * this.cost } get costRemaining() { return this.percentRemaining * this.cost } save(t) { j.filaments.update(this.id, t) } add() { j.filaments.add(this) } remove() { j.filaments.delete(this.id) } toString() { return `${this.brand} ${this.material} status: ${this.status}` } } class ea { constructor(t, r, n, i, a, o) { P(this, "id"); P(this, "fileName"); P(this, "parentDir"); P(this, "isWorkSpaceFile"); P(this, "type"); P(this, "uploaderName"); P(this, "fileContent"); this.id = t, this.fileName = r, this.parentDir = n, this.isWorkSpaceFile = i, this.uploaderName = a, this.type = o } save(t) { j.nanofactoryFiles.update(this.id, t) } add() { j.nanofactoryFiles.add(this) } remove() { j.nanofactoryFiles.delete(this.id) } } class ta { constructor(t) { P(this, "id"); P(this, "peerID"); P(this, "apiKey"); this.id = t } async save(t) { await j.networking.update(this.id, t) } async add() { await j.networking.add(this) } remove() { j.networking.delete(this.id) } } var ra = (e => (e.AVAILABLE = "available", e.WHITELISTED = "whitelisted", e.BLACKLISTED = "blacklisted", e))(ra || {}); class na { constructor() { P(this, "id"); P(this, "whitelisted"); P(this, "blacklisted"); P(this, "available"); this.id = "1", this.whitelisted = new Set([]), this.blacklisted = new Set([]), this.available = new Set([]) } async save(t) { await j.nanofactoryPeers.update(this.id, t) } async add() { await j.nanofactoryPeers.add(this) } remove() { j.nanofactoryPeers.delete(this.id) } async addToList(t, r) { this[t].add(r), t === "whitelisted" && this.available.add(r), await j.nanofactoryPeers.put(this, this.id) } async removeFromList(t, r) { console.log("remove from list called"), console.log(this[t].size), this[t].delete(r), console.log(this[t].size), await j.nanofactoryPeers.put(this, this.id) } } var nt = (e => (e.operational = "Operational", e.offline = "Offline", e.printing = "Printing", e.error = "Error", e.paused = "Paused", e))(nt || {}); class ia { constructor(t) { P(this, "id"); P(this, "name"); P(this, "color"); P(this, "model"); P(this, "volume"); P(this, "heatedBed"); P(this, "heatedChamber"); P(this, "axes"); P(this, "extruder"); P(this, "state"); P(this, "bedLevellingGraph"); P(this, "position"); P(this, "connectionOptions"); P(this, "temperatureHistory"); P(this, "filamentID"); P(this, "isQueuePaused"); P(this, "queuePausedReason"); P(this, "nanofactoryInstallDate"); this.id = t, this.name = "", this.model = "", this.volume = { formFactor: "rectangular", centerOrigin: "center", width: 0, depth: 0, height: 0 }, this.heatedBed = !0, this.heatedChamber = !1, this.nanofactoryInstallDate = new Date, this.state = { status: "Offline" }, this.connectionOptions = { ports: [], baudrates: [], printerProfiles: [], portPreference: "auto", baudratePreference: "auto", printerProfilePreference: "_default", autoconnect: !1 }, this.temperatureHistory = [], this.axes = { x: { inverted: !1, speed: 0 }, y: { inverted: !1, speed: 0 }, z: { inverted: !1, speed: 0 }, e: { inverted: !1, speed: 0 } }, this.extruder = { count: 1, offsets: [] }, this.position = { x: 0, y: 0, z: 0, e: 0, relative: !1, speed: 0 }, this.filamentID = "", this.isQueuePaused = !0, this.queuePausedReason = "Printer has not been assigned a job" } async save(t) { await j.printer.update(this.id, t) } async add() { await j.printer.add(this) } remove() { j.printer.delete(this.id) } toString() { return `${this.model} ${this.name} status: ${this.state.status}` } } var mr = (e => (e.TOPRINT = "To Print", e.PRINTING = "Printing", e.DONE = "Done", e.FAILED = "Failed", e.CANCELLED = "Cancelled", e))(mr || {}); class aa { constructor(t, r, n, i, a, o, u, s, c, l) { P(this, "id"); P(this, "printerID"); P(this, "jobName"); P(this, "status"); P(this, "assignerName"); P(this, "estimatedPrintTime"); P(this, "lastPrintTime"); P(this, "estimatedFilamentUsage"); P(this, "actualFilamentUsage"); P(this, "progress"); P(this, "createdDate"); P(this, "startTime"); P(this, "endTime"); P(this, "queuePosition"); P(this, "file"); P(this, "filamentID"); this.id = t, this.printerID = r, this.jobName = n, this.status = "To Print", this.assignerName = i, this.estimatedPrintTime = a != null ? a : 0, this.estimatedFilamentUsage = o != null ? o : { length: 0, volume: 0 }, this.actualFilamentUsage = { length: 0, volume: 0 }, this.createdDate = u != null ? u : new Date, this.progress = { completion: 0, filePosition: 0, printTime: 0, printTimeLeft: 0 }, this.queuePosition = s, this.file = c, this.filamentID = l } async calculatePosition() { let t = 0, r = await j.printJobs.reverse().sortBy("queuePosition"); r.length > 0 && (t = r[0].queuePosition), this.queuePosition = t + 1 } async add() { await this.calculatePosition(), j.printJobs.add(this) } remove() { j.printJobs.delete(this.id) } save(t) { j.printJobs.update(this.id, t) } async getEstimatedFilamentWeight() { let t = await j.filaments.get(this.filamentID); return t ? t.density * this.estimatedFilamentUsage.volume : 0 } async getUsedFilamentWeight() { let t = await j.filaments.get(this.filamentID); return t ? t.density * this.actualFilamentUsage.volume : 0 } toString() { return `${this.jobName}` } } class Es extends wn { constructor() { super("NanofactoryDatabase"); P(this, "printer"); P(this, "networking"); P(this, "printJobs"); P(this, "filaments"); P(this, "nanofactoryFiles"); P(this, "nanofactoryPeers"); this.version(1.1).stores({ printer: "id", networking: "id, peerID, apiKey", printJobs: "id,filamentID", filaments: "id", nanofactoryFiles: "id, filename", nanofactoryPeers: "id, available, whitelisted, blacklisted" }), this.version(1).stores({ printer: "id", networking: "id, peerID, apiKey", printJobs: "id,filamentID", filaments: "id", nanofactoryFiles: "id, filename" }), this.printer.mapToClass(ia), this.networking.mapToClass(ta), this.printJobs.mapToClass(aa), this.filaments.mapToClass(Rs), this.nanofactoryFiles.mapToClass(ea), this.nanofactoryPeers.mapToClass(na) } } let j; async function xs() { j = new Es, j.open() } async function Ds() { try { let t = await fetch("http://localhost:5000/api/printer?history=true&limit=" + 50, { method: "GET", headers: { "X-API-KEY": V.apiKey } }); return t.ok ? await t.json() : { state: { text: "Offline" } } } catch { return { state: { text: "Offline" } } } } let ge = ""; async function ws(e, t, r, n, i) { switch (r) { case w.jobCreated: let a = new ea(n.file.id, n.file.fileName, n.file.parentDir, n.file.isWorkspaceFile, n.file.uploaderName, n.file.type); a.fileContent = new Blob([i], { type: "text/plain;charset=utf-8" }); let o = new aa(n.id, n.printerID, n.jobName, n.assignerName, n.estimatedPrintTime, n.estimatedFilamentUsage, n.createdDate, n.queuePosition, a, n.filamentID); a.add(), o.add(), await OctoPrint.files.upload("local", new File([a.fileContent], n.jobName + ".gcode")), (await j.printer.toArray())[0].state.status === nt.operational && (ge = n.id, o.save({ startTime: new Date().toISOString(), status: mr.PRINTING }), OctoPrint.files.select("local", n.jobName + ".gcode", !0)); break; case w.currentJobUpdatesRequest: Os(t); break; case w.currentJobUpdatesStop: at[t].close(); break; case w.jobCancelled: let u = await j.printJobs.get(e.id); u && (ge == u.id && OctoPrint.job.cancel(), u.save({ status: mr.CANCELLED })); break; case w.jobDeleted: let s = await j.printJobs.get(e.id); s && s.remove(); break; case w.jobRankChange: let c = await j.printJobs.get(e.id); c && c.save({ queuePosition: e.queuePosition }); break; case w.jobPause: OctoPrint.job.pause(); break; case w.jobResume: OctoPrint.job.resume(); break } } function Os(e) { const t = { label: w.currentJobUpdatesResponse, metadata: e, serialization: "json", reliable: !0 }; let r = ve.connect(e, t); r.on("open", function () { console.log("jobProgress connection is open " + e), at[e] = r }), r.on("close", function () { delete at[e] }), r.on("error", function () { delete at[e] }) } function As() { ge = "" } async function Is(e, t, r, n) { switch (r) { case w.connectPrinter: Ks(e.port, e.baudrate, e.autoconnect, e.save); break; case w.disconnectPrinter: OctoPrint.connection.disconnect(); break; case w.executeCustomGcode: OctoPrint.control.sendGcode(e.data); break; case w.temperatureStreamRequest: Fs(t); break; case w.temperatureStreamStop: Oe[t].close(); break; case w.filamentExtrude: OctoPrint.printer.extrude(e.data); break; case w.home: OctoPrint.printer.home(e.axes); break; case w.terminalRequest: Ns(t); break; case w.terminalStop: ot[t].close(); break } } async function Ms() { let e = await OctoPrint.printerprofiles.get("_default"); e.id = ve.id, delete e.default, delete e.current, delete e.resource, await He.save(e) } async function js() { await He.save({ connectionOptions: (await OctoPrint.connection.getSettings()).options }) } async function Bs() { let e = await Ds(), t = await j.printer.get(V.peerID), r = { state: { status: oa(e.state.text) } }; if ("temperature" in e && (r.temperatureHistory = e.temperature.history, Object.keys(Oe).length > 0)) { let n = r.temperatureHistory.filter(({ time: i }) => !(t != null && t.temperatureHistory.some(({ time: a }) => a === i))); if (n) for (let i in Oe) Oe[i].send(JSON.stringify({ data: n })) } r.state.status !== (t == null ? void 0 : t.state.status) && qt(r.state, w.printerStateChanged), await He.save(r) } function oa(e) { return e.includes("Operational") ? nt.operational : e.includes("Printing") ? nt.printing : e.includes("Paused") ? nt.paused : nt.offline } function Fs(e) { const t = { label: w.temperatureStreamResponse, metadata: e, serialization: "json", reliable: !0 }; let r = ve.connect(e, t); r.on("open", function () { console.log("temperatureStream connection is open " + e), Oe[e] = r }), r.on("close", function () { delete Oe[e] }), r.on("error", function () { delete Oe[e] }) } async function Ks(e, t, r, n) { let i = { save: n, autoconnect: r }; e.toLowerCase().includes("auto") || (i.port = e), t.toLowerCase().includes("auto") || (i.baudrate = parseInt(t)), OctoPrint.connection.connect(i) } function Ns(e) { const t = { label: w.terminalResponse, metadata: e, serialization: "json", reliable: !0 }; let r = ve.connect(e, t); r.on("open", function () { console.log("terminalConnection is open " + e), ot[e] = r }), r.on("close", function () { delete ot[e] }), r.on("error", function () { delete ot[e] }) } async function Ls(e) { const t = { label: w.cameraStreamResponse, metadata: e, serialization: "binary", reliable: !0 }; let r = ve.connect(e, t); r.on("open", function () { console.log("cameraStream connection is open " + e), or[e] = r }), r.on("close", function () { delete or[e] }), r.on("error", function () { delete or[e] }) } var rt = (e => (e.CONNECTED = "connected", e.CURRENT = "current", e.HISTORY = "history", e.REAUTHREQUIRED = "reauthRequired", e.EVENT = "event", e))(rt || {}), tr = (e => (e.PRINTERSTATECHANGED = "PrinterStateChanged", e.PRINTSTARTED = "PrintStarted", e.PRINTDONE = "PrintDone", e))(tr || {}); const Us = [w.jobCreated, w.actionCreated, w.actionModified]; function zs(e, t, r, n) { let i = ""; switch (Us.includes(r) ? i = new TextDecoder("utf-8").decode(e) : e = JSON.parse(e), n = JSON.parse(n), r) { case w.syncAllRequest: $s(t); break; case w.connectPrinter: case w.disconnectPrinter: case w.executeCustomGcode: case w.temperatureStreamRequest: case w.temperatureStreamStop: case w.filamentExtrude: case w.home: case w.terminalRequest: case w.terminalStop: Is(e, t, r); break; case w.jobCreated: case w.currentJobUpdatesRequest: case w.currentJobUpdatesStop: case w.jobCancelled: case w.jobDeleted: case w.jobRankChange: case w.jobPause: case w.jobResume: ws(e, t, r, n, i); break; case w.handshakeRequest: Gs(t); break; case w.cameraStreamRequest: Ls(t); break; case w.cameraStreamStop: or[t].close(); break; default: console.log("Unhandled label: " + r); break } } async function $s(e) { let t = { printer_profile: {}, current_position: { x: 0, y: 0, z: 0, e: 0, speed: 0, relative: !1 }, bed_levelling_data: [], queue_state: { isQueuePaused: !1, queuePausedReason: "testing" }, current_job: { id: "" }, print_queue: [], jobs_history: [], current_filament: { current_filament: {} }, scripts: {} }; t.printer_profile = (await j.printer.toArray())[0], dn(e, t, w.syncAllResponse), br.addToList(ra.AVAILABLE, e) } async function Gs(e) { dn(e, { status: (await j.printer.toArray())[0].state.status }, w.handshakeResponse) } async function Js(e) { var t, r; switch (e.event) { case rt.CONNECTED: case rt.REAUTHREQUIRED: OctoPrint.browser.passiveLogin().done(function (i) { OctoPrint.socket.sendAuth(i.name, i.session) }); break; case rt.HISTORY: console.log(e); break; case rt.CURRENT: let n = await j.printer.get(V.peerID); if (ge && "job" in e.data && console.log(e), ge && "progress" in e.data) { let i = { data: { id: ge, progress: { completion: parseFloat(e.data.progress.completion).toFixed(1) }, estimatedFilamentUsage: (r = (t = e.data.job.filament) == null ? void 0 : t.tool0) != null ? r : { length: 0, volume: 0 }, actualFilamentUsage: { length: 0, volume: 0 } } }; if (i.data.progress.completion) for (let a in at) at[a].send(JSON.stringify(i)) } if ("temps" in e.data && e.data.temps.length > 0) { for (let i in Oe) Oe[i].send(JSON.stringify({ data: e.data.temps })); for (e.data.temps.forEach(i => { n == null || n.temperatureHistory.push(i) }); (n == null ? void 0 : n.temperatureHistory.length) > 50;)n == null || n.temperatureHistory.shift(); n == null || n.save({ temperatureHistory: n.temperatureHistory }) } if ("logs" in e.data) for (let i in ot) ot[i].send(JSON.stringify(e.data.logs)); break; case rt.EVENT: console.log(e), Vs(e); break; default: console.log("Unhandled socketEventType: ", e) } } async function Vs(e) { let t = await j.printer.get(V.peerID); switch (e.data.type) { case tr.PRINTERSTATECHANGED: let r = { status: oa(e.data.payload.state_string) }; t == null || t.save({ state: r }), qt(r, w.printerStateChanged); break; case tr.PRINTSTARTED: ge && qt({ data: { id: ge, startTime: new Date().toISOString() } }, w.jobPrinting); break; case tr.PRINTDONE: if (ge) { qt({ data: { id: ge, endTime: new Date().toISOString() } }, w.jobDone); let n = await j.printJobs.get(ge); n && n.save({ endTime: new Date().toISOString(), status: mr.DONE }), As() } break } } var On = { exports: {} }; (function (e) { var t = {}; t.useBlobBuilder = function () { try { return new Blob([]), !1 } catch { return !0 } }(), t.useArrayBufferView = !t.useBlobBuilder && function () { try { return new Blob([new Uint8Array([])]).size === 0 } catch { return !0 } }(), e.exports.binaryFeatures = t; var r = e.exports.BlobBuilder; typeof window < "u" && (r = e.exports.BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder || window.BlobBuilder); function n() { this._pieces = [], this._parts = [] } n.prototype.append = function (i) { typeof i == "number" ? this._pieces.push(i) : (this.flush(), this._parts.push(i)) }, n.prototype.flush = function () { if (this._pieces.length > 0) { var i = new Uint8Array(this._pieces); t.useArrayBufferView || (i = i.buffer), this._parts.push(i), this._pieces = [] } }, n.prototype.getBuffer = function () { if (this.flush(), t.useBlobBuilder) { for (var i = new r, a = 0, o = this._parts.length; a < o; a++)i.append(this._parts[a]); return i.getBlob() } else return new Blob(this._parts) }, e.exports.BufferBuilder = n })(On); var Hs = On.exports.BufferBuilder, Xn = On.exports.binaryFeatures, qs = { unpack: function (e) { var t = new Z(e); return t.unpack() }, pack: function (e) { var t = new ee; t.pack(e); var r = t.getBuffer(); return r } }, Zn = qs; function Z(e) { this.index = 0, this.dataBuffer = e, this.dataView = new Uint8Array(this.dataBuffer), this.length = this.dataBuffer.byteLength } Z.prototype.unpack = function () { var e = this.unpack_uint8(); if (e < 128) return e; if ((e ^ 224) < 32) return (e ^ 224) - 32; var t; if ((t = e ^ 160) <= 15) return this.unpack_raw(t); if ((t = e ^ 176) <= 15) return this.unpack_string(t); if ((t = e ^ 144) <= 15) return this.unpack_array(t); if ((t = e ^ 128) <= 15) return this.unpack_map(t); switch (e) { case 192: return null; case 193: return; case 194: return !1; case 195: return !0; case 202: return this.unpack_float(); case 203: return this.unpack_double(); case 204: return this.unpack_uint8(); case 205: return this.unpack_uint16(); case 206: return this.unpack_uint32(); case 207: return this.unpack_uint64(); case 208: return this.unpack_int8(); case 209: return this.unpack_int16(); case 210: return this.unpack_int32(); case 211: return this.unpack_int64(); case 212: return; case 213: return; case 214: return; case 215: return; case 216: return t = this.unpack_uint16(), this.unpack_string(t); case 217: return t = this.unpack_uint32(), this.unpack_string(t); case 218: return t = this.unpack_uint16(), this.unpack_raw(t); case 219: return t = this.unpack_uint32(), this.unpack_raw(t); case 220: return t = this.unpack_uint16(), this.unpack_array(t); case 221: return t = this.unpack_uint32(), this.unpack_array(t); case 222: return t = this.unpack_uint16(), this.unpack_map(t); case 223: return t = this.unpack_uint32(), this.unpack_map(t) } }; Z.prototype.unpack_uint8 = function () { var e = this.dataView[this.index] & 255; return this.index++, e }; Z.prototype.unpack_uint16 = function () { var e = this.read(2), t = (e[0] & 255) * 256 + (e[1] & 255); return this.index += 2, t }; Z.prototype.unpack_uint32 = function () { var e = this.read(4), t = ((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]; return this.index += 4, t }; Z.prototype.unpack_uint64 = function () { var e = this.read(8), t = ((((((e[0] * 256 + e[1]) * 256 + e[2]) * 256 + e[3]) * 256 + e[4]) * 256 + e[5]) * 256 + e[6]) * 256 + e[7]; return this.index += 8, t }; Z.prototype.unpack_int8 = function () { var e = this.unpack_uint8(); return e < 128 ? e : e - (1 << 8) }; Z.prototype.unpack_int16 = function () { var e = this.unpack_uint16(); return e < 32768 ? e : e - (1 << 16) }; Z.prototype.unpack_int32 = function () { var e = this.unpack_uint32(); return e < Math.pow(2, 31) ? e : e - Math.pow(2, 32) }; Z.prototype.unpack_int64 = function () { var e = this.unpack_uint64(); return e < Math.pow(2, 63) ? e : e - Math.pow(2, 64) }; Z.prototype.unpack_raw = function (e) { if (this.length < this.index + e) throw new Error("BinaryPackFailure: index is out of range " + this.index + " " + e + " " + this.length); var t = this.dataBuffer.slice(this.index, this.index + e); return this.index += e, t }; Z.prototype.unpack_string = function (e) { for (var t = this.read(e), r = 0, n = "", i, a; r < e;)i = t[r], i < 128 ? (n += String.fromCharCode(i), r++) : (i ^ 192) < 32 ? (a = (i ^ 192) << 6 | t[r + 1] & 63, n += String.fromCharCode(a), r += 2) : (a = (i & 15) << 12 | (t[r + 1] & 63) << 6 | t[r + 2] & 63, n += String.fromCharCode(a), r += 3); return this.index += e, n }; Z.prototype.unpack_array = function (e) { for (var t = new Array(e), r = 0; r < e; r++)t[r] = this.unpack(); return t }; Z.prototype.unpack_map = function (e) { for (var t = {}, r = 0; r < e; r++) { var n = this.unpack(), i = this.unpack(); t[n] = i } return t }; Z.prototype.unpack_float = function () { var e = this.unpack_uint32(), t = e >> 31, r = (e >> 23 & 255) - 127, n = e & 8388607 | 8388608; return (t === 0 ? 1 : -1) * n * Math.pow(2, r - 23) }; Z.prototype.unpack_double = function () { var e = this.unpack_uint32(), t = this.unpack_uint32(), r = e >> 31, n = (e >> 20 & 2047) - 1023, i = e & 1048575 | 1048576, a = i * Math.pow(2, n - 20) + t * Math.pow(2, n - 52); return (r === 0 ? 1 : -1) * a }; Z.prototype.read = function (e) { var t = this.index; if (t + e <= this.length) return this.dataView.subarray(t, t + e); throw new Error("BinaryPackFailure: read index out of range") }; function ee() { this.bufferBuilder = new Hs } ee.prototype.getBuffer = function () { return this.bufferBuilder.getBuffer() }; ee.prototype.pack = function (e) { var t = typeof e; if (t === "string") this.pack_string(e); else if (t === "number") Math.floor(e) === e ? this.pack_integer(e) : this.pack_double(e); else if (t === "boolean") e === !0 ? this.bufferBuilder.append(195) : e === !1 && this.bufferBuilder.append(194); else if (t === "undefined") this.bufferBuilder.append(192); else if (t === "object") if (e === null) this.bufferBuilder.append(192); else { var r = e.constructor; if (r == Array) this.pack_array(e); else if (r == Blob || r == File || e instanceof Blob || e instanceof File) this.pack_bin(e); else if (r == ArrayBuffer) Xn.useArrayBufferView ? this.pack_bin(new Uint8Array(e)) : this.pack_bin(e); else if ("BYTES_PER_ELEMENT" in e) Xn.useArrayBufferView ? this.pack_bin(new Uint8Array(e.buffer)) : this.pack_bin(e.buffer); else if (r == Object || r.toString().startsWith("class")) this.pack_object(e); else if (r == Date) this.pack_string(e.toString()); else if (typeof e.toBinaryPack == "function") this.bufferBuilder.append(e.toBinaryPack()); else throw new Error('Type "' + r.toString() + '" not yet supported') } else throw new Error('Type "' + t + '" not yet supported'); this.bufferBuilder.flush() }; ee.prototype.pack_bin = function (e) { var t = e.length || e.byteLength || e.size; if (t <= 15) this.pack_uint8(160 + t); else if (t <= 65535) this.bufferBuilder.append(218), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(219), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; ee.prototype.pack_string = function (e) { var t = Ys(e); if (t <= 15) this.pack_uint8(176 + t); else if (t <= 65535) this.bufferBuilder.append(216), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(217), this.pack_uint32(t); else throw new Error("Invalid length"); this.bufferBuilder.append(e) }; ee.prototype.pack_array = function (e) { var t = e.length; if (t <= 15) this.pack_uint8(144 + t); else if (t <= 65535) this.bufferBuilder.append(220), this.pack_uint16(t); else if (t <= 4294967295) this.bufferBuilder.append(221), this.pack_uint32(t); else throw new Error("Invalid length"); for (var r = 0; r < t; r++)this.pack(e[r]) }; ee.prototype.pack_integer = function (e) { if (e >= -32 && e <= 127) this.bufferBuilder.append(e & 255); else if (e >= 0 && e <= 255) this.bufferBuilder.append(204), this.pack_uint8(e); else if (e >= -128 && e <= 127) this.bufferBuilder.append(208), this.pack_int8(e); else if (e >= 0 && e <= 65535) this.bufferBuilder.append(205), this.pack_uint16(e); else if (e >= -32768 && e <= 32767) this.bufferBuilder.append(209), this.pack_int16(e); else if (e >= 0 && e <= 4294967295) this.bufferBuilder.append(206), this.pack_uint32(e); else if (e >= -2147483648 && e <= 2147483647) this.bufferBuilder.append(210), this.pack_int32(e); else if (e >= -9223372036854776e3 && e <= 9223372036854776e3) this.bufferBuilder.append(211), this.pack_int64(e); else if (e >= 0 && e <= 18446744073709552e3) this.bufferBuilder.append(207), this.pack_uint64(e); else throw new Error("Invalid integer") }; ee.prototype.pack_double = function (e) { var t = 0; e < 0 && (t = 1, e = -e); var r = Math.floor(Math.log(e) / Math.LN2), n = e / Math.pow(2, r) - 1, i = Math.floor(n * Math.pow(2, 52)), a = Math.pow(2, 32), o = t << 31 | r + 1023 << 20 | i / a & 1048575, u = i % a; this.bufferBuilder.append(203), this.pack_int32(o), this.pack_int32(u) }; ee.prototype.pack_object = function (e) { var t = Object.keys(e), r = t.length; if (r <= 15) this.pack_uint8(128 + r); else if (r <= 65535) this.bufferBuilder.append(222), this.pack_uint16(r); else if (r <= 4294967295) this.bufferBuilder.append(223), this.pack_uint32(r); else throw new Error("Invalid length"); for (var n in e) e.hasOwnProperty(n) && (this.pack(n), this.pack(e[n])) }; ee.prototype.pack_uint8 = function (e) { this.bufferBuilder.append(e) }; ee.prototype.pack_uint16 = function (e) { this.bufferBuilder.append(e >> 8), this.bufferBuilder.append(e & 255) }; ee.prototype.pack_uint32 = function (e) { var t = e & 4294967295; this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255) }; ee.prototype.pack_uint64 = function (e) { var t = e / Math.pow(2, 32), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; ee.prototype.pack_int8 = function (e) { this.bufferBuilder.append(e & 255) }; ee.prototype.pack_int16 = function (e) { this.bufferBuilder.append((e & 65280) >> 8), this.bufferBuilder.append(e & 255) }; ee.prototype.pack_int32 = function (e) { this.bufferBuilder.append(e >>> 24 & 255), this.bufferBuilder.append((e & 16711680) >>> 16), this.bufferBuilder.append((e & 65280) >>> 8), this.bufferBuilder.append(e & 255) }; ee.prototype.pack_int64 = function (e) { var t = Math.floor(e / Math.pow(2, 32)), r = e % Math.pow(2, 32); this.bufferBuilder.append((t & 4278190080) >>> 24), this.bufferBuilder.append((t & 16711680) >>> 16), this.bufferBuilder.append((t & 65280) >>> 8), this.bufferBuilder.append(t & 255), this.bufferBuilder.append((r & 4278190080) >>> 24), this.bufferBuilder.append((r & 16711680) >>> 16), this.bufferBuilder.append((r & 65280) >>> 8), this.bufferBuilder.append(r & 255) }; function Ws(e) { var t = e.charCodeAt(0); return t <= 2047 ? "00" : t <= 65535 ? "000" : t <= 2097151 ? "0000" : t <= 67108863 ? "00000" : "000000" } function Ys(e) { return e.length > 600 ? new Blob([e]).size : e.replace(/[^\u0000-\u007F]/g, Ws).length } let sa = !0, ca = !0; function yt(e, t, r) { const n = e.match(t); return n && n.length >= r && parseInt(n[r], 10) } function pt(e, t, r) { if (!e.RTCPeerConnection) return; const n = e.RTCPeerConnection.prototype, i = n.addEventListener; n.addEventListener = function (o, u) { if (o !== t) return i.apply(this, arguments); const s = c => { const l = r(c); l && (u.handleEvent ? u.handleEvent(l) : u(l)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(u, s), i.apply(this, [o, s]) }; const a = n.removeEventListener; n.removeEventListener = function (o, u) { if (o !== t || !this._eventMap || !this._eventMap[t]) return a.apply(this, arguments); if (!this._eventMap[t].has(u)) return a.apply(this, arguments); const s = this._eventMap[t].get(u); return this._eventMap[t].delete(u), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, a.apply(this, [o, s]) }, Object.defineProperty(n, "on" + t, { get() { return this["_on" + t] }, set(o) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), o && this.addEventListener(t, this["_on" + t] = o) }, enumerable: !0, configurable: !0 }) } function Qs(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (sa = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function Xs(e) { return typeof e != "boolean" ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (ca = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function An() { if (typeof window == "object") { if (sa) return; typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments) } } function kr(e, t) { !ca || console.warn(e + " is deprecated, please use " + t + " instead.") } function Zs(e) { const t = { browser: null, version: null }; if (typeof e > "u" || !e.navigator) return t.browser = "Not a browser.", t; const { navigator: r } = e; if (r.mozGetUserMedia) t.browser = "firefox", t.version = yt(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || e.isSecureContext === !1 && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = yt(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else if (r.mediaDevices && r.userAgent.match(/Edge\/(\d+).(\d+)$/)) t.browser = "edge", t.version = yt(r.userAgent, /Edge\/(\d+).(\d+)$/, 2); else if (e.RTCPeerConnection && r.userAgent.match(/AppleWebKit\/(\d+)\./)) t.browser = "safari", t.version = yt(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype; else return t.browser = "Not a supported browser.", t; return t } function ei(e) { return Object.prototype.toString.call(e) === "[object Object]" } function ua(e) { return ei(e) ? Object.keys(e).reduce(function (t, r) { const n = ei(e[r]), i = n ? ua(e[r]) : e[r], a = n && !Object.keys(i).length; return i === void 0 || a ? t : Object.assign(t, { [r]: i }) }, {}) : e } function an(e, t, r) { !t || r.has(t.id) || (r.set(t.id, t), Object.keys(t).forEach(n => { n.endsWith("Id") ? an(e, e.get(t[n]), r) : n.endsWith("Ids") && t[n].forEach(i => { an(e, e.get(i), r) }) })) } function ti(e, t, r) { const n = r ? "outbound-rtp" : "inbound-rtp", i = new Map; if (t === null) return i; const a = []; return e.forEach(o => { o.type === "track" && o.trackIdentifier === t.id && a.push(o) }), a.forEach(o => { e.forEach(u => { u.type === n && u.trackId === o.id && an(e, u, i) }) }), i } const ri = An; function la(e, t) { const r = e && e.navigator; if (!r.mediaDevices) return; const n = function (u) { if (typeof u != "object" || u.mandatory || u.optional) return u; const s = {}; return Object.keys(u).forEach(c => { if (c === "require" || c === "advanced" || c === "mediaSource") return; const l = typeof u[c] == "object" ? u[c] : { ideal: u[c] }; l.exact !== void 0 && typeof l.exact == "number" && (l.min = l.max = l.exact); const f = function (p, v) { return p ? p + v.charAt(0).toUpperCase() + v.slice(1) : v === "deviceId" ? "sourceId" : v }; if (l.ideal !== void 0) { s.optional = s.optional || []; let p = {}; typeof l.ideal == "number" ? (p[f("min", c)] = l.ideal, s.optional.push(p), p = {}, p[f("max", c)] = l.ideal, s.optional.push(p)) : (p[f("", c)] = l.ideal, s.optional.push(p)) } l.exact !== void 0 && typeof l.exact != "number" ? (s.mandatory = s.mandatory || {}, s.mandatory[f("", c)] = l.exact) : ["min", "max"].forEach(p => { l[p] !== void 0 && (s.mandatory = s.mandatory || {}, s.mandatory[f(p, c)] = l[p]) }) }), u.advanced && (s.optional = (s.optional || []).concat(u.advanced)), s }, i = function (u, s) { if (t.version >= 61) return s(u); if (u = JSON.parse(JSON.stringify(u)), u && typeof u.audio == "object") { const c = function (l, f, p) { f in l && !(p in l) && (l[p] = l[f], delete l[f]) }; u = JSON.parse(JSON.stringify(u)), c(u.audio, "autoGainControl", "googAutoGainControl"), c(u.audio, "noiseSuppression", "googNoiseSuppression"), u.audio = n(u.audio) } if (u && typeof u.video == "object") { let c = u.video.facingMode; c = c && (typeof c == "object" ? c : { ideal: c }); const l = t.version < 66; if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && !(r.mediaDevices.getSupportedConstraints && r.mediaDevices.getSupportedConstraints().facingMode && !l)) { delete u.video.facingMode; let f; if (c.exact === "environment" || c.ideal === "environment" ? f = ["back", "rear"] : (c.exact === "user" || c.ideal === "user") && (f = ["front"]), f) return r.mediaDevices.enumerateDevices().then(p => { p = p.filter(d => d.kind === "videoinput"); let v = p.find(d => f.some(h => d.label.toLowerCase().includes(h))); return !v && p.length && f.includes("back") && (v = p[p.length - 1]), v && (u.video.deviceId = c.exact ? { exact: v.deviceId } : { ideal: v.deviceId }), u.video = n(u.video), ri("chrome: " + JSON.stringify(u)), s(u) }) } u.video = n(u.video) } return ri("chrome: " + JSON.stringify(u)), s(u) }, a = function (u) { return t.version >= 64 ? u : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[u.name] || u.name, message: u.message, constraint: u.constraint || u.constraintName, toString() { return this.name + (this.message && ": ") + this.message } } }, o = function (u, s, c) { i(u, l => { r.webkitGetUserMedia(l, s, f => { c && c(a(f)) }) }) }; if (r.getUserMedia = o.bind(r), r.mediaDevices.getUserMedia) { const u = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = function (s) { return i(s, c => u(c).then(l => { if (c.audio && !l.getAudioTracks().length || c.video && !l.getVideoTracks().length) throw l.getTracks().forEach(f => { f.stop() }), new DOMException("", "NotFoundError"); return l }, l => Promise.reject(a(l)))) } } } function ec(e, t) { if (!(e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices) && !!e.navigator.mediaDevices) { if (typeof t != "function") { console.error("shimGetDisplayMedia: getSourceId argument is not a function"); return } e.navigator.mediaDevices.getDisplayMedia = function (n) { return t(n).then(i => { const a = n.video && n.video.width, o = n.video && n.video.height, u = n.video && n.video.frameRate; return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: i, maxFrameRate: u || 3 } }, a && (n.video.mandatory.maxWidth = a), o && (n.video.mandatory.maxHeight = o), e.navigator.mediaDevices.getUserMedia(n) }) } } } function fa(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function pa(e) { if (typeof e == "object" && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() { return this._ontrack }, set(r) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = r) }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { return this._ontrackpoly || (this._ontrackpoly = n => { n.stream.addEventListener("addtrack", i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.track.id) : a = { track: i.track }; const o = new Event("track"); o.track = i.track, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }), n.stream.getTracks().forEach(i => { let a; e.RTCPeerConnection.prototype.getReceivers ? a = this.getReceivers().find(u => u.track && u.track.id === i.id) : a = { track: i }; const o = new Event("track"); o.track = i, o.receiver = a, o.transceiver = { receiver: a }, o.streams = [n.stream], this.dispatchEvent(o) }) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else pt(e, "track", t => (t.transceiver || Object.defineProperty(t, "transceiver", { value: { receiver: t.receiver } }), t)) } function da(e) { if (typeof e == "object" && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { const t = function (i, a) { return { track: a, get dtmf() { return this._dtmf === void 0 && (a.kind === "audio" ? this._dtmf = i.createDTMFSender(a) : this._dtmf = null), this._dtmf }, _pc: i } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; const i = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (u, s) { let c = i.apply(this, arguments); return c || (c = t(this, u), this._senders.push(c)), c }; const a = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (u) { a.apply(this, arguments); const s = this._senders.indexOf(u); s !== -1 && this._senders.splice(s, 1) } } const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (a) { this._senders = this._senders || [], r.apply(this, [a]), a.getTracks().forEach(o => { this._senders.push(t(this, o)) }) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (a) { this._senders = this._senders || [], n.apply(this, [a]), a.getTracks().forEach(o => { const u = this._senders.find(s => s.track === o); u && this._senders.splice(this._senders.indexOf(u), 1) }) } } else if (typeof e == "object" && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function ha(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [n, i, a] = arguments; if (arguments.length > 0 && typeof n == "function") return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof n != "function")) return t.apply(this, []); const o = function (s) { const c = {}; return s.result().forEach(f => { const p = { id: f.id, timestamp: f.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[f.type] || f.type }; f.names().forEach(v => { p[v] = f.stat(v) }), c[p.id] = p }), c }, u = function (s) { return new Map(Object.keys(s).map(c => [c, s[c]])) }; if (arguments.length >= 2) { const s = function (c) { i(u(o(c))) }; return t.apply(this, [s, n]) } return new Promise((s, c) => { t.apply(this, [function (l) { s(u(o(l))) }, c]) }).then(i, a) } } function va(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return; if (!("getStats" in e.RTCRtpSender.prototype)) { const r = e.RTCPeerConnection.prototype.getSenders; r && (e.RTCPeerConnection.prototype.getSenders = function () { const a = r.apply(this, []); return a.forEach(o => o._pc = this), a }); const n = e.RTCPeerConnection.prototype.addTrack; n && (e.RTCPeerConnection.prototype.addTrack = function () { const a = n.apply(this, arguments); return a._pc = this, a }), e.RTCRtpSender.prototype.getStats = function () { const a = this; return this._pc.getStats().then(o => ti(o, a.track, !0)) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { const r = e.RTCPeerConnection.prototype.getReceivers; r && (e.RTCPeerConnection.prototype.getReceivers = function () { const i = r.apply(this, []); return i.forEach(a => a._pc = this), i }), pt(e, "track", n => (n.receiver._pc = n.srcElement, n)), e.RTCRtpReceiver.prototype.getStats = function () { const i = this; return this._pc.getStats().then(a => ti(a, i.track, !1)) } } if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return; const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const n = arguments[0]; let i, a, o; return this.getSenders().forEach(u => { u.track === n && (i ? o = !0 : i = u) }), this.getReceivers().forEach(u => (u.track === n && (a ? o = !0 : a = u), u.track === n)), o || i && a ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : i ? i.getStats() : a ? a.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return t.apply(this, arguments) } } function ma(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(o => this._shimmedLocalStreams[o][0]) }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (o, u) { if (!u) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const s = t.apply(this, arguments); return this._shimmedLocalStreams[u.id] ? this._shimmedLocalStreams[u.id].indexOf(s) === -1 && this._shimmedLocalStreams[u.id].push(s) : this._shimmedLocalStreams[u.id] = [u, s], s }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (o) { this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o.getTracks().forEach(c => { if (this.getSenders().find(f => f.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError") }); const u = this.getSenders(); r.apply(this, arguments); const s = this.getSenders().filter(c => u.indexOf(c) === -1); this._shimmedLocalStreams[o.id] = [o].concat(s) }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[o.id], n.apply(this, arguments) }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (o) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o && Object.keys(this._shimmedLocalStreams).forEach(u => { const s = this._shimmedLocalStreams[u].indexOf(o); s !== -1 && this._shimmedLocalStreams[u].splice(s, 1), this._shimmedLocalStreams[u].length === 1 && delete this._shimmedLocalStreams[u] }), i.apply(this, arguments) } } function ya(e, t) { if (!e.RTCPeerConnection) return; if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return ma(e); const r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const l = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, l.map(f => this._reverseStreams[f.id]) }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (l) { if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, l.getTracks().forEach(f => { if (this.getSenders().find(v => v.track === f)) throw new DOMException("Track already exists.", "InvalidAccessError") }), !this._reverseStreams[l.id]) { const f = new e.MediaStream(l.getTracks()); this._streams[l.id] = f, this._reverseStreams[f.id] = l, l = f } n.apply(this, [l]) }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (l) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[l.id] || l]), delete this._reverseStreams[this._streams[l.id] ? this._streams[l.id].id : l.id], delete this._streams[l.id] }, e.RTCPeerConnection.prototype.addTrack = function (l, f) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); const p = [].slice.call(arguments, 1); if (p.length !== 1 || !p[0].getTracks().find(h => h === l)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find(h => h.track === l)) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const d = this._streams[f.id]; if (d) d.addTrack(l), Promise.resolve().then(() => { this.dispatchEvent(new Event("negotiationneeded")) }); else { const h = new e.MediaStream([l]); this._streams[f.id] = h, this._reverseStreams[h.id] = f, this.addStream(h) } return this.getSenders().find(h => h.track === l) }; function a(c, l) { let f = l.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const v = c._reverseStreams[p], d = c._streams[v.id]; f = f.replace(new RegExp(d.id, "g"), v.id) }), new RTCSessionDescription({ type: l.type, sdp: f }) } function o(c, l) { let f = l.sdp; return Object.keys(c._reverseStreams || []).forEach(p => { const v = c._reverseStreams[p], d = c._streams[v.id]; f = f.replace(new RegExp(v.id, "g"), d.id) }), new RTCSessionDescription({ type: l.type, sdp: f }) } ["createOffer", "createAnswer"].forEach(function (c) { const l = e.RTCPeerConnection.prototype[c], f = { [c]() { const p = arguments; return arguments.length && typeof arguments[0] == "function" ? l.apply(this, [d => { const h = a(this, d); p[0].apply(null, [h]) }, d => { p[1] && p[1].apply(null, d) }, arguments[2]]) : l.apply(this, arguments).then(d => a(this, d)) } }; e.RTCPeerConnection.prototype[c] = f[c] }); const u = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return !arguments.length || !arguments[0].type ? u.apply(this, arguments) : (arguments[0] = o(this, arguments[0]), u.apply(this, arguments)) }; const s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() { const c = s.get.apply(this); return c.type === "" ? c : a(this, c) } }), e.RTCPeerConnection.prototype.removeTrack = function (l) { if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!l._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (!(l._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; let p; Object.keys(this._streams).forEach(v => { this._streams[v].getTracks().find(h => l.track === h) && (p = this._streams[v]) }), p && (p.getTracks().length === 1 ? this.removeStream(this._reverseStreams[p.id]) : p.removeTrack(l.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function on(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), !!e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (r) { const n = e.RTCPeerConnection.prototype[r], i = { [r]() { return arguments[0] = new (r === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments) } }; e.RTCPeerConnection.prototype[r] = i[r] }) } function ga(e, t) { pt(e, "negotiationneeded", r => { const n = r.target; if (!((t.version < 72 || n.getConfiguration && n.getConfiguration().sdpSemantics === "plan-b") && n.signalingState !== "stable")) return r }) } const ni = Object.freeze(Object.defineProperty({ __proto__: null, shimMediaStream: fa, shimOnTrack: pa, shimGetSendersWithDtmf: da, shimGetStats: ha, shimSenderReceiverGetStats: va, shimAddTrackRemoveTrackWithNative: ma, shimAddTrackRemoveTrack: ya, shimPeerConnection: on, fixNegotiationNeeded: ga, shimGetUserMedia: la, shimGetDisplayMedia: ec }, Symbol.toStringTag, { value: "Module" })); function tc(e, t) { let r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(n => { if (n && (n.urls || n.url)) { let i = n.urls || n.url; n.url && !n.urls && kr("RTCIceServer.url", "RTCIceServer.urls"); const a = typeof i == "string"; return a && (i = [i]), i = i.filter(o => { if (o.indexOf("stun:") === 0) return !1; const u = o.startsWith("turn") && !o.startsWith("turn:[") && o.includes("transport=udp"); return u && !r ? (r = !0, !0) : u && !r }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } var In = { exports: {} }; (function (e) {
    var t = {}; t.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10) }, t.localCName = t.generateIdentifier(), t.splitLines = function (r) {
        return r.trim().split(`
`).map(function (n) { return n.trim() })
    }, t.splitSections = function (r) {
        var n = r.split(`
m=`); return n.map(function (i, a) {
            return (a > 0 ? "m=" + i : i).trim() + `\r
`})
    }, t.getDescription = function (r) { var n = t.splitSections(r); return n && n[0] }, t.getMediaSections = function (r) { var n = t.splitSections(r); return n.shift(), n }, t.matchPrefix = function (r, n) { return t.splitLines(r).filter(function (i) { return i.indexOf(n) === 0 }) }, t.parseCandidate = function (r) { var n; r.indexOf("a=candidate:") === 0 ? n = r.substring(12).split(" ") : n = r.substring(10).split(" "); for (var i = { foundation: n[0], component: parseInt(n[1], 10), protocol: n[2].toLowerCase(), priority: parseInt(n[3], 10), ip: n[4], address: n[4], port: parseInt(n[5], 10), type: n[7] }, a = 8; a < n.length; a += 2)switch (n[a]) { case "raddr": i.relatedAddress = n[a + 1]; break; case "rport": i.relatedPort = parseInt(n[a + 1], 10); break; case "tcptype": i.tcpType = n[a + 1]; break; case "ufrag": i.ufrag = n[a + 1], i.usernameFragment = n[a + 1]; break; default: i[n[a]] = n[a + 1]; break }return i }, t.writeCandidate = function (r) { var n = []; n.push(r.foundation), n.push(r.component), n.push(r.protocol.toUpperCase()), n.push(r.priority), n.push(r.address || r.ip), n.push(r.port); var i = r.type; return n.push("typ"), n.push(i), i !== "host" && r.relatedAddress && r.relatedPort && (n.push("raddr"), n.push(r.relatedAddress), n.push("rport"), n.push(r.relatedPort)), r.tcpType && r.protocol.toLowerCase() === "tcp" && (n.push("tcptype"), n.push(r.tcpType)), (r.usernameFragment || r.ufrag) && (n.push("ufrag"), n.push(r.usernameFragment || r.ufrag)), "candidate:" + n.join(" ") }, t.parseIceOptions = function (r) { return r.substr(14).split(" ") }, t.parseRtpMap = function (r) { var n = r.substr(9).split(" "), i = { payloadType: parseInt(n.shift(), 10) }; return n = n[0].split("/"), i.name = n[0], i.clockRate = parseInt(n[1], 10), i.channels = n.length === 3 ? parseInt(n[2], 10) : 1, i.numChannels = i.channels, i }, t.writeRtpMap = function (r) {
        var n = r.payloadType; r.preferredPayloadType !== void 0 && (n = r.preferredPayloadType); var i = r.channels || r.numChannels || 1; return "a=rtpmap:" + n + " " + r.name + "/" + r.clockRate + (i !== 1 ? "/" + i : "") + `\r
`}, t.parseExtmap = function (r) { var n = r.substr(9).split(" "); return { id: parseInt(n[0], 10), direction: n[0].indexOf("/") > 0 ? n[0].split("/")[1] : "sendrecv", uri: n[1] } }, t.writeExtmap = function (r) {
            return "a=extmap:" + (r.id || r.preferredId) + (r.direction && r.direction !== "sendrecv" ? "/" + r.direction : "") + " " + r.uri + `\r
`}, t.parseFmtp = function (r) { for (var n = {}, i, a = r.substr(r.indexOf(" ") + 1).split(";"), o = 0; o < a.length; o++)i = a[o].trim().split("="), n[i[0].trim()] = i[1]; return n }, t.writeFmtp = function (r) {
            var n = "", i = r.payloadType; if (r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.parameters && Object.keys(r.parameters).length) {
                var a = []; Object.keys(r.parameters).forEach(function (o) { r.parameters[o] ? a.push(o + "=" + r.parameters[o]) : a.push(o) }), n += "a=fmtp:" + i + " " + a.join(";") + `\r
`} return n
        }, t.parseRtcpFb = function (r) { var n = r.substr(r.indexOf(" ") + 1).split(" "); return { type: n.shift(), parameter: n.join(" ") } }, t.writeRtcpFb = function (r) {
            var n = "", i = r.payloadType; return r.preferredPayloadType !== void 0 && (i = r.preferredPayloadType), r.rtcpFeedback && r.rtcpFeedback.length && r.rtcpFeedback.forEach(function (a) {
                n += "a=rtcp-fb:" + i + " " + a.type + (a.parameter && a.parameter.length ? " " + a.parameter : "") + `\r
`}), n
        }, t.parseSsrcMedia = function (r) { var n = r.indexOf(" "), i = { ssrc: parseInt(r.substr(7, n - 7), 10) }, a = r.indexOf(":", n); return a > -1 ? (i.attribute = r.substr(n + 1, a - n - 1), i.value = r.substr(a + 1)) : i.attribute = r.substr(n + 1), i }, t.parseSsrcGroup = function (r) { var n = r.substr(13).split(" "); return { semantics: n.shift(), ssrcs: n.map(function (i) { return parseInt(i, 10) }) } }, t.getMid = function (r) { var n = t.matchPrefix(r, "a=mid:")[0]; if (n) return n.substr(6) }, t.parseFingerprint = function (r) { var n = r.substr(14).split(" "); return { algorithm: n[0].toLowerCase(), value: n[1] } }, t.getDtlsParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=fingerprint:"); return { role: "auto", fingerprints: i.map(t.parseFingerprint) } }, t.writeDtlsParameters = function (r, n) {
            var i = "a=setup:" + n + `\r
`; return r.fingerprints.forEach(function (a) {
                i += "a=fingerprint:" + a.algorithm + " " + a.value + `\r
`}), i
        }, t.parseCryptoLine = function (r) { var n = r.substr(9).split(" "); return { tag: parseInt(n[0], 10), cryptoSuite: n[1], keyParams: n[2], sessionParams: n.slice(3) } }, t.writeCryptoLine = function (r) {
            return "a=crypto:" + r.tag + " " + r.cryptoSuite + " " + (typeof r.keyParams == "object" ? t.writeCryptoKeyParams(r.keyParams) : r.keyParams) + (r.sessionParams ? " " + r.sessionParams.join(" ") : "") + `\r
`}, t.parseCryptoKeyParams = function (r) { if (r.indexOf("inline:") !== 0) return null; var n = r.substr(7).split("|"); return { keyMethod: "inline", keySalt: n[0], lifeTime: n[1], mkiValue: n[2] ? n[2].split(":")[0] : void 0, mkiLength: n[2] ? n[2].split(":")[1] : void 0 } }, t.writeCryptoKeyParams = function (r) { return r.keyMethod + ":" + r.keySalt + (r.lifeTime ? "|" + r.lifeTime : "") + (r.mkiValue && r.mkiLength ? "|" + r.mkiValue + ":" + r.mkiLength : "") }, t.getCryptoParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=crypto:"); return i.map(t.parseCryptoLine) }, t.getIceParameters = function (r, n) { var i = t.matchPrefix(r + n, "a=ice-ufrag:")[0], a = t.matchPrefix(r + n, "a=ice-pwd:")[0]; return i && a ? { usernameFragment: i.substr(12), password: a.substr(10) } : null }, t.writeIceParameters = function (r) {
            return "a=ice-ufrag:" + r.usernameFragment + `\r
a=ice-pwd:`+ r.password + `\r
`}, t.parseRtpParameters = function (r) { for (var n = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i = t.splitLines(r), a = i[0].split(" "), o = 3; o < a.length; o++) { var u = a[o], s = t.matchPrefix(r, "a=rtpmap:" + u + " ")[0]; if (s) { var c = t.parseRtpMap(s), l = t.matchPrefix(r, "a=fmtp:" + u + " "); switch (c.parameters = l.length ? t.parseFmtp(l[0]) : {}, c.rtcpFeedback = t.matchPrefix(r, "a=rtcp-fb:" + u + " ").map(t.parseRtcpFb), n.codecs.push(c), c.name.toUpperCase()) { case "RED": case "ULPFEC": n.fecMechanisms.push(c.name.toUpperCase()); break } } } return t.matchPrefix(r, "a=extmap:").forEach(function (f) { n.headerExtensions.push(t.parseExtmap(f)) }), n }, t.writeRtpDescription = function (r, n) {
            var i = ""; i += "m=" + r + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map(function (o) { return o.preferredPayloadType !== void 0 ? o.preferredPayloadType : o.payloadType }).join(" ") + `\r
`, i += `c=IN IP4 0.0.0.0\r
`, i += `a=rtcp:9 IN IP4 0.0.0.0\r
`, n.codecs.forEach(function (o) { i += t.writeRtpMap(o), i += t.writeFmtp(o), i += t.writeRtcpFb(o) }); var a = 0; return n.codecs.forEach(function (o) { o.maxptime > a && (a = o.maxptime) }), a > 0 && (i += "a=maxptime:" + a + `\r
`), i += `a=rtcp-mux\r
`, n.headerExtensions && n.headerExtensions.forEach(function (o) { i += t.writeExtmap(o) }), i
        }, t.parseRtpEncodingParameters = function (r) { var n = [], i = t.parseRtpParameters(r), a = i.fecMechanisms.indexOf("RED") !== -1, o = i.fecMechanisms.indexOf("ULPFEC") !== -1, u = t.matchPrefix(r, "a=ssrc:").map(function (p) { return t.parseSsrcMedia(p) }).filter(function (p) { return p.attribute === "cname" }), s = u.length > 0 && u[0].ssrc, c, l = t.matchPrefix(r, "a=ssrc-group:FID").map(function (p) { var v = p.substr(17).split(" "); return v.map(function (d) { return parseInt(d, 10) }) }); l.length > 0 && l[0].length > 1 && l[0][0] === s && (c = l[0][1]), i.codecs.forEach(function (p) { if (p.name.toUpperCase() === "RTX" && p.parameters.apt) { var v = { ssrc: s, codecPayloadType: parseInt(p.parameters.apt, 10) }; s && c && (v.rtx = { ssrc: c }), n.push(v), a && (v = JSON.parse(JSON.stringify(v)), v.fec = { ssrc: s, mechanism: o ? "red+ulpfec" : "red" }, n.push(v)) } }), n.length === 0 && s && n.push({ ssrc: s }); var f = t.matchPrefix(r, "b="); return f.length && (f[0].indexOf("b=TIAS:") === 0 ? f = parseInt(f[0].substr(7), 10) : f[0].indexOf("b=AS:") === 0 ? f = parseInt(f[0].substr(5), 10) * 1e3 * .95 - 50 * 40 * 8 : f = void 0, n.forEach(function (p) { p.maxBitrate = f })), n }, t.parseRtcpParameters = function (r) { var n = {}, i = t.matchPrefix(r, "a=ssrc:").map(function (u) { return t.parseSsrcMedia(u) }).filter(function (u) { return u.attribute === "cname" })[0]; i && (n.cname = i.value, n.ssrc = i.ssrc); var a = t.matchPrefix(r, "a=rtcp-rsize"); n.reducedSize = a.length > 0, n.compound = a.length === 0; var o = t.matchPrefix(r, "a=rtcp-mux"); return n.mux = o.length > 0, n }, t.parseMsid = function (r) { var n, i = t.matchPrefix(r, "a=msid:"); if (i.length === 1) return n = i[0].substr(7).split(" "), { stream: n[0], track: n[1] }; var a = t.matchPrefix(r, "a=ssrc:").map(function (o) { return t.parseSsrcMedia(o) }).filter(function (o) { return o.attribute === "msid" }); if (a.length > 0) return n = a[0].value.split(" "), { stream: n[0], track: n[1] } }, t.parseSctpDescription = function (r) { var n = t.parseMLine(r), i = t.matchPrefix(r, "a=max-message-size:"), a; i.length > 0 && (a = parseInt(i[0].substr(19), 10)), isNaN(a) && (a = 65536); var o = t.matchPrefix(r, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: n.fmt, maxMessageSize: a }; var u = t.matchPrefix(r, "a=sctpmap:"); if (u.length > 0) { var s = t.matchPrefix(r, "a=sctpmap:")[0].substr(10).split(" "); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: a } } }, t.writeSctpDescription = function (r, n) {
            var i = []; return r.protocol !== "DTLS/SCTP" ? i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + n.port + `\r
`] : i = ["m=" + r.kind + " 9 " + r.protocol + " " + n.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + n.port + " " + n.protocol + ` 65535\r
`], n.maxMessageSize !== void 0 && i.push("a=max-message-size:" + n.maxMessageSize + `\r
`), i.join("")
        }, t.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, t.writeSessionBoilerplate = function (r, n, i) {
            var a, o = n !== void 0 ? n : 2; r ? a = r : a = t.generateSessionId(); var u = i || "thisisadapterortc"; return `v=0\r
o=`+ u + " " + a + " " + o + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`}, t.writeMediaSection = function (r, n, i, a) {
            var o = t.writeRtpDescription(r.kind, n); if (o += t.writeIceParameters(r.iceGatherer.getLocalParameters()), o += t.writeDtlsParameters(r.dtlsTransport.getLocalParameters(), i === "offer" ? "actpass" : "active"), o += "a=mid:" + r.mid + `\r
`, r.direction ? o += "a=" + r.direction + `\r
`: r.rtpSender && r.rtpReceiver ? o += `a=sendrecv\r
`: r.rtpSender ? o += `a=sendonly\r
`: r.rtpReceiver ? o += `a=recvonly\r
`: o += `a=inactive\r
`, r.rtpSender) {
                var u = "msid:" + a.id + " " + r.rtpSender.track.id + `\r
`; o += "a=" + u, o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " " + u, r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " " + u, o += "a=ssrc-group:FID " + r.sendEncodingParameters[0].ssrc + " " + r.sendEncodingParameters[0].rtx.ssrc + `\r
`)
            } return o += "a=ssrc:" + r.sendEncodingParameters[0].ssrc + " cname:" + t.localCName + `\r
`, r.rtpSender && r.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + r.sendEncodingParameters[0].rtx.ssrc + " cname:" + t.localCName + `\r
`), o
        }, t.getDirection = function (r, n) { for (var i = t.splitLines(r), a = 0; a < i.length; a++)switch (i[a]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return i[a].substr(2) }return n ? t.getDirection(n) : "sendrecv" }, t.getKind = function (r) { var n = t.splitLines(r), i = n[0].split(" "); return i[0].substr(2) }, t.isRejected = function (r) { return r.split(" ", 2)[1] === "0" }, t.parseMLine = function (r) { var n = t.splitLines(r), i = n[0].substr(2).split(" "); return { kind: i[0], port: parseInt(i[1], 10), protocol: i[2], fmt: i.slice(3).join(" ") } }, t.parseOLine = function (r) { var n = t.matchPrefix(r, "o=")[0], i = n.substr(2).split(" "); return { username: i[0], sessionId: i[1], sessionVersion: parseInt(i[2], 10), netType: i[3], addressType: i[4], address: i[5] } }, t.isValidSDP = function (r) { if (typeof r != "string" || r.length === 0) return !1; for (var n = t.splitLines(r), i = 0; i < n.length; i++)if (n[i].length < 2 || n[i].charAt(1) !== "=") return !1; return !0 }, e.exports = t
})(In); const rr = In.exports; var A = In.exports; function rc(e) { return { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type } function ii(e, t, r, n, i) {
    var a = A.writeRtpDescription(e.kind, t); if (a += A.writeIceParameters(e.iceGatherer.getLocalParameters()), a += A.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), r === "offer" ? "actpass" : i || "active"), a += "a=mid:" + e.mid + `\r
`, e.rtpSender && e.rtpReceiver ? a += `a=sendrecv\r
`: e.rtpSender ? a += `a=sendonly\r
`: e.rtpReceiver ? a += `a=recvonly\r
`: a += `a=inactive\r
`, e.rtpSender) {
        var o = e.rtpSender._initialTrackId || e.rtpSender.track.id; e.rtpSender._initialTrackId = o; var u = "msid:" + (n ? n.id : "-") + " " + o + `\r
`; a += "a=" + u, a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + u, e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + u, a += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + `\r
`)
    } return a += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + A.localCName + `\r
`, e.rtpSender && e.sendEncodingParameters[0].rtx && (a += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + A.localCName + `\r
`), a
} function nc(e, t) { var r = !1; return e = JSON.parse(JSON.stringify(e)), e.filter(function (n) { if (n && (n.urls || n.url)) { var i = n.urls || n.url; n.url && !n.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead."); var a = typeof i == "string"; return a && (i = [i]), i = i.filter(function (o) { var u = o.indexOf("turn:") === 0 && o.indexOf("transport=udp") !== -1 && o.indexOf("turn:[") === -1 && !r; return u ? (r = !0, !0) : o.indexOf("stun:") === 0 && t >= 14393 && o.indexOf("?transport=udp") === -1 }), delete n.url, n.urls = a ? i[0] : i, !!i.length } }) } function Jt(e, t) { var r = { codecs: [], headerExtensions: [], fecMechanisms: [] }, n = function (a, o) { a = parseInt(a, 10); for (var u = 0; u < o.length; u++)if (o[u].payloadType === a || o[u].preferredPayloadType === a) return o[u] }, i = function (a, o, u, s) { var c = n(a.parameters.apt, u), l = n(o.parameters.apt, s); return c && l && c.name.toLowerCase() === l.name.toLowerCase() }; return e.codecs.forEach(function (a) { for (var o = 0; o < t.codecs.length; o++) { var u = t.codecs[o]; if (a.name.toLowerCase() === u.name.toLowerCase() && a.clockRate === u.clockRate) { if (a.name.toLowerCase() === "rtx" && a.parameters && u.parameters.apt && !i(a, u, e.codecs, t.codecs)) continue; u = JSON.parse(JSON.stringify(u)), u.numChannels = Math.min(a.numChannels, u.numChannels), r.codecs.push(u), u.rtcpFeedback = u.rtcpFeedback.filter(function (s) { for (var c = 0; c < a.rtcpFeedback.length; c++)if (a.rtcpFeedback[c].type === s.type && a.rtcpFeedback[c].parameter === s.parameter) return !0; return !1 }); break } } }), e.headerExtensions.forEach(function (a) { for (var o = 0; o < t.headerExtensions.length; o++) { var u = t.headerExtensions[o]; if (a.uri === u.uri) { r.headerExtensions.push(u); break } } }), r } function ai(e, t, r) { return { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t][e].indexOf(r) !== -1 } function Ar(e, t) { var r = e.getRemoteCandidates().find(function (n) { return t.foundation === n.foundation && t.ip === n.ip && t.port === n.port && t.priority === n.priority && t.protocol === n.protocol && t.type === n.type }); return r || e.addRemoteCandidate(t), !r } function re(e, t) { var r = new Error(t); return r.name = e, r.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e], r } var ic = function (e, t) {
    function r(s, c) { c.addTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", { track: s })) } function n(s, c) { c.removeTrack(s), c.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", { track: s })) } function i(s, c, l, f) { var p = new Event("track"); p.track = c, p.receiver = l, p.transceiver = { receiver: l }, p.streams = f, e.setTimeout(function () { s._dispatchEvent("track", p) }) } var a = function (s) { var c = this, l = document.createDocumentFragment(); if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (p) { c[p] = l[p].bind(l) }), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", s = JSON.parse(JSON.stringify(s || {})), this.usingBundle = s.bundlePolicy === "max-bundle", s.rtcpMuxPolicy === "negotiate") throw re("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported"); switch (s.rtcpMuxPolicy || (s.rtcpMuxPolicy = "require"), s.iceTransportPolicy) { case "all": case "relay": break; default: s.iceTransportPolicy = "all"; break }switch (s.bundlePolicy) { case "balanced": case "max-compat": case "max-bundle": break; default: s.bundlePolicy = "balanced"; break }if (s.iceServers = nc(s.iceServers || [], t), this._iceGatherers = [], s.iceCandidatePoolSize) for (var f = s.iceCandidatePoolSize; f > 0; f--)this._iceGatherers.push(new e.RTCIceGatherer({ iceServers: s.iceServers, gatherPolicy: s.iceTransportPolicy })); else s.iceCandidatePoolSize = 0; this._config = s, this.transceivers = [], this._sdpSessionId = A.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1 }; Object.defineProperty(a.prototype, "localDescription", { configurable: !0, get: function () { return this._localDescription } }), Object.defineProperty(a.prototype, "remoteDescription", { configurable: !0, get: function () { return this._remoteDescription } }), a.prototype.onicecandidate = null, a.prototype.onaddstream = null, a.prototype.ontrack = null, a.prototype.onremovestream = null, a.prototype.onsignalingstatechange = null, a.prototype.oniceconnectionstatechange = null, a.prototype.onconnectionstatechange = null, a.prototype.onicegatheringstatechange = null, a.prototype.onnegotiationneeded = null, a.prototype.ondatachannel = null, a.prototype._dispatchEvent = function (s, c) { this._isClosed || (this.dispatchEvent(c), typeof this["on" + s] == "function" && this["on" + s](c)) }, a.prototype._emitGatheringStateChange = function () { var s = new Event("icegatheringstatechange"); this._dispatchEvent("icegatheringstatechange", s) }, a.prototype.getConfiguration = function () { return this._config }, a.prototype.getLocalStreams = function () { return this.localStreams }, a.prototype.getRemoteStreams = function () { return this.remoteStreams }, a.prototype._createTransceiver = function (s, c) { var l = this.transceivers.length > 0, f = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: s, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: !0 }; if (this.usingBundle && l) f.iceTransport = this.transceivers[0].iceTransport, f.dtlsTransport = this.transceivers[0].dtlsTransport; else { var p = this._createIceAndDtlsTransports(); f.iceTransport = p.iceTransport, f.dtlsTransport = p.dtlsTransport } return c || this.transceivers.push(f), f }, a.prototype.addTrack = function (s, c) { if (this._isClosed) throw re("InvalidStateError", "Attempted to call addTrack on a closed peerconnection."); var l = this.transceivers.find(function (v) { return v.track === s }); if (l) throw re("InvalidAccessError", "Track already exists."); for (var f, p = 0; p < this.transceivers.length; p++)!this.transceivers[p].track && this.transceivers[p].kind === s.kind && (f = this.transceivers[p]); return f || (f = this._createTransceiver(s.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(c) === -1 && this.localStreams.push(c), f.track = s, f.stream = c, f.rtpSender = new e.RTCRtpSender(s, f.dtlsTransport), f.rtpSender }, a.prototype.addStream = function (s) { var c = this; if (t >= 15025) s.getTracks().forEach(function (f) { c.addTrack(f, s) }); else { var l = s.clone(); s.getTracks().forEach(function (f, p) { var v = l.getTracks()[p]; f.addEventListener("enabled", function (d) { v.enabled = d.enabled }) }), l.getTracks().forEach(function (f) { c.addTrack(f, l) }) } }, a.prototype.removeTrack = function (s) { if (this._isClosed) throw re("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection."); if (!(s instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender."); var c = this.transceivers.find(function (p) { return p.rtpSender === s }); if (!c) throw re("InvalidAccessError", "Sender was not created by this connection."); var l = c.stream; c.rtpSender.stop(), c.rtpSender = null, c.track = null, c.stream = null; var f = this.transceivers.map(function (p) { return p.stream }); f.indexOf(l) === -1 && this.localStreams.indexOf(l) > -1 && this.localStreams.splice(this.localStreams.indexOf(l), 1), this._maybeFireNegotiationNeeded() }, a.prototype.removeStream = function (s) { var c = this; s.getTracks().forEach(function (l) { var f = c.getSenders().find(function (p) { return p.track === l }); f && c.removeTrack(f) }) }, a.prototype.getSenders = function () { return this.transceivers.filter(function (s) { return !!s.rtpSender }).map(function (s) { return s.rtpSender }) }, a.prototype.getReceivers = function () { return this.transceivers.filter(function (s) { return !!s.rtpReceiver }).map(function (s) { return s.rtpReceiver }) }, a.prototype._createIceGatherer = function (s, c) { var l = this; if (c && s > 0) return this.transceivers[0].iceGatherer; if (this._iceGatherers.length) return this._iceGatherers.shift(); var f = new e.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy }); return Object.defineProperty(f, "state", { value: "new", writable: !0 }), this.transceivers[s].bufferedCandidateEvents = [], this.transceivers[s].bufferCandidates = function (p) { var v = !p.candidate || Object.keys(p.candidate).length === 0; f.state = v ? "completed" : "gathering", l.transceivers[s].bufferedCandidateEvents !== null && l.transceivers[s].bufferedCandidateEvents.push(p) }, f.addEventListener("localcandidate", this.transceivers[s].bufferCandidates), f }, a.prototype._gather = function (s, c) {
        var l = this, f = this.transceivers[c].iceGatherer; if (!f.onlocalcandidate) {
            var p = this.transceivers[c].bufferedCandidateEvents; this.transceivers[c].bufferedCandidateEvents = null, f.removeEventListener("localcandidate", this.transceivers[c].bufferCandidates), f.onlocalcandidate = function (v) {
                if (!(l.usingBundle && c > 0)) {
                    var d = new Event("icecandidate"); d.candidate = { sdpMid: s, sdpMLineIndex: c }; var h = v.candidate, b = !h || Object.keys(h).length === 0; if (b) (f.state === "new" || f.state === "gathering") && (f.state = "completed"); else { f.state === "new" && (f.state = "gathering"), h.component = 1, h.ufrag = f.getLocalParameters().usernameFragment; var m = A.writeCandidate(h); d.candidate = Object.assign(d.candidate, A.parseCandidate(m)), d.candidate.candidate = m, d.candidate.toJSON = function () { return { candidate: d.candidate.candidate, sdpMid: d.candidate.sdpMid, sdpMLineIndex: d.candidate.sdpMLineIndex, usernameFragment: d.candidate.usernameFragment } } } var g = A.getMediaSections(l._localDescription.sdp); b ? g[d.candidate.sdpMLineIndex] += `a=end-of-candidates\r
`: g[d.candidate.sdpMLineIndex] += "a=" + d.candidate.candidate + `\r
`, l._localDescription.sdp = A.getDescription(l._localDescription.sdp) + g.join(""); var C = l.transceivers.every(function (_) { return _.iceGatherer && _.iceGatherer.state === "completed" }); l.iceGatheringState !== "gathering" && (l.iceGatheringState = "gathering", l._emitGatheringStateChange()), b || l._dispatchEvent("icecandidate", d), C && (l._dispatchEvent("icecandidate", new Event("icecandidate")), l.iceGatheringState = "complete", l._emitGatheringStateChange())
                }
            }, e.setTimeout(function () { p.forEach(function (v) { f.onlocalcandidate(v) }) }, 0)
        }
    }, a.prototype._createIceAndDtlsTransports = function () { var s = this, c = new e.RTCIceTransport(null); c.onicestatechange = function () { s._updateIceConnectionState(), s._updateConnectionState() }; var l = new e.RTCDtlsTransport(c); return l.ondtlsstatechange = function () { s._updateConnectionState() }, l.onerror = function () { Object.defineProperty(l, "state", { value: "failed", writable: !0 }), s._updateConnectionState() }, { iceTransport: c, dtlsTransport: l } }, a.prototype._disposeIceAndDtlsTransports = function (s) { var c = this.transceivers[s].iceGatherer; c && (delete c.onlocalcandidate, delete this.transceivers[s].iceGatherer); var l = this.transceivers[s].iceTransport; l && (delete l.onicestatechange, delete this.transceivers[s].iceTransport); var f = this.transceivers[s].dtlsTransport; f && (delete f.ondtlsstatechange, delete f.onerror, delete this.transceivers[s].dtlsTransport) }, a.prototype._transceive = function (s, c, l) { var f = Jt(s.localCapabilities, s.remoteCapabilities); c && s.rtpSender && (f.encodings = s.sendEncodingParameters, f.rtcp = { cname: A.localCName, compound: s.rtcpParameters.compound }, s.recvEncodingParameters.length && (f.rtcp.ssrc = s.recvEncodingParameters[0].ssrc), s.rtpSender.send(f)), l && s.rtpReceiver && f.codecs.length > 0 && (s.kind === "video" && s.recvEncodingParameters && t < 15019 && s.recvEncodingParameters.forEach(function (p) { delete p.rtx }), s.recvEncodingParameters.length ? f.encodings = s.recvEncodingParameters : f.encodings = [{}], f.rtcp = { compound: s.rtcpParameters.compound }, s.rtcpParameters.cname && (f.rtcp.cname = s.rtcpParameters.cname), s.sendEncodingParameters.length && (f.rtcp.ssrc = s.sendEncodingParameters[0].ssrc), s.rtpReceiver.receive(f)) }, a.prototype.setLocalDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(re("TypeError", 'Unsupported type "' + s.type + '"')); if (!ai("setLocalDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(re("InvalidStateError", "Can not set local " + s.type + " in state " + c.signalingState)); var l, f; if (s.type === "offer") l = A.splitSections(s.sdp), f = l.shift(), l.forEach(function (v, d) { var h = A.parseRtpParameters(v); c.transceivers[d].localCapabilities = h }), c.transceivers.forEach(function (v, d) { c._gather(v.mid, d) }); else if (s.type === "answer") { l = A.splitSections(c._remoteDescription.sdp), f = l.shift(); var p = A.matchPrefix(f, "a=ice-lite").length > 0; l.forEach(function (v, d) { var h = c.transceivers[d], b = h.iceGatherer, m = h.iceTransport, g = h.dtlsTransport, C = h.localCapabilities, _ = h.remoteCapabilities, y = A.isRejected(v) && A.matchPrefix(v, "a=bundle-only").length === 0; if (!y && !h.rejected) { var S = A.getIceParameters(v, f), R = A.getDtlsParameters(v, f); p && (R.role = "server"), (!c.usingBundle || d === 0) && (c._gather(h.mid, d), m.state === "new" && m.start(b, S, p ? "controlling" : "controlled"), g.state === "new" && g.start(R)); var T = Jt(C, _); c._transceive(h, T.codecs.length > 0, !1) } }) } return c._localDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-local-offer") : c._updateSignalingState("stable"), Promise.resolve() }, a.prototype.setRemoteDescription = function (s) { var c = this; if (["offer", "answer"].indexOf(s.type) === -1) return Promise.reject(re("TypeError", 'Unsupported type "' + s.type + '"')); if (!ai("setRemoteDescription", s.type, c.signalingState) || c._isClosed) return Promise.reject(re("InvalidStateError", "Can not set remote " + s.type + " in state " + c.signalingState)); var l = {}; c.remoteStreams.forEach(function (m) { l[m.id] = m }); var f = [], p = A.splitSections(s.sdp), v = p.shift(), d = A.matchPrefix(v, "a=ice-lite").length > 0, h = A.matchPrefix(v, "a=group:BUNDLE ").length > 0; c.usingBundle = h; var b = A.matchPrefix(v, "a=ice-options:")[0]; return b ? c.canTrickleIceCandidates = b.substr(14).split(" ").indexOf("trickle") >= 0 : c.canTrickleIceCandidates = !1, p.forEach(function (m, g) { var C = A.splitLines(m), _ = A.getKind(m), y = A.isRejected(m) && A.matchPrefix(m, "a=bundle-only").length === 0, S = C[0].substr(2).split(" ")[2], R = A.getDirection(m, v), T = A.parseMsid(m), O = A.getMid(m) || A.generateIdentifier(); if (y || _ === "application" && (S === "DTLS/SCTP" || S === "UDP/DTLS/SCTP")) { c.transceivers[g] = { mid: O, kind: _, protocol: S, rejected: !0 }; return } !y && c.transceivers[g] && c.transceivers[g].rejected && (c.transceivers[g] = c._createTransceiver(_, !0)); var k, N, K, F, z, M, te, Q, W, pe = A.parseRtpParameters(m), oe, ye; y || (oe = A.getIceParameters(m, v), ye = A.getDtlsParameters(m, v), ye.role = "client"), te = A.parseRtpEncodingParameters(m); var de = A.parseRtcpParameters(m), Me = A.matchPrefix(m, "a=end-of-candidates", v).length > 0, Y = A.matchPrefix(m, "a=candidate:").map(function (le) { return A.parseCandidate(le) }).filter(function (le) { return le.component === 1 }); if ((s.type === "offer" || s.type === "answer") && !y && h && g > 0 && c.transceivers[g] && (c._disposeIceAndDtlsTransports(g), c.transceivers[g].iceGatherer = c.transceivers[0].iceGatherer, c.transceivers[g].iceTransport = c.transceivers[0].iceTransport, c.transceivers[g].dtlsTransport = c.transceivers[0].dtlsTransport, c.transceivers[g].rtpSender && c.transceivers[g].rtpSender.setTransport(c.transceivers[0].dtlsTransport), c.transceivers[g].rtpReceiver && c.transceivers[g].rtpReceiver.setTransport(c.transceivers[0].dtlsTransport)), s.type === "offer" && !y) { k = c.transceivers[g] || c._createTransceiver(_), k.mid = O, k.iceGatherer || (k.iceGatherer = c._createIceGatherer(g, h)), Y.length && k.iceTransport.state === "new" && (Me && (!h || g === 0) ? k.iceTransport.setRemoteCandidates(Y) : Y.forEach(function (le) { Ar(k.iceTransport, le) })), Q = e.RTCRtpReceiver.getCapabilities(_), t < 15019 && (Q.codecs = Q.codecs.filter(function (le) { return le.name !== "rtx" })), M = k.sendEncodingParameters || [{ ssrc: (2 * g + 2) * 1001 }]; var je = !1; if (R === "sendrecv" || R === "sendonly") { if (je = !k.rtpReceiver, z = k.rtpReceiver || new e.RTCRtpReceiver(k.dtlsTransport, _), je) { var Be; W = z.track, T && T.stream === "-" || (T ? (l[T.stream] || (l[T.stream] = new e.MediaStream, Object.defineProperty(l[T.stream], "id", { get: function () { return T.stream } })), Object.defineProperty(W, "id", { get: function () { return T.track } }), Be = l[T.stream]) : (l.default || (l.default = new e.MediaStream), Be = l.default)), Be && (r(W, Be), k.associatedRemoteMediaStreams.push(Be)), f.push([W, z, Be]) } } else k.rtpReceiver && k.rtpReceiver.track && (k.associatedRemoteMediaStreams.forEach(function (le) { var Fn = le.getTracks().find(function (qa) { return qa.id === k.rtpReceiver.track.id }); Fn && n(Fn, le) }), k.associatedRemoteMediaStreams = []); k.localCapabilities = Q, k.remoteCapabilities = pe, k.rtpReceiver = z, k.rtcpParameters = de, k.sendEncodingParameters = M, k.recvEncodingParameters = te, c._transceive(c.transceivers[g], !1, je) } else if (s.type === "answer" && !y) { k = c.transceivers[g], N = k.iceGatherer, K = k.iceTransport, F = k.dtlsTransport, z = k.rtpReceiver, M = k.sendEncodingParameters, Q = k.localCapabilities, c.transceivers[g].recvEncodingParameters = te, c.transceivers[g].remoteCapabilities = pe, c.transceivers[g].rtcpParameters = de, Y.length && K.state === "new" && ((d || Me) && (!h || g === 0) ? K.setRemoteCandidates(Y) : Y.forEach(function (le) { Ar(k.iceTransport, le) })), (!h || g === 0) && (K.state === "new" && K.start(N, oe, "controlling"), F.state === "new" && F.start(ye)); var Va = Jt(k.localCapabilities, k.remoteCapabilities), Ha = Va.codecs.filter(function (le) { return le.name.toLowerCase() === "rtx" }).length; !Ha && k.sendEncodingParameters[0].rtx && delete k.sendEncodingParameters[0].rtx, c._transceive(k, R === "sendrecv" || R === "recvonly", R === "sendrecv" || R === "sendonly"), z && (R === "sendrecv" || R === "sendonly") ? (W = z.track, T ? (l[T.stream] || (l[T.stream] = new e.MediaStream), r(W, l[T.stream]), f.push([W, z, l[T.stream]])) : (l.default || (l.default = new e.MediaStream), r(W, l.default), f.push([W, z, l.default]))) : delete k.rtpReceiver } }), c._dtlsRole === void 0 && (c._dtlsRole = s.type === "offer" ? "active" : "passive"), c._remoteDescription = { type: s.type, sdp: s.sdp }, s.type === "offer" ? c._updateSignalingState("have-remote-offer") : c._updateSignalingState("stable"), Object.keys(l).forEach(function (m) { var g = l[m]; if (g.getTracks().length) { if (c.remoteStreams.indexOf(g) === -1) { c.remoteStreams.push(g); var C = new Event("addstream"); C.stream = g, e.setTimeout(function () { c._dispatchEvent("addstream", C) }) } f.forEach(function (_) { var y = _[0], S = _[1]; g.id === _[2].id && i(c, y, S, [g]) }) } }), f.forEach(function (m) { m[2] || i(c, m[0], m[1], []) }), e.setTimeout(function () { !(c && c.transceivers) || c.transceivers.forEach(function (m) { m.iceTransport && m.iceTransport.state === "new" && m.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), m.iceTransport.addRemoteCandidate({})) }) }, 4e3), Promise.resolve() }, a.prototype.close = function () { this.transceivers.forEach(function (s) { s.iceTransport && s.iceTransport.stop(), s.dtlsTransport && s.dtlsTransport.stop(), s.rtpSender && s.rtpSender.stop(), s.rtpReceiver && s.rtpReceiver.stop() }), this._isClosed = !0, this._updateSignalingState("closed") }, a.prototype._updateSignalingState = function (s) { this.signalingState = s; var c = new Event("signalingstatechange"); this._dispatchEvent("signalingstatechange", c) }, a.prototype._maybeFireNegotiationNeeded = function () { var s = this; this.signalingState !== "stable" || this.needNegotiation === !0 || (this.needNegotiation = !0, e.setTimeout(function () { if (s.needNegotiation) { s.needNegotiation = !1; var c = new Event("negotiationneeded"); s._dispatchEvent("negotiationneeded", c) } }, 0)) }, a.prototype._updateIceConnectionState = function () { var s, c = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (f) { f.iceTransport && !f.rejected && c[f.iceTransport.state]++ }), s = "new", c.failed > 0 ? s = "failed" : c.checking > 0 ? s = "checking" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 ? s = "connected" : c.completed > 0 && (s = "completed"), s !== this.iceConnectionState) { this.iceConnectionState = s; var l = new Event("iceconnectionstatechange"); this._dispatchEvent("iceconnectionstatechange", l) } }, a.prototype._updateConnectionState = function () { var s, c = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 }; if (this.transceivers.forEach(function (f) { f.iceTransport && f.dtlsTransport && !f.rejected && (c[f.iceTransport.state]++, c[f.dtlsTransport.state]++) }), c.connected += c.completed, s = "new", c.failed > 0 ? s = "failed" : c.connecting > 0 ? s = "connecting" : c.disconnected > 0 ? s = "disconnected" : c.new > 0 ? s = "new" : c.connected > 0 && (s = "connected"), s !== this.connectionState) { this.connectionState = s; var l = new Event("connectionstatechange"); this._dispatchEvent("connectionstatechange", l) } }, a.prototype.createOffer = function () {
        var s = this; if (s._isClosed) return Promise.reject(re("InvalidStateError", "Can not call createOffer after close")); var c = s.transceivers.filter(function (d) { return d.kind === "audio" }).length, l = s.transceivers.filter(function (d) { return d.kind === "video" }).length, f = arguments[0]; if (f) { if (f.mandatory || f.optional) throw new TypeError("Legacy mandatory/optional constraints not supported."); f.offerToReceiveAudio !== void 0 && (f.offerToReceiveAudio === !0 ? c = 1 : f.offerToReceiveAudio === !1 ? c = 0 : c = f.offerToReceiveAudio), f.offerToReceiveVideo !== void 0 && (f.offerToReceiveVideo === !0 ? l = 1 : f.offerToReceiveVideo === !1 ? l = 0 : l = f.offerToReceiveVideo) } for (s.transceivers.forEach(function (d) { d.kind === "audio" ? (c--, c < 0 && (d.wantReceive = !1)) : d.kind === "video" && (l--, l < 0 && (d.wantReceive = !1)) }); c > 0 || l > 0;)c > 0 && (s._createTransceiver("audio"), c--), l > 0 && (s._createTransceiver("video"), l--); var p = A.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.transceivers.forEach(function (d, h) { var b = d.track, m = d.kind, g = d.mid || A.generateIdentifier(); d.mid = g, d.iceGatherer || (d.iceGatherer = s._createIceGatherer(h, s.usingBundle)); var C = e.RTCRtpSender.getCapabilities(m); t < 15019 && (C.codecs = C.codecs.filter(function (y) { return y.name !== "rtx" })), C.codecs.forEach(function (y) { y.name === "H264" && y.parameters["level-asymmetry-allowed"] === void 0 && (y.parameters["level-asymmetry-allowed"] = "1"), d.remoteCapabilities && d.remoteCapabilities.codecs && d.remoteCapabilities.codecs.forEach(function (S) { y.name.toLowerCase() === S.name.toLowerCase() && y.clockRate === S.clockRate && (y.preferredPayloadType = S.payloadType) }) }), C.headerExtensions.forEach(function (y) { var S = d.remoteCapabilities && d.remoteCapabilities.headerExtensions || []; S.forEach(function (R) { y.uri === R.uri && (y.id = R.id) }) }); var _ = d.sendEncodingParameters || [{ ssrc: (2 * h + 1) * 1001 }]; b && t >= 15019 && m === "video" && !_[0].rtx && (_[0].rtx = { ssrc: _[0].ssrc + 1 }), d.wantReceive && (d.rtpReceiver = new e.RTCRtpReceiver(d.dtlsTransport, m)), d.localCapabilities = C, d.sendEncodingParameters = _ }), s._config.bundlePolicy !== "max-compat" && (p += "a=group:BUNDLE " + s.transceivers.map(function (d) { return d.mid }).join(" ") + `\r
`), p += `a=ice-options:trickle\r
`, s.transceivers.forEach(function (d, h) {
            p += ii(d, d.localCapabilities, "offer", d.stream, s._dtlsRole), p += `a=rtcp-rsize\r
`, d.iceGatherer && s.iceGatheringState !== "new" && (h === 0 || !s.usingBundle) && (d.iceGatherer.getLocalCandidates().forEach(function (b) {
                b.component = 1, p += "a=" + A.writeCandidate(b) + `\r
`}), d.iceGatherer.state === "completed" && (p += `a=end-of-candidates\r
`))
        }); var v = new e.RTCSessionDescription({ type: "offer", sdp: p }); return Promise.resolve(v)
    }, a.prototype.createAnswer = function () {
        var s = this; if (s._isClosed) return Promise.reject(re("InvalidStateError", "Can not call createAnswer after close")); if (!(s.signalingState === "have-remote-offer" || s.signalingState === "have-local-pranswer")) return Promise.reject(re("InvalidStateError", "Can not call createAnswer in signalingState " + s.signalingState)); var c = A.writeSessionBoilerplate(s._sdpSessionId, s._sdpSessionVersion++); s.usingBundle && (c += "a=group:BUNDLE " + s.transceivers.map(function (p) { return p.mid }).join(" ") + `\r
`), c += `a=ice-options:trickle\r
`; var l = A.getMediaSections(s._remoteDescription.sdp).length; s.transceivers.forEach(function (p, v) {
            if (!(v + 1 > l)) {
                if (p.rejected) {
                    p.kind === "application" ? p.protocol === "DTLS/SCTP" ? c += `m=application 0 DTLS/SCTP 5000\r
`: c += "m=application 0 " + p.protocol + ` webrtc-datachannel\r
`: p.kind === "audio" ? c += `m=audio 0 UDP/TLS/RTP/SAVPF 0\r
a=rtpmap:0 PCMU/8000\r
`: p.kind === "video" && (c += `m=video 0 UDP/TLS/RTP/SAVPF 120\r
a=rtpmap:120 VP8/90000\r
`), c += `c=IN IP4 0.0.0.0\r
a=inactive\r
a=mid:`+ p.mid + `\r
`; return
                } if (p.stream) { var d; p.kind === "audio" ? d = p.stream.getAudioTracks()[0] : p.kind === "video" && (d = p.stream.getVideoTracks()[0]), d && t >= 15019 && p.kind === "video" && !p.sendEncodingParameters[0].rtx && (p.sendEncodingParameters[0].rtx = { ssrc: p.sendEncodingParameters[0].ssrc + 1 }) } var h = Jt(p.localCapabilities, p.remoteCapabilities), b = h.codecs.filter(function (m) { return m.name.toLowerCase() === "rtx" }).length; !b && p.sendEncodingParameters[0].rtx && delete p.sendEncodingParameters[0].rtx, c += ii(p, h, "answer", p.stream, s._dtlsRole), p.rtcpParameters && p.rtcpParameters.reducedSize && (c += `a=rtcp-rsize\r
`)
            }
        }); var f = new e.RTCSessionDescription({ type: "answer", sdp: c }); return Promise.resolve(f)
    }, a.prototype.addIceCandidate = function (s) {
        var c = this, l; return s && !(s.sdpMLineIndex !== void 0 || s.sdpMid) ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function (f, p) {
            if (c._remoteDescription) if (!s || s.candidate === "") for (var v = 0; v < c.transceivers.length && !(!c.transceivers[v].rejected && (c.transceivers[v].iceTransport.addRemoteCandidate({}), l = A.getMediaSections(c._remoteDescription.sdp), l[v] += `a=end-of-candidates\r
`, c._remoteDescription.sdp = A.getDescription(c._remoteDescription.sdp) + l.join(""), c.usingBundle)); v++); else {
                var d = s.sdpMLineIndex; if (s.sdpMid) { for (var h = 0; h < c.transceivers.length; h++)if (c.transceivers[h].mid === s.sdpMid) { d = h; break } } var b = c.transceivers[d]; if (b) {
                    if (b.rejected) return f(); var m = Object.keys(s.candidate).length > 0 ? A.parseCandidate(s.candidate) : {}; if (m.protocol === "tcp" && (m.port === 0 || m.port === 9) || m.component && m.component !== 1) return f(); if ((d === 0 || d > 0 && b.iceTransport !== c.transceivers[0].iceTransport) && !Ar(b.iceTransport, m)) return p(re("OperationError", "Can not add ICE candidate")); var g = s.candidate.trim(); g.indexOf("a=") === 0 && (g = g.substr(2)), l = A.getMediaSections(c._remoteDescription.sdp), l[d] += "a=" + (m.type ? g : "end-of-candidates") + `\r
`, c._remoteDescription.sdp = A.getDescription(c._remoteDescription.sdp) + l.join("")
                } else return p(re("OperationError", "Can not add ICE candidate"))
            } else return p(re("InvalidStateError", "Can not add ICE candidate without a remote description")); f()
        })
    }, a.prototype.getStats = function (s) { if (s && s instanceof e.MediaStreamTrack) { var c = null; if (this.transceivers.forEach(function (f) { f.rtpSender && f.rtpSender.track === s ? c = f.rtpSender : f.rtpReceiver && f.rtpReceiver.track === s && (c = f.rtpReceiver) }), !c) throw re("InvalidAccessError", "Invalid selector."); return c.getStats() } var l = []; return this.transceivers.forEach(function (f) { ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function (p) { f[p] && l.push(f[p].getStats()) }) }), Promise.all(l).then(function (f) { var p = new Map; return f.forEach(function (v) { v.forEach(function (d) { p.set(d.id, d) }) }), p }) }; var o = ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"]; o.forEach(function (s) { var c = e[s]; if (c && c.prototype && c.prototype.getStats) { var l = c.prototype.getStats; c.prototype.getStats = function () { return l.apply(this).then(function (f) { var p = new Map; return Object.keys(f).forEach(function (v) { f[v].type = rc(f[v]), p.set(v, f[v]) }), p }) } } }); var u = ["createOffer", "createAnswer"]; return u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[0] == "function" || typeof l[1] == "function" ? c.apply(this, [arguments[2]]).then(function (f) { typeof l[0] == "function" && l[0].apply(null, [f]) }, function (f) { typeof l[1] == "function" && l[1].apply(null, [f]) }) : c.apply(this, arguments) } }), u = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"], u.forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[1] == "function" || typeof l[2] == "function" ? c.apply(this, arguments).then(function () { typeof l[1] == "function" && l[1].apply(null) }, function (f) { typeof l[2] == "function" && l[2].apply(null, [f]) }) : c.apply(this, arguments) } }), ["getStats"].forEach(function (s) { var c = a.prototype[s]; a.prototype[s] = function () { var l = arguments; return typeof l[1] == "function" ? c.apply(this, arguments).then(function () { typeof l[1] == "function" && l[1].apply(null) }) : c.apply(this, arguments) } }), a
}; function ba(e) { const t = e && e.navigator, r = function (i) { return { name: { PermissionDeniedError: "NotAllowedError" }[i.name] || i.name, message: i.message, constraint: i.constraint, toString() { return this.name } } }, n = t.mediaDevices.getUserMedia.bind(t.mediaDevices); t.mediaDevices.getUserMedia = function (i) { return n(i).catch(a => Promise.reject(r(a))) } } function _a(e) { "getDisplayMedia" in e.navigator && (!e.navigator.mediaDevices || e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator))) } function sn(e, t) { if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function (i) { return i }), e.RTCSessionDescription || (e.RTCSessionDescription = function (i) { return i }), t.version < 15025)) { const n = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled"); Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", { set(i) { n.set.call(this, i); const a = new Event("enabled"); a.enabled = i, this.dispatchEvent(a) } }) } e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype) && Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() { return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new e.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf } }), e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender); const r = ic(e, t.version); e.RTCPeerConnection = function (i) { return i && i.iceServers && (i.iceServers = tc(i.iceServers, t.version), An("ICE servers after filtering:", i.iceServers)), new r(i) }, e.RTCPeerConnection.prototype = r.prototype } function Ca(e) { e.RTCRtpSender && !("replaceTrack" in e.RTCRtpSender.prototype) && (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack) } const oi = Object.freeze(Object.defineProperty({ __proto__: null, shimPeerConnection: sn, shimReplaceTrack: Ca, shimGetUserMedia: ba, shimGetDisplayMedia: _a }, Symbol.toStringTag, { value: "Module" })); function Sa(e, t) { const r = e && e.navigator, n = e && e.MediaStreamTrack; if (r.getUserMedia = function (i, a, o) { kr("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r.mediaDevices.getUserMedia(i).then(a, o) }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) { const i = function (o, u, s) { u in o && !(s in o) && (o[s] = o[u], delete o[u]) }, a = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (o) { return typeof o == "object" && typeof o.audio == "object" && (o = JSON.parse(JSON.stringify(o)), i(o.audio, "autoGainControl", "mozAutoGainControl"), i(o.audio, "noiseSuppression", "mozNoiseSuppression")), a(o) }, n && n.prototype.getSettings) { const o = n.prototype.getSettings; n.prototype.getSettings = function () { const u = o.apply(this, arguments); return i(u, "mozAutoGainControl", "autoGainControl"), i(u, "mozNoiseSuppression", "noiseSuppression"), u } } if (n && n.prototype.applyConstraints) { const o = n.prototype.applyConstraints; n.prototype.applyConstraints = function (u) { return this.kind === "audio" && typeof u == "object" && (u = JSON.parse(JSON.stringify(u)), i(u, "autoGainControl", "mozAutoGainControl"), i(u, "noiseSuppression", "mozNoiseSuppression")), o.apply(this, [u]) } } } } function ac(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || !e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = function (n) { if (!(n && n.video)) { const i = new DOMException("getDisplayMedia without video constraints is undefined"); return i.name = "NotFoundError", i.code = 8, Promise.reject(i) } return n.video === !0 ? n.video = { mediaSource: t } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n) }) } function Ta(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function cn(e, t) { if (typeof e != "object" || !(e.RTCPeerConnection || e.mozRTCPeerConnection)) return; !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (i) { const a = e.RTCPeerConnection.prototype[i], o = { [i]() { return arguments[0] = new (i === "addIceCandidate" ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), a.apply(this, arguments) } }; e.RTCPeerConnection.prototype[i] = o[i] }); const r = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const [a, o, u] = arguments; return n.apply(this, [a || null]).then(s => { if (t.version < 53 && !o) try { s.forEach(c => { c.type = r[c.type] || c.type }) } catch (c) { if (c.name !== "TypeError") throw c; s.forEach((l, f) => { s.set(f, Object.assign({}, l, { type: r[l.type] || l.type })) }) } return s }).then(o, u) } } function ka(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return; const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const i = t.apply(this, []); return i.forEach(a => a._pc = this), i }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const i = r.apply(this, arguments); return i._pc = this, i }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } function Pa(e) { if (!(typeof e == "object" && e.RTCPeerConnection && e.RTCRtpSender) || e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return; const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const n = t.apply(this, []); return n.forEach(i => i._pc = this), n }), pt(e, "track", r => (r.receiver._pc = r.srcElement, r)), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } function Ra(e) { !e.RTCPeerConnection || "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { kr("removeStream", "removeTrack"), this.getSenders().forEach(n => { n.track && r.getTracks().includes(n.track) && this.removeTrack(n) }) }) } function Ea(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function xa(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const n = arguments[1], i = n && "sendEncodings" in n; i && n.sendEncodings.forEach(o => { if ("rid" in o && !/^[a-z0-9]{0,16}$/i.test(o.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in o && !(parseFloat(o.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in o && !(parseFloat(o.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") }); const a = t.apply(this, arguments); if (i) { const { sender: o } = a, u = o.getParameters(); (!("encodings" in u) || u.encodings.length === 1 && Object.keys(u.encodings[0]).length === 0) && (u.encodings = n.sendEncodings, o.sendEncodings = n.sendEncodings, this.setParametersPromises.push(o.setParameters(u).then(() => { delete o.sendEncodings }).catch(() => { delete o.sendEncodings }))) } return a }) } function Da(e) { if (!(typeof e == "object" && e.RTCRtpSender)) return; const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const n = t.apply(this, arguments); return "encodings" in n || (n.encodings = [].concat(this.sendEncodings || [{}])), n }) } function wa(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } function Oa(e) { if (!(typeof e == "object" && e.RTCPeerConnection)) return; const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => { this.setParametersPromises = [] }) : t.apply(this, arguments) } } const si = Object.freeze(Object.defineProperty({ __proto__: null, shimOnTrack: Ta, shimPeerConnection: cn, shimSenderGetStats: ka, shimReceiverGetStats: Pa, shimRemoveStream: Ra, shimRTCDataChannel: Ea, shimAddTransceiver: xa, shimGetParameters: Da, shimCreateOffer: wa, shimCreateAnswer: Oa, shimGetUserMedia: Sa, shimGetDisplayMedia: ac }, Symbol.toStringTag, { value: "Module" })); function Aa(e) { if (!(typeof e != "object" || !e.RTCPeerConnection)) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (n) { this._localStreams || (this._localStreams = []), this._localStreams.includes(n) || this._localStreams.push(n), n.getAudioTracks().forEach(i => t.call(this, i, n)), n.getVideoTracks().forEach(i => t.call(this, i, n)) }, e.RTCPeerConnection.prototype.addTrack = function (n, ...i) { return i && i.forEach(a => { this._localStreams ? this._localStreams.includes(a) || this._localStreams.push(a) : this._localStreams = [a] }), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (r) { this._localStreams || (this._localStreams = []); const n = this._localStreams.indexOf(r); if (n === -1) return; this._localStreams.splice(n, 1); const i = r.getTracks(); this.getSenders().forEach(a => { i.includes(a.track) && this.removeTrack(a) }) }) } } function Ia(e) { if (!(typeof e != "object" || !e.RTCPeerConnection) && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() { return this._onaddstream }, set(r) { this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = r), this.addEventListener("track", this._onaddstreampoly = n => { n.streams.forEach(i => { if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(i)) return; this._remoteStreams.push(i); const a = new Event("addstream"); a.stream = i, this.dispatchEvent(a) }) }) } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const n = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (i) { i.streams.forEach(a => { if (n._remoteStreams || (n._remoteStreams = []), n._remoteStreams.indexOf(a) >= 0) return; n._remoteStreams.push(a); const o = new Event("addstream"); o.stream = a, n.dispatchEvent(o) }) }), t.apply(n, arguments) } } } function Ma(e) { if (typeof e != "object" || !e.RTCPeerConnection) return; const t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer, i = t.setLocalDescription, a = t.setRemoteDescription, o = t.addIceCandidate; t.createOffer = function (c, l) { const f = arguments.length >= 2 ? arguments[2] : arguments[0], p = r.apply(this, [f]); return l ? (p.then(c, l), Promise.resolve()) : p }, t.createAnswer = function (c, l) { const f = arguments.length >= 2 ? arguments[2] : arguments[0], p = n.apply(this, [f]); return l ? (p.then(c, l), Promise.resolve()) : p }; let u = function (s, c, l) { const f = i.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }; t.setLocalDescription = u, u = function (s, c, l) { const f = a.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }, t.setRemoteDescription = u, u = function (s, c, l) { const f = o.apply(this, [s]); return l ? (f.then(c, l), Promise.resolve()) : f }, t.addIceCandidate = u } function ja(e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const r = t.mediaDevices, n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = i => n(Ba(i)) } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (n, i, a) { t.mediaDevices.getUserMedia(n).then(i, a) }.bind(t)) } function Ba(e) { return e && e.video !== void 0 ? Object.assign({}, e, { video: ua(e.video) }) : e } function Fa(e) { if (!e.RTCPeerConnection) return; const t = e.RTCPeerConnection; e.RTCPeerConnection = function (n, i) { if (n && n.iceServers) { const a = []; for (let o = 0; o < n.iceServers.length; o++) { let u = n.iceServers[o]; !u.hasOwnProperty("urls") && u.hasOwnProperty("url") ? (kr("RTCIceServer.url", "RTCIceServer.urls"), u = JSON.parse(JSON.stringify(u)), u.urls = u.url, delete u.url, a.push(u)) : a.push(n.iceServers[o]) } n.iceServers = a } return new t(n, i) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get() { return t.generateCertificate } }) } function Ka(e) { typeof e == "object" && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() { return { receiver: this.receiver } } }) } function Na(e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (n) { if (n) { typeof n.offerToReceiveAudio < "u" && (n.offerToReceiveAudio = !!n.offerToReceiveAudio); const i = this.getTransceivers().find(o => o.receiver.track.kind === "audio"); n.offerToReceiveAudio === !1 && i ? i.direction === "sendrecv" ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : i.direction === "recvonly" && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : n.offerToReceiveAudio === !0 && !i && this.addTransceiver("audio"), typeof n.offerToReceiveVideo < "u" && (n.offerToReceiveVideo = !!n.offerToReceiveVideo); const a = this.getTransceivers().find(o => o.receiver.track.kind === "video"); n.offerToReceiveVideo === !1 && a ? a.direction === "sendrecv" ? a.setDirection ? a.setDirection("sendonly") : a.direction = "sendonly" : a.direction === "recvonly" && (a.setDirection ? a.setDirection("inactive") : a.direction = "inactive") : n.offerToReceiveVideo === !0 && !a && this.addTransceiver("video") } return t.apply(this, arguments) } } function La(e) { typeof e != "object" || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } const ci = Object.freeze(Object.defineProperty({ __proto__: null, shimLocalStreamsAPI: Aa, shimRemoteStreamsAPI: Ia, shimCallbacksAPI: Ma, shimGetUserMedia: ja, shimConstraints: Ba, shimRTCIceServerUrls: Fa, shimTrackEventTransceiver: Ka, shimCreateOfferLegacy: Na, shimAudioContext: La }, Symbol.toStringTag, { value: "Module" })); function nr(e) { if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return; const t = e.RTCIceCandidate; e.RTCIceCandidate = function (n) { if (typeof n == "object" && n.candidate && n.candidate.indexOf("a=") === 0 && (n = JSON.parse(JSON.stringify(n)), n.candidate = n.candidate.substr(2)), n.candidate && n.candidate.length) { const i = new t(n), a = rr.parseCandidate(n.candidate), o = Object.assign(i, a); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(n) }, e.RTCIceCandidate.prototype = t.prototype, pt(e, "icecandidate", r => (r.candidate && Object.defineProperty(r, "candidate", { value: new e.RTCIceCandidate(r.candidate), writable: "false" }), r)) } function gt(e, t) { if (!e.RTCPeerConnection) return; "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp } }); const r = function (u) { if (!u || !u.sdp) return !1; const s = rr.splitSections(u.sdp); return s.shift(), s.some(c => { const l = rr.parseMLine(c); return l && l.kind === "application" && l.protocol.indexOf("SCTP") !== -1 }) }, n = function (u) { const s = u.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (s === null || s.length < 2) return -1; const c = parseInt(s[1], 10); return c !== c ? -1 : c }, i = function (u) { let s = 65536; return t.browser === "firefox" && (t.version < 57 ? u === -1 ? s = 16384 : s = 2147483637 : t.version < 60 ? s = t.version === 57 ? 65535 : 65536 : s = 2147483637), s }, a = function (u, s) { let c = 65536; t.browser === "firefox" && t.version === 57 && (c = 65535); const l = rr.matchPrefix(u.sdp, "a=max-message-size:"); return l.length > 0 ? c = parseInt(l[0].substr(19), 10) : t.browser === "firefox" && s !== -1 && (c = 2147483637), c }, o = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, t.browser === "chrome" && t.version >= 76) { const { sdpSemantics: s } = this.getConfiguration(); s === "plan-b" && Object.defineProperty(this, "sctp", { get() { return typeof this._sctp > "u" ? null : this._sctp }, enumerable: !0, configurable: !0 }) } if (r(arguments[0])) { const s = n(arguments[0]), c = i(s), l = a(arguments[0], s); let f; c === 0 && l === 0 ? f = Number.POSITIVE_INFINITY : c === 0 || l === 0 ? f = Math.max(c, l) : f = Math.min(c, l); const p = {}; Object.defineProperty(p, "maxMessageSize", { get() { return f } }), this._sctp = p } return o.apply(this, arguments) } } function bt(e) { if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return; function t(n, i) { const a = n.send; n.send = function () { const u = arguments[0], s = u.length || u.size || u.byteLength; if (n.readyState === "open" && i.sctp && s > i.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + i.sctp.maxMessageSize + " bytes)"); return a.apply(n, arguments) } } const r = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const i = r.apply(this, arguments); return t(i, this), i }, pt(e, "datachannel", n => (t(n.channel, n.target), n)) } function un(e) { if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return; const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get() { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get() { return this._onconnectionstatechange || null }, set(r) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), r && this.addEventListener("connectionstatechange", this._onconnectionstatechange = r) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach(r => { const n = t[r]; t[r] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = i => { const a = i.target; if (a._lastConnectionState !== a.connectionState) { a._lastConnectionState = a.connectionState; const o = new Event("connectionstatechange", i); a.dispatchEvent(o) } return i }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments) } }) } function ln(e, t) {
    if (!e.RTCPeerConnection || t.browser === "chrome" && t.version >= 71 || t.browser === "safari" && t.version >= 605) return; const r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (i) {
        if (i && i.sdp && i.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
            const a = i.sdp.split(`
`).filter(o => o.trim() !== "a=extmap-allow-mixed").join(`
`); e.RTCSessionDescription && i instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: i.type, sdp: a }) : i.sdp = a
        } return r.apply(this, arguments)
    }
} function ir(e, t) { if (!(e.RTCPeerConnection && e.RTCPeerConnection.prototype)) return; const r = e.RTCPeerConnection.prototype.addIceCandidate; !r || r.length === 0 || (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? (t.browser === "chrome" && t.version < 78 || t.browser === "firefox" && t.version < 68 || t.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } const oc = Object.freeze(Object.defineProperty({ __proto__: null, shimRTCIceCandidate: nr, shimMaxMessageSize: gt, shimSendThrowTypeError: bt, shimConnectionState: un, removeExtmapAllowMixed: ln, shimAddIceCandidateNullOrEmpty: ir }, Symbol.toStringTag, { value: "Module" })); function sc({ window: e } = {}, t = { shimChrome: !0, shimFirefox: !0, shimEdge: !0, shimSafari: !0 }) { const r = An, n = Zs(e), i = { browserDetails: n, commonShim: oc, extractVersion: yt, disableLog: Qs, disableWarnings: Xs }; switch (n.browser) { case "chrome": if (!ni || !on || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), i; if (n.version === null) return r("Chrome shim can not determine version, not shimming."), i; r("adapter.js shimming chrome."), i.browserShim = ni, ir(e, n), la(e, n), fa(e), on(e, n), pa(e), ya(e, n), da(e), ha(e), va(e), ga(e, n), nr(e), un(e), gt(e, n), bt(e), ln(e, n); break; case "firefox": if (!si || !cn || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), i; r("adapter.js shimming firefox."), i.browserShim = si, ir(e, n), Sa(e, n), cn(e, n), Ta(e), Ra(e), ka(e), Pa(e), Ea(e), xa(e), Da(e), wa(e), Oa(e), nr(e), un(e), gt(e, n), bt(e); break; case "edge": if (!oi || !sn || !t.shimEdge) return r("MS edge shim is not included in this adapter release."), i; r("adapter.js shimming edge."), i.browserShim = oi, ba(e), _a(e), sn(e, n), Ca(e), gt(e, n), bt(e); break; case "safari": if (!ci || !t.shimSafari) return r("Safari shim is not included in this adapter release."), i; r("adapter.js shimming safari."), i.browserShim = ci, ir(e, n), Fa(e), Na(e), Ma(e), Aa(e), Ia(e), Ka(e), ja(e), La(e), nr(e), gt(e, n), bt(e), ln(e, n); break; default: r("Unsupported browser!"); break }return i } const ui = sc({ window: typeof window > "u" ? void 0 : window }); function Te(e, t, r, n) { Object.defineProperty(e, t, { get: r, set: n, enumerable: !0, configurable: !0 }) } var Ir = ui.default || ui, dt = new (function () {
    function e() { this.isIOS = ["iPad", "iPhone", "iPod"].includes(navigator.platform), this.supportedBrowsers = ["firefox", "chrome", "safari"], this.minFirefoxVersion = 59, this.minChromeVersion = 72, this.minSafariVersion = 605 } return e.prototype.isWebRTCSupported = function () { return typeof RTCPeerConnection < "u" }, e.prototype.isBrowserSupported = function () { var t = this.getBrowser(), r = this.getVersion(), n = this.supportedBrowsers.includes(t); return n ? t === "chrome" ? r >= this.minChromeVersion : t === "firefox" ? r >= this.minFirefoxVersion : t === "safari" ? !this.isIOS && r >= this.minSafariVersion : !1 : !1 }, e.prototype.getBrowser = function () { return Ir.browserDetails.browser }, e.prototype.getVersion = function () { return Ir.browserDetails.version || 0 }, e.prototype.isUnifiedPlanSupported = function () { var t = this.getBrowser(), r = Ir.browserDetails.version || 0; if (t === "chrome" && r < this.minChromeVersion) return !1; if (t === "firefox" && r >= this.minFirefoxVersion) return !0; if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return !1; var n, i = !1; try { n = new RTCPeerConnection, n.addTransceiver("audio"), i = !0 } catch { } finally { n && n.close() } return i }, e.prototype.toString = function () {
        return `Supports:
    browser:`.concat(this.getBrowser(), `
    version:`).concat(this.getVersion(), `
    isIOS:`).concat(this.isIOS, `
    isWebRTCSupported:`).concat(this.isWebRTCSupported(), `
    isBrowserSupported:`).concat(this.isBrowserSupported(), `
    isUnifiedPlanSupported:`).concat(this.isUnifiedPlanSupported())
    }, e
}()), li = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: ["turn:eu-0.turn.peerjs.com:3478", "turn:us-0.turn.peerjs.com:3478"], username: "peerjs", credential: "peerjsp" }], sdpSemantics: "unified-plan" }, cc = function () { function e() { this.CLOUD_HOST = "0.peerjs.com", this.CLOUD_PORT = 443, this.chunkedBrowsers = { Chrome: 1, chrome: 1 }, this.chunkedMTU = 16300, this.defaultConfig = li, this.browser = dt.getBrowser(), this.browserVersion = dt.getVersion(), this.supports = function () { var t = { browser: dt.isBrowserSupported(), webRTC: dt.isWebRTCSupported(), audioVideo: !1, data: !1, binaryBlob: !1, reliable: !1 }; if (!t.webRTC) return t; var r; try { r = new RTCPeerConnection(li), t.audioVideo = !0; var n = void 0; try { n = r.createDataChannel("_PEERJSTEST", { ordered: !0 }), t.data = !0, t.reliable = !!n.ordered; try { n.binaryType = "blob", t.binaryBlob = !dt.isIOS } catch { } } catch { } finally { n && n.close() } } catch { } finally { r && r.close() } return t }(), this.pack = Zn.pack, this.unpack = Zn.unpack, this._dataCount = 1 } return e.prototype.noop = function () { }, e.prototype.validateId = function (t) { return !t || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(t) }, e.prototype.chunk = function (t) { for (var r = [], n = t.size, i = Math.ceil(n / L.chunkedMTU), a = 0, o = 0; o < n;) { var u = Math.min(n, o + L.chunkedMTU), s = t.slice(o, u), c = { __peerData: this._dataCount, n: a, data: s, total: i }; r.push(c), o = u, a++ } return this._dataCount++, r }, e.prototype.blobToArrayBuffer = function (t, r) { var n = new FileReader; return n.onload = function (i) { i.target && r(i.target.result) }, n.readAsArrayBuffer(t), n }, e.prototype.binaryStringToArrayBuffer = function (t) { for (var r = new Uint8Array(t.length), n = 0; n < t.length; n++)r[n] = t.charCodeAt(n) & 255; return r.buffer }, e.prototype.randomToken = function () { return Math.random().toString(36).slice(2) }, e.prototype.isSecure = function () { return location.protocol === "https:" }, e }(), L = new cc, Ua = {}; Te(Ua, "Peer", () => Ci, e => Ci = e); var Kt = {}, uc = Object.prototype.hasOwnProperty, ue = "~"; function Ot() { } Object.create && (Ot.prototype = Object.create(null), new Ot().__proto__ || (ue = !1)); function lc(e, t, r) { this.fn = e, this.context = t, this.once = r || !1 } function za(e, t, r, n, i) { if (typeof r != "function") throw new TypeError("The listener must be a function"); var a = new lc(r, n || e, i), o = ue ? ue + t : t; return e._events[o] ? e._events[o].fn ? e._events[o] = [e._events[o], a] : e._events[o].push(a) : (e._events[o] = a, e._eventsCount++), e } function ar(e, t) { --e._eventsCount === 0 ? e._events = new Ot : delete e._events[t] } function ae() { this._events = new Ot, this._eventsCount = 0 } ae.prototype.eventNames = function () { var t = [], r, n; if (this._eventsCount === 0) return t; for (n in r = this._events) uc.call(r, n) && t.push(ue ? n.slice(1) : n); return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(r)) : t }; ae.prototype.listeners = function (t) { var r = ue ? ue + t : t, n = this._events[r]; if (!n) return []; if (n.fn) return [n.fn]; for (var i = 0, a = n.length, o = new Array(a); i < a; i++)o[i] = n[i].fn; return o }; ae.prototype.listenerCount = function (t) { var r = ue ? ue + t : t, n = this._events[r]; return n ? n.fn ? 1 : n.length : 0 }; ae.prototype.emit = function (t, r, n, i, a, o) { var u = ue ? ue + t : t; if (!this._events[u]) return !1; var s = this._events[u], c = arguments.length, l, f; if (s.fn) { switch (s.once && this.removeListener(t, s.fn, void 0, !0), c) { case 1: return s.fn.call(s.context), !0; case 2: return s.fn.call(s.context, r), !0; case 3: return s.fn.call(s.context, r, n), !0; case 4: return s.fn.call(s.context, r, n, i), !0; case 5: return s.fn.call(s.context, r, n, i, a), !0; case 6: return s.fn.call(s.context, r, n, i, a, o), !0 }for (f = 1, l = new Array(c - 1); f < c; f++)l[f - 1] = arguments[f]; s.fn.apply(s.context, l) } else { var p = s.length, v; for (f = 0; f < p; f++)switch (s[f].once && this.removeListener(t, s[f].fn, void 0, !0), c) { case 1: s[f].fn.call(s[f].context); break; case 2: s[f].fn.call(s[f].context, r); break; case 3: s[f].fn.call(s[f].context, r, n); break; case 4: s[f].fn.call(s[f].context, r, n, i); break; default: if (!l) for (v = 1, l = new Array(c - 1); v < c; v++)l[v - 1] = arguments[v]; s[f].fn.apply(s[f].context, l) } } return !0 }; ae.prototype.on = function (t, r, n) { return za(this, t, r, n, !1) }; ae.prototype.once = function (t, r, n) { return za(this, t, r, n, !0) }; ae.prototype.removeListener = function (t, r, n, i) { var a = ue ? ue + t : t; if (!this._events[a]) return this; if (!r) return ar(this, a), this; var o = this._events[a]; if (o.fn) o.fn === r && (!i || o.once) && (!n || o.context === n) && ar(this, a); else { for (var u = 0, s = [], c = o.length; u < c; u++)(o[u].fn !== r || i && !o[u].once || n && o[u].context !== n) && s.push(o[u]); s.length ? this._events[a] = s.length === 1 ? s[0] : s : ar(this, a) } return this }; ae.prototype.removeAllListeners = function (t) { var r; return t ? (r = ue ? ue + t : t, this._events[r] && ar(this, r)) : (this._events = new Ot, this._eventsCount = 0), this }; ae.prototype.off = ae.prototype.removeListener; ae.prototype.addListener = ae.prototype.on; ae.prefixed = ue; ae.EventEmitter = ae; Kt = ae; var x = {}; Te(x, "LogLevel", () => fe, e => fe = e); Te(x, "default", () => fi, e => fi = e); var $e = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Ge = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, fc = "PeerJS: ", fe; (function (e) { e[e.Disabled = 0] = "Disabled", e[e.Errors = 1] = "Errors", e[e.Warnings = 2] = "Warnings", e[e.All = 3] = "All" })(fe || (fe = {})); var pc = function () { function e() { this._logLevel = fe.Disabled } return Object.defineProperty(e.prototype, "logLevel", { get: function () { return this._logLevel }, set: function (t) { this._logLevel = t }, enumerable: !1, configurable: !0 }), e.prototype.log = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= fe.All && this._print.apply(this, Ge([fe.All], $e(t), !1)) }, e.prototype.warn = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= fe.Warnings && this._print.apply(this, Ge([fe.Warnings], $e(t), !1)) }, e.prototype.error = function () { for (var t = [], r = 0; r < arguments.length; r++)t[r] = arguments[r]; this._logLevel >= fe.Errors && this._print.apply(this, Ge([fe.Errors], $e(t), !1)) }, e.prototype.setLogFunction = function (t) { this._print = t }, e.prototype._print = function (t) { for (var r = [], n = 1; n < arguments.length; n++)r[n - 1] = arguments[n]; var i = Ge([fc], $e(r), !1); for (var a in i) i[a] instanceof Error && (i[a] = "(" + i[a].name + ") " + i[a].message); t >= fe.All ? console.log.apply(console, Ge([], $e(i), !1)) : t >= fe.Warnings ? console.warn.apply(console, Ge(["WARNING"], $e(i), !1)) : t >= fe.Errors && console.error.apply(console, Ge(["ERROR"], $e(i), !1)) }, e }(), fi = new pc, $a = {}; Te($a, "Socket", () => pi, e => pi = e); var be; (function (e) { e.Data = "data", e.Media = "media" })(be || (be = {})); var J; (function (e) { e.BrowserIncompatible = "browser-incompatible", e.Disconnected = "disconnected", e.InvalidID = "invalid-id", e.InvalidKey = "invalid-key", e.Network = "network", e.PeerUnavailable = "peer-unavailable", e.SslUnavailable = "ssl-unavailable", e.ServerError = "server-error", e.SocketError = "socket-error", e.SocketClosed = "socket-closed", e.UnavailableID = "unavailable-id", e.WebRTC = "webrtc" })(J || (J = {})); var Pe; (function (e) { e.Binary = "binary", e.BinaryUTF8 = "binary-utf8", e.JSON = "json" })(Pe || (Pe = {})); var De; (function (e) { e.Message = "message", e.Disconnected = "disconnected", e.Error = "error", e.Close = "close" })(De || (De = {})); var X; (function (e) { e.Heartbeat = "HEARTBEAT", e.Candidate = "CANDIDATE", e.Offer = "OFFER", e.Answer = "ANSWER", e.Open = "OPEN", e.Error = "ERROR", e.IdTaken = "ID-TAKEN", e.InvalidKey = "INVALID-KEY", e.Leave = "LEAVE", e.Expire = "EXPIRE" })(X || (X = {})); var Mn = {}; Mn = JSON.parse('{"name":"peerjs","version":"1.4.6","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz St\xFCckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","So\u0308ren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"type":"module","sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.cjs","browser-unminified":"dist/peerjs.cjs","types":"dist/types.d.ts","engines":{"node":">= 10"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"includeNodeModules":true,"context":"browser","optimize":true,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"},"browser-unminified":{"includeNodeModules":true,"context":"browser","optimize":false,"engines":{"browsers":"cover 99%, not dead"},"source":"lib/global.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build && cp dist/peerjs.cjs dist/peerjs.js && cp dist/peerjs.min.cjs dist/peerjs.min.js","prepublishOnly":"npm run build","test":"mocha -r ts-node/register -r jsdom-global/register test/**/*.ts","format":"prettier --write .","semantic-release":"semantic-release"},"devDependencies":{"@parcel/config-default":"^2.5.0","@parcel/packager-ts":"^2.5.0","@parcel/transformer-typescript-tsc":"^2.5.0","@parcel/transformer-typescript-types":"^2.5.0","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.18","chai":"^4.3.6","git-authors-cli":"^1.0.40","jsdom":"^19.0.0","jsdom-global":"^3.0.2","mocha":"^9.2.0","mock-socket":"8.0.5","parcel":"^2.5.0","parcel-transformer-tsc-sourcemaps":"^1.0.2","prettier":"^2.6.2","semantic-release":"^19.0.2","standard":"^16.0.4","ts-node":"^10.5.0","typescript":"^4.5.5"},"dependencies":{"@swc/helpers":"^0.3.13","eventemitter3":"^4.0.7","peerjs-js-binarypack":"1.0.1","webrtc-adapter":"^7.7.1"}}'); var dc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), hc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, vc = function (e, t, r) { if (r || arguments.length === 2) for (var n = 0, i = t.length, a; n < i; n++)(a || !(n in t)) && (a || (a = Array.prototype.slice.call(t, 0, n)), a[n] = t[n]); return e.concat(a || Array.prototype.slice.call(t)) }, mc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, pi = function (e) { dc(t, e); function t(r, n, i, a, o, u) { u === void 0 && (u = 5e3); var s = e.call(this) || this; s.pingInterval = u, s._disconnected = !0, s._messagesQueue = []; var c = r ? "wss://" : "ws://"; return s._baseUrl = c + n + ":" + i + a + "peerjs?key=" + o, s } return t.prototype.start = function (r, n) { var i = this; this._id = r; var a = "".concat(this._baseUrl, "&id=").concat(r, "&token=").concat(n); !!this._socket || !this._disconnected || (this._socket = new WebSocket(a + "&version=" + Mn.version), this._disconnected = !1, this._socket.onmessage = function (o) { var u; try { u = JSON.parse(o.data), x.default.log("Server message received:", u) } catch { x.default.log("Invalid server message", o.data); return } i.emit(De.Message, u) }, this._socket.onclose = function (o) { i._disconnected || (x.default.log("Socket closed.", o), i._cleanup(), i._disconnected = !0, i.emit(De.Disconnected)) }, this._socket.onopen = function () { i._disconnected || (i._sendQueuedMessages(), x.default.log("Socket open"), i._scheduleHeartbeat()) }) }, t.prototype._scheduleHeartbeat = function () { var r = this; this._wsPingTimer = setTimeout(function () { r._sendHeartbeat() }, this.pingInterval) }, t.prototype._sendHeartbeat = function () { if (!this._wsOpen()) { x.default.log("Cannot send heartbeat, because socket closed"); return } var r = JSON.stringify({ type: X.Heartbeat }); this._socket.send(r), this._scheduleHeartbeat() }, t.prototype._wsOpen = function () { return !!this._socket && this._socket.readyState === 1 }, t.prototype._sendQueuedMessages = function () { var r, n, i = vc([], hc(this._messagesQueue), !1); this._messagesQueue = []; try { for (var a = mc(i), o = a.next(); !o.done; o = a.next()) { var u = o.value; this.send(u) } } catch (s) { r = { error: s } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } }, t.prototype.send = function (r) { if (!this._disconnected) { if (!this._id) { this._messagesQueue.push(r); return } if (!r.type) { this.emit(De.Error, "Invalid message"); return } if (!!this._wsOpen()) { var n = JSON.stringify(r); this._socket.send(n) } } }, t.prototype.close = function () { this._disconnected || (this._cleanup(), this._disconnected = !0) }, t.prototype._cleanup = function () { this._socket && (this._socket.onopen = this._socket.onmessage = this._socket.onclose = null, this._socket.close(), this._socket = void 0), clearTimeout(this._wsPingTimer) }, t }(Kt.EventEmitter), fn = {}; Te(fn, "MediaConnection", () => vi, e => vi = e); var jn = {}; Te(jn, "Negotiator", () => di, e => di = e); var yr = function () { return yr = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, yr.apply(this, arguments) }, Vt = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(l) { try { c(n.next(l)) } catch (f) { o(f) } } function s(l) { try { c(n.throw(l)) } catch (f) { o(f) } } function c(l) { l.done ? a(l.value) : i(l.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, Ht = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (l) { return s([c, l]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (l) { c = [6, l], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, di = function () { function e(t) { this.connection = t } return e.prototype.startConnection = function (t) { var r = this._startPeerConnection(); if (this.connection.peerConnection = r, this.connection.type === be.Media && t._stream && this._addTracksToConnection(t._stream, r), t.originator) { if (this.connection.type === be.Data) { var n = this.connection, i = { ordered: !!t.reliable }, a = r.createDataChannel(n.label, i); n.initialize(a) } this._makeOffer() } else this.handleSDP("OFFER", t.sdp) }, e.prototype._startPeerConnection = function () { x.default.log("Creating RTCPeerConnection."); var t = new RTCPeerConnection(this.connection.provider.options.config); return this._setupListeners(t), t }, e.prototype._setupListeners = function (t) { var r = this, n = this.connection.peer, i = this.connection.connectionId, a = this.connection.type, o = this.connection.provider; x.default.log("Listening for ICE candidates."), t.onicecandidate = function (u) { !u.candidate || !u.candidate.candidate || (x.default.log("Received ICE candidates for ".concat(n, ":"), u.candidate), o.socket.send({ type: X.Candidate, payload: { candidate: u.candidate, type: a, connectionId: i }, dst: n })) }, t.oniceconnectionstatechange = function () { switch (t.iceConnectionState) { case "failed": x.default.log("iceConnectionState is failed, closing connections to " + n), r.connection.emit("error", new Error("Negotiation of connection to " + n + " failed.")), r.connection.close(); break; case "closed": x.default.log("iceConnectionState is closed, closing connections to " + n), r.connection.emit("error", new Error("Connection to " + n + " closed.")), r.connection.close(); break; case "disconnected": x.default.log("iceConnectionState changed to disconnected on the connection with " + n); break; case "completed": t.onicecandidate = L.noop; break }r.connection.emit("iceStateChanged", t.iceConnectionState) }, x.default.log("Listening for data channel"), t.ondatachannel = function (u) { x.default.log("Received data channel"); var s = u.channel, c = o.getConnection(n, i); c.initialize(s) }, x.default.log("Listening for remote stream"), t.ontrack = function (u) { x.default.log("Received remote stream"); var s = u.streams[0], c = o.getConnection(n, i); if (c.type === be.Media) { var l = c; r._addStreamToMediaConnection(s, l) } } }, e.prototype.cleanup = function () { x.default.log("Cleaning up PeerConnection to " + this.connection.peer); var t = this.connection.peerConnection; if (!!t) { this.connection.peerConnection = null, t.onicecandidate = t.oniceconnectionstatechange = t.ondatachannel = t.ontrack = function () { }; var r = t.signalingState !== "closed", n = !1; if (this.connection.type === be.Data) { var i = this.connection, a = i.dataChannel; a && (n = !!a.readyState && a.readyState !== "closed") } (r || n) && t.close() } }, e.prototype._makeOffer = function () { return Vt(this, void 0, Promise, function () { var t, r, n, i, a, o, u; return Ht(this, function (s) { switch (s.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 7, , 8]), [4, t.createOffer(this.connection.options.constraints)]; case 2: n = s.sent(), x.default.log("Created offer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), s.label = 3; case 3: return s.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return s.sent(), x.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), i = { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, metadata: this.connection.metadata, browser: L.browser }, this.connection.type === be.Data && (a = this.connection, i = yr(yr({}, i), { label: a.label, reliable: a.reliable, serialization: a.serialization })), r.socket.send({ type: X.Offer, payload: i, dst: this.connection.peer }), [3, 6]; case 5: return o = s.sent(), o != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer" && (r.emitError(J.WebRTC, o), x.default.log("Failed to setLocalDescription, ", o)), [3, 6]; case 6: return [3, 8]; case 7: return u = s.sent(), r.emitError(J.WebRTC, u), x.default.log("Failed to createOffer, ", u), [3, 8]; case 8: return [2] } }) }) }, e.prototype._makeAnswer = function () { return Vt(this, void 0, Promise, function () { var t, r, n, i, a; return Ht(this, function (o) { switch (o.label) { case 0: t = this.connection.peerConnection, r = this.connection.provider, o.label = 1; case 1: return o.trys.push([1, 7, , 8]), [4, t.createAnswer()]; case 2: n = o.sent(), x.default.log("Created answer."), this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform == "function" && (n.sdp = this.connection.options.sdpTransform(n.sdp) || n.sdp), o.label = 3; case 3: return o.trys.push([3, 5, , 6]), [4, t.setLocalDescription(n)]; case 4: return o.sent(), x.default.log("Set localDescription:", n, "for:".concat(this.connection.peer)), r.socket.send({ type: X.Answer, payload: { sdp: n, type: this.connection.type, connectionId: this.connection.connectionId, browser: L.browser }, dst: this.connection.peer }), [3, 6]; case 5: return i = o.sent(), r.emitError(J.WebRTC, i), x.default.log("Failed to setLocalDescription, ", i), [3, 6]; case 6: return [3, 8]; case 7: return a = o.sent(), r.emitError(J.WebRTC, a), x.default.log("Failed to create answer, ", a), [3, 8]; case 8: return [2] } }) }) }, e.prototype.handleSDP = function (t, r) { return Vt(this, void 0, Promise, function () { var n, i, a, o; return Ht(this, function (u) { switch (u.label) { case 0: r = new RTCSessionDescription(r), n = this.connection.peerConnection, i = this.connection.provider, x.default.log("Setting remote description", r), a = this, u.label = 1; case 1: return u.trys.push([1, 5, , 6]), [4, n.setRemoteDescription(r)]; case 2: return u.sent(), x.default.log("Set remoteDescription:".concat(t, " for:").concat(this.connection.peer)), t !== "OFFER" ? [3, 4] : [4, a._makeAnswer()]; case 3: u.sent(), u.label = 4; case 4: return [3, 6]; case 5: return o = u.sent(), i.emitError(J.WebRTC, o), x.default.log("Failed to setRemoteDescription, ", o), [3, 6]; case 6: return [2] } }) }) }, e.prototype.handleCandidate = function (t) { return Vt(this, void 0, Promise, function () { var r, n, i, a, o, u; return Ht(this, function (s) { switch (s.label) { case 0: x.default.log("handleCandidate:", t), r = t.candidate, n = t.sdpMLineIndex, i = t.sdpMid, a = this.connection.peerConnection, o = this.connection.provider, s.label = 1; case 1: return s.trys.push([1, 3, , 4]), [4, a.addIceCandidate(new RTCIceCandidate({ sdpMid: i, sdpMLineIndex: n, candidate: r }))]; case 2: return s.sent(), x.default.log("Added ICE candidate for:".concat(this.connection.peer)), [3, 4]; case 3: return u = s.sent(), o.emitError(J.WebRTC, u), x.default.log("Failed to handleCandidate, ", u), [3, 4]; case 4: return [2] } }) }) }, e.prototype._addTracksToConnection = function (t, r) { if (x.default.log("add tracks from stream ".concat(t.id, " to peer connection")), !r.addTrack) return x.default.error("Your browser does't support RTCPeerConnection#addTrack. Ignored."); t.getTracks().forEach(function (n) { r.addTrack(n, t) }) }, e.prototype._addStreamToMediaConnection = function (t, r) { x.default.log("add stream ".concat(t.id, " to media connection ").concat(r.connectionId)), r.addStream(t) }, e }(), Bn = {}; Te(Bn, "BaseConnection", () => hi, e => hi = e); var yc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), hi = function (e) { yc(t, e); function t(r, n, i) { var a = e.call(this) || this; return a.peer = r, a.provider = n, a.options = i, a._open = !1, a.metadata = i.metadata, a } return Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), t }(Kt.EventEmitter), gc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), gr = function () { return gr = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, gr.apply(this, arguments) }, bc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, vi = function (e) { gc(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a._localStream = a.options._stream, a.connectionId = a.options.connectionId || t.ID_PREFIX + L.randomToken(), a._negotiator = new jn.Negotiator(a), a._localStream && a._negotiator.startConnection({ _stream: a._localStream, originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return be.Media }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "localStream", { get: function () { return this._localStream }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "remoteStream", { get: function () { return this._remoteStream }, enumerable: !1, configurable: !0 }), t.prototype.addStream = function (r) { x.default.log("Receiving stream", r), this._remoteStream = r, e.prototype.emit.call(this, "stream", r) }, t.prototype.handleMessage = function (r) { var n = r.type, i = r.payload; switch (r.type) { case X.Answer: this._negotiator.handleSDP(n, i.sdp), this._open = !0; break; case X.Candidate: this._negotiator.handleCandidate(i.candidate); break; default: x.default.warn("Unrecognized message type:".concat(n, " from peer:").concat(this.peer)); break } }, t.prototype.answer = function (r, n) { var i, a; if (n === void 0 && (n = {}), this._localStream) { x.default.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?"); return } this._localStream = r, n && n.sdpTransform && (this.options.sdpTransform = n.sdpTransform), this._negotiator.startConnection(gr(gr({}, this.options._payload), { _stream: r })); var o = this.provider._getMessages(this.connectionId); try { for (var u = bc(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; this.handleMessage(c) } } catch (l) { i = { error: l } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } this._open = !0 }, t.prototype.close = function () { this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this._localStream = null, this._remoteStream = null, this.provider && (this.provider._removeConnection(this), this.provider = null), this.options && this.options._stream && (this.options._stream = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.ID_PREFIX = "mc_", t }(Bn.BaseConnection), pn = {}; Te(pn, "DataConnection", () => yi, e => yi = e); var Ga = {}; Te(Ga, "EncodingQueue", () => mi, e => mi = e); var _c = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), mi = function (e) { _c(t, e); function t() { var r = e.call(this) || this; return r.fileReader = new FileReader, r._queue = [], r._processing = !1, r.fileReader.onload = function (n) { r._processing = !1, n.target && r.emit("done", n.target.result), r.doNextTask() }, r.fileReader.onerror = function (n) { x.default.error("EncodingQueue error:", n), r._processing = !1, r.destroy(), r.emit("error", n) }, r } return Object.defineProperty(t.prototype, "queue", { get: function () { return this._queue }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "size", { get: function () { return this.queue.length }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "processing", { get: function () { return this._processing }, enumerable: !1, configurable: !0 }), t.prototype.enque = function (r) { this.queue.push(r), !this.processing && this.doNextTask() }, t.prototype.destroy = function () { this.fileReader.abort(), this._queue = [] }, t.prototype.doNextTask = function () { this.size !== 0 && (this.processing || (this._processing = !0, this.fileReader.readAsArrayBuffer(this.queue.shift()))) }, t }(Kt.EventEmitter), Cc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Sc = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, yi = function (e) { Cc(t, e); function t(r, n, i) { var a = e.call(this, r, n, i) || this; return a.stringify = JSON.stringify, a.parse = JSON.parse, a._buffer = [], a._bufferSize = 0, a._buffering = !1, a._chunkedData = {}, a._encodingQueue = new Ga.EncodingQueue, a.connectionId = a.options.connectionId || t.ID_PREFIX + L.randomToken(), a.label = a.options.label || a.connectionId, a.serialization = a.options.serialization || Pe.Binary, a.reliable = !!a.options.reliable, a._encodingQueue.on("done", function (o) { a._bufferedSend(o) }), a._encodingQueue.on("error", function () { x.default.error("DC#".concat(a.connectionId, ": Error occured in encoding from blob to arraybuffer, close DC")), a.close() }), a._negotiator = new jn.Negotiator(a), a._negotiator.startConnection(a.options._payload || { originator: !0 }), a } return Object.defineProperty(t.prototype, "type", { get: function () { return be.Data }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "dataChannel", { get: function () { return this._dc }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "bufferSize", { get: function () { return this._bufferSize }, enumerable: !1, configurable: !0 }), t.prototype.initialize = function (r) { this._dc = r, this._configureDataChannel() }, t.prototype._configureDataChannel = function () { var r = this; (!L.supports.binaryBlob || L.supports.reliable) && (this.dataChannel.binaryType = "arraybuffer"), this.dataChannel.onopen = function () { x.default.log("DC#".concat(r.connectionId, " dc connection success")), r._open = !0, r.emit("open") }, this.dataChannel.onmessage = function (n) { x.default.log("DC#".concat(r.connectionId, " dc onmessage:"), n.data), r._handleDataMessage(n) }, this.dataChannel.onclose = function () { x.default.log("DC#".concat(r.connectionId, " dc closed for:"), r.peer), r.close() } }, t.prototype._handleDataMessage = function (r) { var n = this, i = r.data, a = i.constructor, o = this.serialization === Pe.Binary || this.serialization === Pe.BinaryUTF8, u = i; if (o) { if (a === Blob) { L.blobToArrayBuffer(i, function (c) { var l = L.unpack(c); n.emit("data", l) }); return } else if (a === ArrayBuffer) u = L.unpack(i); else if (a === String) { var s = L.binaryStringToArrayBuffer(i); u = L.unpack(s) } } else this.serialization === Pe.JSON && (u = this.parse(i)); if (u.__peerData) { this._handleChunk(u); return } e.prototype.emit.call(this, "data", u) }, t.prototype._handleChunk = function (r) { var n = r.__peerData, i = this._chunkedData[n] || { data: [], count: 0, total: r.total }; if (i.data[r.n] = r.data, i.count++, this._chunkedData[n] = i, i.total === i.count) { delete this._chunkedData[n]; var a = new Blob(i.data); this._handleDataMessage({ data: a }) } }, t.prototype.close = function () { this._buffer = [], this._bufferSize = 0, this._chunkedData = {}, this._negotiator && (this._negotiator.cleanup(), this._negotiator = null), this.provider && (this.provider._removeConnection(this), this.provider = null), this.dataChannel && (this.dataChannel.onopen = null, this.dataChannel.onmessage = null, this.dataChannel.onclose = null, this._dc = null), this._encodingQueue && (this._encodingQueue.destroy(), this._encodingQueue.removeAllListeners(), this._encodingQueue = null), this.open && (this._open = !1, e.prototype.emit.call(this, "close")) }, t.prototype.send = function (r, n) { if (!this.open) { e.prototype.emit.call(this, "error", new Error("Connection is not open. You should listen for the `open` event before sending messages.")); return } if (this.serialization === Pe.JSON) this._bufferedSend(this.stringify(r)); else if (this.serialization === Pe.Binary || this.serialization === Pe.BinaryUTF8) { var i = L.pack(r); if (!n && i.size > L.chunkedMTU) { this._sendChunks(i); return } L.supports.binaryBlob ? this._bufferedSend(i) : this._encodingQueue.enque(i) } else this._bufferedSend(r) }, t.prototype._bufferedSend = function (r) { (this._buffering || !this._trySend(r)) && (this._buffer.push(r), this._bufferSize = this._buffer.length) }, t.prototype._trySend = function (r) { var n = this; if (!this.open) return !1; if (this.dataChannel.bufferedAmount > t.MAX_BUFFERED_AMOUNT) return this._buffering = !0, setTimeout(function () { n._buffering = !1, n._tryBuffer() }, 50), !1; try { this.dataChannel.send(r) } catch (i) { return x.default.error("DC#:".concat(this.connectionId, " Error when sending:"), i), this._buffering = !0, this.close(), !1 } return !0 }, t.prototype._tryBuffer = function () { if (!!this.open && this._buffer.length !== 0) { var r = this._buffer[0]; this._trySend(r) && (this._buffer.shift(), this._bufferSize = this._buffer.length, this._tryBuffer()) } }, t.prototype._sendChunks = function (r) { var n, i, a = L.chunk(r); x.default.log("DC#".concat(this.connectionId, " Try to send ").concat(a.length, " chunks...")); try { for (var o = Sc(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; this.send(s, !0) } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.handleMessage = function (r) { var n = r.payload; switch (r.type) { case X.Answer: this._negotiator.handleSDP(r.type, n.sdp); break; case X.Candidate: this._negotiator.handleCandidate(n.candidate); break; default: x.default.warn("Unrecognized message type:", r.type, "from peer:", this.peer); break } }, t.ID_PREFIX = "dc_", t.MAX_BUFFERED_AMOUNT = 8388608, t }(Bn.BaseConnection), Ja = {}; Te(Ja, "API", () => _i, e => _i = e); var gi = function (e, t, r, n) { function i(a) { return a instanceof r ? a : new r(function (o) { o(a) }) } return new (r || (r = Promise))(function (a, o) { function u(l) { try { c(n.next(l)) } catch (f) { o(f) } } function s(l) { try { c(n.throw(l)) } catch (f) { o(f) } } function c(l) { l.done ? a(l.value) : i(l.value).then(u, s) } c((n = n.apply(e, t || [])).next()) }) }, bi = function (e, t) { var r = { label: 0, sent: function () { if (a[0] & 1) throw a[1]; return a[1] }, trys: [], ops: [] }, n, i, a, o; return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function () { return this }), o; function u(c) { return function (l) { return s([c, l]) } } function s(c) { if (n) throw new TypeError("Generator is already executing."); for (; r;)try { if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done) return a; switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) { case 0: case 1: a = c; break; case 4: return r.label++, { value: c[1], done: !1 }; case 5: r.label++, i = c[1], c = [0]; continue; case 7: c = r.ops.pop(), r.trys.pop(); continue; default: if (a = r.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) { r = 0; continue } if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) { r.label = c[1]; break } if (c[0] === 6 && r.label < a[1]) { r.label = a[1], a = c; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(c); break } a[2] && r.ops.pop(), r.trys.pop(); continue }c = t.call(e, r) } catch (l) { c = [6, l], i = 0 } finally { n = a = 0 } if (c[0] & 5) throw c[1]; return { value: c[0] ? c[1] : void 0, done: !0 } } }, _i = function () { function e(t) { this._options = t } return e.prototype._buildRequest = function (t) { var r = this._options.secure ? "https" : "http", n = this._options, i = n.host, a = n.port, o = n.path, u = n.key, s = new URL("".concat(r, "://").concat(i, ":").concat(a).concat(o).concat(u, "/").concat(t)); return s.searchParams.set("ts", "".concat(Date.now()).concat(Math.random())), s.searchParams.set("version", Mn.version), fetch(s.href, { referrerPolicy: this._options.referrerPolicy }) }, e.prototype.retrieveId = function () { return gi(this, void 0, Promise, function () { var t, r, n; return bi(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("id")]; case 1: if (t = i.sent(), t.status !== 200) throw new Error("Error. Status:".concat(t.status)); return [2, t.text()]; case 2: throw r = i.sent(), x.default.error("Error retrieving ID", r), n = "", this._options.path === "/" && this._options.host !== L.CLOUD_HOST && (n = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer."), new Error("Could not get an ID from the server." + n); case 3: return [2] } }) }) }, e.prototype.listAllPeers = function () { return gi(this, void 0, Promise, function () { var t, r, n; return bi(this, function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this._buildRequest("peers")]; case 1: if (t = i.sent(), t.status !== 200) throw t.status === 401 ? (r = "", this._options.host === L.CLOUD_HOST ? r = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key." : r = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.", new Error("It doesn't look like you have permission to list peers IDs. " + r)) : new Error("Error. Status:".concat(t.status)); return [2, t.json()]; case 2: throw n = i.sent(), x.default.error("Error retrieving list peers", n), new Error("Could not get list peers from the server." + n); case 3: return [2] } }) }) }, e }(), Tc = function () { var e = function (t, r) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (n, i) { n.__proto__ = i } || function (n, i) { for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (n[a] = i[a]) }, e(t, r) }; return function (t, r) { if (typeof r != "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null"); e(t, r); function n() { this.constructor = t } t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n) } }(), Tt = function () { return Tt = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++) { t = arguments[r]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) } return e }, Tt.apply(this, arguments) }, ht = function (e) { var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0; if (r) return r.call(e); if (e && typeof e.length == "number") return { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }, kc = function (e, t) { var r = typeof Symbol == "function" && e[Symbol.iterator]; if (!r) return e; var n = r.call(e), i, a = [], o; try { for (; (t === void 0 || t-- > 0) && !(i = n.next()).done;)a.push(i.value) } catch (u) { o = { error: u } } finally { try { i && !i.done && (r = n.return) && r.call(n) } finally { if (o) throw o.error } } return a }, Ci = function (e) { Tc(t, e); function t(r, n) { var i = e.call(this) || this; i._id = null, i._lastServerId = null, i._destroyed = !1, i._disconnected = !1, i._open = !1, i._connections = new Map, i._lostMessages = new Map; var a; return r && r.constructor == Object ? n = r : r && (a = r.toString()), n = Tt({ debug: 0, host: L.CLOUD_HOST, port: L.CLOUD_PORT, path: "/", key: t.DEFAULT_KEY, token: L.randomToken(), config: L.defaultConfig, referrerPolicy: "strict-origin-when-cross-origin" }, n), i._options = n, i._options.host === "/" && (i._options.host = window.location.hostname), i._options.path && (i._options.path[0] !== "/" && (i._options.path = "/" + i._options.path), i._options.path[i._options.path.length - 1] !== "/" && (i._options.path += "/")), i._options.secure === void 0 && i._options.host !== L.CLOUD_HOST ? i._options.secure = L.isSecure() : i._options.host == L.CLOUD_HOST && (i._options.secure = !0), i._options.logFunction && x.default.setLogFunction(i._options.logFunction), x.default.logLevel = i._options.debug || 0, i._api = new Ja.API(n), i._socket = i._createServerConnection(), !L.supports.audioVideo && !L.supports.data ? (i._delayedAbort(J.BrowserIncompatible, "The current browser does not support WebRTC"), i) : !!a && !L.validateId(a) ? (i._delayedAbort(J.InvalidID, 'ID "'.concat(a, '" is invalid')), i) : (a ? i._initialize(a) : i._api.retrieveId().then(function (o) { return i._initialize(o) }).catch(function (o) { return i._abort(J.ServerError, o) }), i) } return Object.defineProperty(t.prototype, "id", { get: function () { return this._id }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "options", { get: function () { return this._options }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "open", { get: function () { return this._open }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "socket", { get: function () { return this._socket }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "connections", { get: function () { var r, n, i = Object.create(null); try { for (var a = ht(this._connections), o = a.next(); !o.done; o = a.next()) { var u = kc(o.value, 2), s = u[0], c = u[1]; i[s] = c } } catch (l) { r = { error: l } } finally { try { o && !o.done && (n = a.return) && n.call(a) } finally { if (r) throw r.error } } return i }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "destroyed", { get: function () { return this._destroyed }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "disconnected", { get: function () { return this._disconnected }, enumerable: !1, configurable: !0 }), t.prototype._createServerConnection = function () { var r = this, n = new $a.Socket(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval); return n.on(De.Message, function (i) { r._handleMessage(i) }), n.on(De.Error, function (i) { r._abort(J.SocketError, i) }), n.on(De.Disconnected, function () { r.disconnected || (r.emitError(J.Network, "Lost connection to server."), r.disconnect()) }), n.on(De.Close, function () { r.disconnected || r._abort(J.SocketClosed, "Underlying socket is already closed.") }), n }, t.prototype._initialize = function (r) { this._id = r, this.socket.start(r, this._options.token) }, t.prototype._handleMessage = function (r) { var n, i, a = r.type, o = r.payload, u = r.src; switch (a) { case X.Open: this._lastServerId = this.id, this._open = !0, this.emit("open", this.id); break; case X.Error: this._abort(J.ServerError, o.msg); break; case X.IdTaken: this._abort(J.UnavailableID, 'ID "'.concat(this.id, '" is taken')); break; case X.InvalidKey: this._abort(J.InvalidKey, 'API KEY "'.concat(this._options.key, '" is invalid')); break; case X.Leave: x.default.log("Received leave message from ".concat(u)), this._cleanupPeer(u), this._connections.delete(u); break; case X.Expire: this.emitError(J.PeerUnavailable, "Could not connect to peer ".concat(u)); break; case X.Offer: var d = o.connectionId, h = this.getConnection(u, d); if (h && (h.close(), x.default.warn("Offer received for existing Connection ID:".concat(d))), o.type === be.Media) { var s = new fn.MediaConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata }); h = s, this._addConnection(u, h), this.emit("call", s) } else if (o.type === be.Data) { var c = new pn.DataConnection(u, this, { connectionId: d, _payload: o, metadata: o.metadata, label: o.label, serialization: o.serialization, reliable: o.reliable }); h = c, this._addConnection(u, h), this.emit("connection", c) } else { x.default.warn("Received malformed connection type:".concat(o.type)); return } var l = this._getMessages(d); try { for (var f = ht(l), p = f.next(); !p.done; p = f.next()) { var v = p.value; h.handleMessage(v) } } catch (b) { n = { error: b } } finally { try { p && !p.done && (i = f.return) && i.call(f) } finally { if (n) throw n.error } } break; default: if (!o) { x.default.warn("You received a malformed message from ".concat(u, " of type ").concat(a)); return } var d = o.connectionId, h = this.getConnection(u, d); h && h.peerConnection ? h.handleMessage(r) : d ? this._storeMessage(d, r) : x.default.warn("You received an unrecognized message:", r); break } }, t.prototype._storeMessage = function (r, n) { this._lostMessages.has(r) || this._lostMessages.set(r, []), this._lostMessages.get(r).push(n) }, t.prototype._getMessages = function (r) { var n = this._lostMessages.get(r); return n ? (this._lostMessages.delete(r), n) : [] }, t.prototype.connect = function (r, n) { if (n === void 0 && (n = {}), this.disconnected) { x.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } var i = new pn.DataConnection(r, this, n); return this._addConnection(r, i), i }, t.prototype.call = function (r, n, i) { if (i === void 0 && (i = {}), this.disconnected) { x.default.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect."), this.emitError(J.Disconnected, "Cannot connect to new Peer after disconnecting from server."); return } if (!n) { x.default.error("To call a peer, you must provide a stream from your browser's `getUserMedia`."); return } var a = new fn.MediaConnection(r, this, Tt(Tt({}, i), { _stream: n })); return this._addConnection(r, a), a }, t.prototype._addConnection = function (r, n) { x.default.log("add connection ".concat(n.type, ":").concat(n.connectionId, " to peerId:").concat(r)), this._connections.has(r) || this._connections.set(r, []), this._connections.get(r).push(n) }, t.prototype._removeConnection = function (r) { var n = this._connections.get(r.peer); if (n) { var i = n.indexOf(r); i !== -1 && n.splice(i, 1) } this._lostMessages.delete(r.connectionId) }, t.prototype.getConnection = function (r, n) { var i, a, o = this._connections.get(r); if (!o) return null; try { for (var u = ht(o), s = u.next(); !s.done; s = u.next()) { var c = s.value; if (c.connectionId === n) return c } } catch (l) { i = { error: l } } finally { try { s && !s.done && (a = u.return) && a.call(u) } finally { if (i) throw i.error } } return null }, t.prototype._delayedAbort = function (r, n) { var i = this; setTimeout(function () { i._abort(r, n) }, 0) }, t.prototype._abort = function (r, n) { x.default.error("Aborting!"), this.emitError(r, n), this._lastServerId ? this.disconnect() : this.destroy() }, t.prototype.emitError = function (r, n) { x.default.error("Error:", n); var i; typeof n == "string" ? i = new Error(n) : i = n, i.type = r, this.emit("error", i) }, t.prototype.destroy = function () { this.destroyed || (x.default.log("Destroy peer with ID:".concat(this.id)), this.disconnect(), this._cleanup(), this._destroyed = !0, this.emit("close")) }, t.prototype._cleanup = function () { var r, n; try { for (var i = ht(this._connections.keys()), a = i.next(); !a.done; a = i.next()) { var o = a.value; this._cleanupPeer(o), this._connections.delete(o) } } catch (u) { r = { error: u } } finally { try { a && !a.done && (n = i.return) && n.call(i) } finally { if (r) throw r.error } } this.socket.removeAllListeners() }, t.prototype._cleanupPeer = function (r) { var n, i, a = this._connections.get(r); if (!!a) try { for (var o = ht(a), u = o.next(); !u.done; u = o.next()) { var s = u.value; s.close() } } catch (c) { n = { error: c } } finally { try { u && !u.done && (i = o.return) && i.call(o) } finally { if (n) throw n.error } } }, t.prototype.disconnect = function () { if (!this.disconnected) { var r = this.id; x.default.log("Disconnect peer with ID:".concat(r)), this._disconnected = !0, this._open = !1, this.socket.close(), this._lastServerId = r, this._id = null, this.emit("disconnected", r) } }, t.prototype.reconnect = function () { if (this.disconnected && !this.destroyed) x.default.log("Attempting reconnection to server with ID ".concat(this._lastServerId)), this._disconnected = !1, this._initialize(this._lastServerId); else { if (this.destroyed) throw new Error("This peer cannot reconnect to the server. It has already been destroyed."); if (!this.disconnected && !this.open) x.default.error("In a hurry? We're still trying to make the initial connection!"); else throw new Error("Peer ".concat(this.id, " cannot reconnect because it is not disconnected from the server!")) } }, t.prototype.listAllPeers = function (r) { var n = this; r === void 0 && (r = function (i) { }), this._api.listAllPeers().then(function (i) { return r(i) }).catch(function (i) { return n._abort(J.ServerError, i) }) }, t.DEFAULT_KEY = "peerjs", t }(Kt.EventEmitter), Pc = Ua.Peer; let ve, V, He, br, at = {}, Oe = {}, or = {}, ot = {}; OctoPrint.options.baseurl = "http://localhost:5000/"; xs().then(async () => { let e = await j.printer.toArray(); e.length > 0 && (He = e[0]); let t = await j.nanofactoryPeers.toArray(); if (t.length > 0 ? br = t[0] : br = new na, V = await j.networking.get("1"), V || (V = new ta("1"), await V.add()), !V.peerID || !V.apiKey) { let r = setInterval(async () => { window.peerID && !V.peerID && (V.save({ peerID: window.peerID }), V.peerID = window.peerID, He || (He = new ia(window.peerID), He.add())), window.apiKey && !V.apiKey && (V.save({ apiKey: window.apiKey }), V.apiKey = window.apiKey), V.peerID && V.apiKey && (clearInterval(r), Si()) }, 1e3) } else Si() }); async function Si() { OctoPrint.options.apikey = V.apiKey, ve = new Pc(V.peerID), Rc(), await Ms(), await js(), await Bs(), await OctoPrint.socket.connect(), OctoPrint.socket.onMessage("*", e => Js(e)) } function Rc() { ve.on("open", function (e) { console.log("Connected to peer server with id:" + e) }), ve.on("connection", function (e) { console.log("Connected with peer:" + e.peer), e.on("data", function (t) { console.log("Received Label: " + e.label), zs(t, e.peer, e.label, e.metadata), e.close() }) }), ve.on("disconnected", function () { console.log("Disconnected from signaling server, reconnecting..."), ve.reconnect() }), ve.on("close", function () { console.log("Peer destroyed, cannot reconnect") }), ve.on("error", function (e) { console.error(e) }) }
